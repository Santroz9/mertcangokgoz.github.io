



<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <title>nasldoc: nasl</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Le styles -->
  <style type="text/css">
	body {
	padding-top: 60px;
	padding-bottom: 40px;
	}
	.sidebar-nav {
	padding: 9px 0;
	}
  </style>

  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/shCore.css" rel="stylesheet" type="text/css" />
  <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />

  <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <!-- Fav and touch icons -->
  <link rel="shortcut icon" href="ico/favicon.ico">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
  <link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

	<div class="navbar navbar-inverse navbar-fixed-top">
	  <div class="navbar-inner">
		<div class="container-fluid">
		  <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		  </a>
		  <a class="brand" href="index.html">nasldoc</a>
		  <div class="nav-collapse collapse">
			<ul class="nav">
			  <li class="active"><a href="index.html">Home</a></li>
			</ul>
		  </div><!--/.nav-collapse -->
		</div>
	  </div>
	</div>

  <div class="container-fluid">
	<div class="row-fluid">
	<div class="span3">
	  <div class="well sidebar-nav">
	  <ul class="nav nav-list">
		
			
			
			<li class="even">
			  <a href="GSHB_BruteForce.html">GSHB_BruteForce.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="GSHB_read_file.html">GSHB_read_file.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="bad_ssh_host_keys.html">bad_ssh_host_keys.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="bad_ssh_keys.html">bad_ssh_keys.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="bin.html">bin.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="byte_func.html">byte_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="cisco_ios.html">cisco_ios.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="cpe.html">cpe.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="default_account.html">default_account.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="default_credentials.html">default_credentials.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="dump.html">dump.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="ftp_func.html">ftp_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="gb_openssl_heartbeat.html">gb_openssl_heartbeat.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="global_settings.html">global_settings.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="gvr_apps_auth_func.html">gvr_apps_auth_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="host_details.html">host_details.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="hp_printers.html">hp_printers.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="http_func.html">http_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="http_keepalive.html">http_keepalive.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="imap_func.html">imap_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="itg.html">itg.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="junos.html">junos.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="kyocera_printers.html">kyocera_printers.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="ldap.html">ldap.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="lexmark_printers.html">lexmark_printers.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="misc_func.html">misc_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="netop.html">netop.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="network_func.html">network_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="nfs_func.html">nfs_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="nmap.html">nmap.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="nntp_func.html">nntp_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="os_eol.html">os_eol.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pingpong.html">pingpong.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="pkg-lib-bsd.html">pkg-lib-bsd.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pkg-lib-deb.html">pkg-lib-deb.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="pkg-lib-gentoo.html">pkg-lib-gentoo.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pkg-lib-hpux.html">pkg-lib-hpux.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="pkg-lib-macosx.html">pkg-lib-macosx.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pkg-lib-rpm.html">pkg-lib-rpm.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="pkg-lib-slack.html">pkg-lib-slack.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pop3_func.html">pop3_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="revisions-lib.html">revisions-lib.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="rsync_func.html">rsync_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="secpod_activex.html">secpod_activex.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="secpod_ie_supersede.html">secpod_ie_supersede.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="secpod_reg.html">secpod_reg.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="secpod_smb_func.html">secpod_smb_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="secpod_ssl_ciphers.html">secpod_ssl_ciphers.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="sharp_printers.html">sharp_printers.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="sip.html">sip.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="smb_default_credentials.html">smb_default_credentials.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="smb_nt.html">smb_nt.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="smbcl_func.html">smbcl_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="smtp_func.html">smtp_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="snmp_func.html">snmp_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="solaris.html">solaris.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="ssh_func.html">ssh_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="ssl_funcs.html">ssl_funcs.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="telnet_func.html">telnet_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="tftp.html">tftp.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="uddi.html">uddi.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="url_func.html">url_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="version_func.html">version_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="vmware_esx.html">vmware_esx.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wmi_file.html">wmi_file.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="wmi_hardware.html">wmi_hardware.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wmi_misc.html">wmi_misc.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="wmi_os.html">wmi_os.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wmi_proc.html">wmi_proc.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="wmi_rsop.html">wmi_rsop.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wmi_svc.html">wmi_svc.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="wmi_user.html">wmi_user.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wordlist.html">wordlist.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="xerox_printers.html">xerox_printers.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="xml.html">xml.inc</a>
			</li>
		
	  </ul>
	  </div><!--/.well -->
	</div><!--/span-->
	<div class="span9">

		<a name="top"></a>
		<h1>Overview of ssh_func.inc</h1>
		

		

		
		

		<h1>Public Variable Summary</h1>

		
		<p>Public variables are intended to be accessed by the code that imports
		this library.</p>
		

		<table class="nopad">
		  <tr class="TableHeadingColor">
			<th>Name</th>
			<th>Summary</th>
		  </tr>
		  
		  <tr>
			<td><a href="#bugged_channels">bugged_channels</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#bugged_first">bugged_first</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#bugged_rps">bugged_rps</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#bugged_rws">bugged_rws</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#bugged_sshd">bugged_sshd</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#dh_priv">dh_priv</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#dh_pub">dh_pub</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#enc_keys">enc_keys</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#l_window_size">l_window_size</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#local_channel">local_channel</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#r_packet_size">r_packet_size</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#r_window_size">r_window_size</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#received_size">received_size</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#remote_channel">remote_channel</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#seqn_r">seqn_r</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#seqn_w">seqn_w</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#server_host_key_blob">server_host_key_blob</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#session_id">session_id</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_host_key_algos">ssh_host_key_algos</a></td>
			<td></td>
		  </tr>
		  
		</table>
		
		
		

		<h1>Private Variable Summary</h1>

		
		<p>Private variables are not intended to be accessed by the code that
		imports this library. There is no functional difference between private
		and public variables, only convention, and they may be accessed as
		normal. </p>
		

		<table class="nopad">
		  <tr class="TableHeadingColor">
			<th>Name</th>
			<th>Summary</th>
		  </tr>
		  
		  <tr>
			<td><a href="#_last_libssh_sess">_last_libssh_sess</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#_ssh_banner">_ssh_banner</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#_ssh_cmd_error">_ssh_cmd_error</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#_ssh_error">_ssh_error</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#_ssh_server_version">_ssh_server_version</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#_ssh_supported_authentication">_ssh_supported_authentication</a></td>
			<td></td>
		  </tr>
		  
		</table>
		
		

		
		
		<h1>Public Function Summary</h1>

		
		<p>Public functions are intended to be called by the code that imports
		this library.</p>
		

		<table class="nopad">
		  <tr class="TableHeadingColor">
			<th>Name</th>
			<th>Summary</th>
		  </tr>
		  
		  <tr>
			<td><a href="#base64decode">base64decode</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#check_pattern">check_pattern</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#crypt">crypt</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#decrypt">decrypt</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#del_esc_seq">del_esc_seq</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#derive_keys">derive_keys</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#dh_gen_key">dh_gen_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#dh_valid_key">dh_valid_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#get_data_size">get_data_size</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#get_server_host_key">get_server_host_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#get_ssh_banner">get_ssh_banner</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#get_ssh_error">get_ssh_error</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#get_ssh_server_version">get_ssh_server_version</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#get_ssh_supported_authentication">get_ssh_supported_authentication</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#getstring">getstring</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#init">init</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#is_sshd_bugged">is_sshd_bugged</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_ssh_login">kb_ssh_login</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_ssh_passphrase">kb_ssh_passphrase</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_ssh_password">kb_ssh_password</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_ssh_privatekey">kb_ssh_privatekey</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_ssh_publickey">kb_ssh_publickey</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_ssh_transport">kb_ssh_transport</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kex_packet">kex_packet</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#mac_compute">mac_compute</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ntol">ntol</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#packet_payload">packet_payload</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#putbignum">putbignum</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#putstring">putstring</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#raw_int32">raw_int32</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#raw_int8">raw_int8</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#recv_ssh_packet">recv_ssh_packet</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#send_ssh_packet">send_ssh_packet</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#set_ssh_error">set_ssh_error</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_close_channel">ssh_close_channel</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_close_connection">ssh_close_connection</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_cmd">ssh_cmd</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_cmd_error">ssh_cmd_error</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_cmd_exec">ssh_cmd_exec</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_cmd_pty">ssh_cmd_pty</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_dss_verify">ssh_dss_verify</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_exchange_identification">ssh_exchange_identification</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_hack_get_server_version">ssh_hack_get_server_version</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_hex2raw">ssh_hex2raw</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_kex2">ssh_kex2</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_login">ssh_login</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_login_or_reuse_connection">ssh_login_or_reuse_connection</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_open_channel">ssh_open_channel</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_read_from_shell">ssh_read_from_shell</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_reconnect">ssh_reconnect</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_recv">ssh_recv</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_reuse_connection">ssh_reuse_connection</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_rsa_verify">ssh_rsa_verify</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ssh_userauth2">ssh_userauth2</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#update_window_size">update_window_size</a></td>
			<td></td>
		  </tr>
		  
		</table>
		
		
		
		

		
		
		<h1>Public Variable Details</h1>
		
		<h2 id="bugged_channels">bugged_channels</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="bugged_first">bugged_first</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="bugged_rps">bugged_rps</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="bugged_rws">bugged_rws</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="bugged_sshd">bugged_sshd</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="dh_priv">dh_priv</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="dh_pub">dh_pub</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="enc_keys">enc_keys</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="l_window_size">l_window_size</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="local_channel">local_channel</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="r_packet_size">r_packet_size</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="r_window_size">r_window_size</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="received_size">received_size</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="remote_channel">remote_channel</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="seqn_r">seqn_r</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="seqn_w">seqn_w</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="server_host_key_blob">server_host_key_blob</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="session_id">session_id</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_host_key_algos">ssh_host_key_algos</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		
		
		
		<h1>Private Variable Details</h1>
		
		<h2 id="_last_libssh_sess">_last_libssh_sess</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="_ssh_banner">_ssh_banner</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="_ssh_cmd_error">_ssh_cmd_error</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="_ssh_error">_ssh_error</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="_ssh_server_version">_ssh_server_version</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="_ssh_supported_authentication">_ssh_supported_authentication</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		
		

		
		
		<h1>Public Function Details</h1>
		
		<h2 id="base64decode">base64decode</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>str</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function base64decode(str)
{
 local_var len, i, j, k, ret, base64, b64;
 len = strlen(str);
 ret = &quot;&quot;;

 base64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;

 for (i = 0; i &lt; 256; i++)
   b64[i] = 0;
 for (i = 0; i &lt; strlen(base64); i++)
   b64[ord(base64[i])] = i;

 for(j=0;j&lt;len;j+=4)
 {
   for (i = 0; i &lt; 4; i++)
   {
    c = ord(str[j+i]);
    a[i] = c;
    b[i] = b64[c];
   }

   o[0] = (b[0] &lt;&lt; 2) | (b[1] &gt;&gt; 4);
   o[1] = (b[1] &lt;&lt; 4) | (b[2] &gt;&gt; 2);
   o[2] = (b[2] &lt;&lt; 6) | b[3];
   if (a[2] == ord(&#39;=&#39;))
     i = 1;
   else if (a[3] == ord(&#39;=&#39;))
     i = 2;
   else
     i = 3;
   for(k=0;k&lt;i;k++)
      ret += raw_int8(i:o[k]);

   if (i &lt; 3)
     break;
 }

 return ret;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="check_pattern">check_pattern</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>buffer</dt>
			
		
			<dt>length</dt>
			
		
			<dt>pattern</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function check_pattern(buffer,pattern,length)
{
 local_var alglen, len, alg;

 alglen = ntol (buffer:buffer, begin:length);
 len = length+4+alglen;
 alg = substr(buffer,length+4,len-1);
 if (!ereg(string:alg, pattern:pattern))
  return -1;

 return len;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="crypt">crypt</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function crypt(data)
{
 local_var crypted;

 crypted = bf_cbc_encrypt(data:data, key:enc_keys[2], iv:enc_keys[0]);

 enc_keys[0] = crypted[1];

 return crypted[0];
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="decrypt">decrypt</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function decrypt(data)
{
 local_var decrypted;

 decrypted = bf_cbc_decrypt(data:data, key:enc_keys[3], iv:enc_keys[1]);

 enc_keys[1] = decrypted[1];
 return decrypted[0];
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="del_esc_seq">del_esc_seq</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function del_esc_seq( data )
{
  local_var data;

  data = ereg_replace( pattern:&#39;\x1b\x5b[0-9;]*[mK]&#39;, replace:&#39;&#39;, string:data );
  data = ereg_replace( pattern:&#39;\x1b\x3e&#39;, replace:&#39;&#39;, string:data );
  data = ereg_replace( pattern:&#39;[\r|\x07|\x1b|\x08|\\[|\x0c]&#39;, replace:&#39;&#39;, string:data );

  return data;
}

function ssh_read_from_shell( sess, pattern, timeout, retry )

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="derive_keys">derive_keys</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>hash</dt>
			
		
			<dt>session_id</dt>
			
		
			<dt>shared</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function derive_keys(hash,shared,session_id)
{
 local_var c, i, to_hash, keys;
 # c = &#39;A&#39;;
 c = 65;
 for (i = 0;i &lt; 6; i++)
 {
   to_hash = putbignum(buffer:shared) + hash + raw_int8(i:c) + session_id;
   keys[i] = SHA1(to_hash);
   c++;
 }

 #         MODE OUT  MODE IN
 # enc.iv    0         1
 # enc.key   2         3
 # mac.key   4         5

 return keys;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="dh_gen_key">dh_gen_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>g</dt>
			
		
			<dt>p</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function dh_gen_key(p, g)
{
 local_var tries,keys;

 dh_pub = dh_priv = &quot;&quot;;

 tries = 0;

 if (!p)
   return keys;

 # { &quot;blowfish-cbc&quot;, 	SSH_CIPHER_SSH2, 8, 16, EVP_bf_cbc }
 # hash = sha1 = 20 (len) = 20 * 8 (bits)
 need = 20 * 8;

 # need won&#39;t be &gt; than INT_MAX / 2
 # maybe we must test if 2*need &gt;= numbits ...
 #if (need &gt; INT_MAX / 2 || 2 * need &gt;= BN_num_bits(dh-&gt;p))
 #  return keys;

 for (tries = 0; tries &lt; 10; tries++)
 {
   dh_priv = bn_random(need:(need*2));
   if (!dh_priv)
     return -1;
   dh_pub = dh_generate_key(p:p, g:g, priv:dh_priv);
   if (!dh_pub)
     return -1;
   if (dh_valid_key(key:dh_pub, p:p))
     break;
 }

 if (tries++ &gt;= 10)
   return -1;

 return 0;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="dh_valid_key">dh_valid_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>key</dt>
			
		
			<dt>p</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function dh_valid_key(key, p)
{
 local_var val,i;

 if (ord(key[0]) &gt; 0x80)
   return 0;

 val = 0;
 for(i=0;i&lt;strlen(key);i++)
 {
  val = val + ord(key[i]);
  if (val &gt; 1)
    break;
 }

 # ok if key &lt; p
 if ((val&gt;1) &amp;&amp; (bn_cmp(key1:key,key2:p) == -1))
   return 1;

 return 0;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="get_data_size">get_data_size</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function get_data_size()
{
 local_var len;

 if (r_window_size &lt;= r_packet_size)
    len = r_window_size;
 else
    len = r_packet_size;

 # packet option ~= 50 bytes
 len -= 50;

 # Remote server has not readjusted his window
 if (len &lt;= 0)
    return -1;

 return len;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="get_server_host_key">get_server_host_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>sess_id</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function get_server_host_key(sess_id) {
  if( defined_func( &quot;ssh_get_host_key&quot; ) )
  {
    if( sess_id &amp;&amp; int( sess_id ) &gt; 0 ) _last_libssh_sess = sess_id;
    return ssh_get_host_key( _last_libssh_sess );
  }
  else
    return server_host_key_blob;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="get_ssh_banner">get_ssh_banner</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>sess_id</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function get_ssh_banner(sess_id)
{
# Please use ssh_get_session_banner directly for new code.  The saved
# session id is just a bad hack.
 if (_HAVE_LIBSSH)
 {
   if( sess_id &amp;&amp; int( sess_id ) &gt; 0 ) _last_libssh_sess = sess_id;
   return ssh_get_issue_banner (_last_libssh_sess);
 }
 return _ssh_banner;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="get_ssh_error">get_ssh_error</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function get_ssh_error()
{
 return _ssh_error;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="get_ssh_server_version">get_ssh_server_version</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function get_ssh_server_version()
{
 return _ssh_server_version;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="get_ssh_supported_authentication">get_ssh_supported_authentication</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>sess_id</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function get_ssh_supported_authentication(sess_id)
{
 if (_HAVE_LIBSSH &amp;&amp; defined_func(&quot;ssh_get_auth_methods&quot;))
 {
     if( sess_id &amp;&amp; int( sess_id ) &gt; 0 ) _last_libssh_sess = sess_id;
     return ssh_get_auth_methods(_last_libssh_sess);
 }
 return _ssh_supported_authentication;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="getstring">getstring</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>buffer</dt>
			
		
			<dt>pos</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function getstring(buffer,pos)
{
 local_var buf_len, buf;

 buf_len = ntol (buffer:buffer,begin:pos);
 buf = substr(buffer,pos+4,pos+4+buf_len-1);

 return buf;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="init">init</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function init()
{
 # sequence packet = 0
 seqn_w = seqn_r = 0;
 local_channel = 0;
 _ssh_banner = &quot;&quot;;
 _ssh_server_version = &quot;&quot;;
 _ssh_supported_authentication = &quot;&quot;;
 _ssh_cmd_error = &quot;&quot;;
 _ssh_error = &quot;&quot;;
 _last_libssh_sess = 0;
 bugged_sshd = 0;
 bugged_first = 1;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="is_sshd_bugged">is_sshd_bugged</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>banner</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function is_sshd_bugged(banner)
{
 if (ereg(string:banner, pattern:&quot;^SSH-2\.0-Sun_SSH_1\.0&quot;))
   return 1;

 return 0;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_ssh_login">kb_ssh_login</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function kb_ssh_login()
{
 return string(get_kb_item(&quot;Secret/SSH/login&quot;));
}

function kb_ssh_password()

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_ssh_passphrase">kb_ssh_passphrase</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function kb_ssh_passphrase()
{
 return string(get_kb_item(&quot;Secret/SSH/passphrase&quot;));
}

function kb_ssh_transport()

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_ssh_password">kb_ssh_password</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function kb_ssh_password()
{
 return string(get_kb_item(&quot;Secret/SSH/password&quot;));
}

function kb_ssh_privatekey()

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_ssh_privatekey">kb_ssh_privatekey</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function kb_ssh_privatekey()
{
 return string(get_kb_item(&quot;Secret/SSH/privatekey&quot;));
}

function kb_ssh_publickey()

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_ssh_publickey">kb_ssh_publickey</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function kb_ssh_publickey()
{
 return string(get_kb_item(&quot;Secret/SSH/publickey&quot;));
}

function kb_ssh_passphrase()

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_ssh_transport">kb_ssh_transport</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function kb_ssh_transport()
{
 local_var r;
 r = get_preference(&quot;auth_port_ssh&quot;);
 if ( r ) return int(r);

 r = get_kb_item(&quot;Services/ssh&quot;);

 if ( r ) return int(r);
 else return 22;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kex_packet">kex_packet</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>code</dt>
			
		
			<dt>payload</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function kex_packet(payload,code)
{
 local_var len, padding_len, full_len, kex;

 len =
   # padding length
     1 +
     # msg code
     1 +
     # payload length
     strlen(payload);

 #padding (mod 8) = 8 - ( (len+packet_len(4) ) % 8 )
 padding_len = 8 - ((len + 4) % 8);

 # if padding len is less than 4 add block size
 if (padding_len &lt; 4)
   padding_len += 8;

 full_len = len + padding_len;

 kex =
    # packet length
    raw_int32 (i:full_len) +
    # padding length
    raw_int8 (i:padding_len) +
    #msg code (32 = Diffie-Hellman GEX Init)
    code +
    # Payload (Pub key)
    payload +
    # Padding
    crap(data:raw_string(0),length:padding_len);

 return kex;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="mac_compute">mac_compute</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
			<dt>type</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function mac_compute(data, type)
{
 local_var to_hash;

 # we only support sha1! enc_keys[5] == mac_out key
 if (!type)
 {
  to_hash = raw_int32(i:seqn_w) + data;
  hash = HMAC_SHA1(data:to_hash, key:enc_keys[4]);
 }
 else
 {
  to_hash = raw_int32(i:seqn_r) + data;
  hash = HMAC_SHA1(data:to_hash, key:enc_keys[5]);
 }

 return hash;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ntol">ntol</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>begin</dt>
			
		
			<dt>buffer</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ntol(buffer,begin)
{
 local_var len;

 len = 16777216*ord(buffer[begin]) +
       ord(buffer[begin+1])*65536 +
       ord(buffer[begin+2])*256 +
       ord(buffer[begin+3]);

 return len;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="packet_payload">packet_payload</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>code</dt>
			
		
			<dt>packet</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function packet_payload(packet,code)
{
 local_var packetlen, paddinglen, msgcode;

 packetlen = ntol(buffer:packet, begin:0);
 paddinglen = ord(packet[4]);
 msgcode = ord(packet[5]);

 # Diffie-Hellman Key Exchange Reply
 if (msgcode != code)
  return 0;

 payload = substr(packet,6,packetlen-1);
 return payload;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="putbignum">putbignum</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>buffer</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function putbignum(buffer)
{
 local_var len, buf;

 if (ord(buffer[0]) &amp; 0x80)
 {
   len = strlen(buffer)+1;
   buf = raw_int32(i:len) + raw_string(0x00) + buffer;
 }
 else
   buf = raw_int32(i:strlen(buffer)) + buffer;

 return buf;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="putstring">putstring</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>buffer</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function putstring(buffer)
{
 local_var buf;

 buf = raw_int32(i:strlen(buffer)) + buffer;

 return buf;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="raw_int32">raw_int32</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>i</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function raw_int32(i)
{
 local_var buf;

 buf = raw_string (
		 (i&gt;&gt;24) &amp; 255,
        (i&gt;&gt;16) &amp; 255,
        (i&gt;&gt;8) &amp; 255,
        (i) &amp; 255
		 );
 return buf;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="raw_int8">raw_int8</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>i</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function raw_int8(i)
{
 local_var buf;

 buf = raw_string (
        (i) &amp; 255
		 );
 return buf;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="recv_ssh_packet">recv_ssh_packet</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>socket</dt>
			
		
			<dt>timeout</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function recv_ssh_packet(socket, timeout)
{
 local_var len, need, padding_len, full_len, buf, res, macbuf, decrypted;
 local_var hmac, hmacbuf, mac, payload, ret;


 payload = raw_int8(i:0);

 # blockbytes = 8 for blowfish-cbc
 buf = recv(socket:socket, length:8, min:8, timeout:timeout);
 if (strlen(buf) != 8)
   return payload;

 decrypted = decrypt(data:buf);

 len = ntol(buffer:decrypted, begin:0);
 # Maximum packet size is 32768 bytes
 if (len &gt; 32768)
   return payload;
 # 8 = blocksize ... i know it is not generic and it will be hard to change all
 need = 4 + len - 8;
 buf = recv(socket:socket, length:need, min:need, timeout:timeout);
 if (strlen(buf) != need)
   return payload;

 decrypted = decrypted + decrypt(data:buf);

 # hmac-sha1 length = 20 ... same comment as before
 mac = recv(socket:socket, length:20, min:20, timeout:timeout);
 if (strlen(mac) != 20)
   return payload;

 macbuf = mac_compute(data:decrypted, type:1);

 hmac = hexstr(mac);
 hmacbuf = hexstr(macbuf);
 if (hmac &gt;!&lt; hmacbuf)
   return payload;

 payload = substr(decrypted, 5, strlen(decrypted)-ord(decrypted[4])-1);
 seqn_r++;

 # SSH servers can send IGNORE (code 2) or BANNER (code 53) msg
 ret = ord(payload[0]);
 if ((ret == 2) || (ret == 53) || ret == 4)
 {
   if (ret == 53)
     _ssh_banner += getstring (buffer:payload, pos:1);

   return recv_ssh_packet(socket:socket, timeout:timeout);
 }

 return payload;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="send_ssh_packet">send_ssh_packet</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>code</dt>
			
		
			<dt>payload</dt>
			
		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function send_ssh_packet(socket,payload,code)
{
 local_var i, len, padding_len, full_len, buf, res, macbuf, crypted;

 len =
   # padding length
     1 +
     # msg code
     1 +
     # payload length
     strlen(payload);

 #padding (mod 8) = 8 - ( (len+packet_len(4) ) % 8 )
 padding_len = 8 - ((len + 4) % 8);

 # if padding len is less than 4 add block size
 if (padding_len &lt; 4)
   padding_len += 8;

 full_len = len + padding_len;

 padding = &quot;&quot;;
 for (i=0;i&lt;padding_len;i++)
    padding = padding + raw_int8(i:(rand() % 256));


 buf =
    # packet length
    raw_int32 (i:full_len) +
    # padding length
    raw_int8 (i:padding_len) +
    #msg code (32 = Diffie-Hellman GEX Init)
    code +
    # Payload (Pub key)
    payload +
    # Padding
    padding;

 macbuf = mac_compute(data:buf, type:0);

 crypted = crypt(data:buf);

 buf = crypted + macbuf;

 send(socket:socket, data:buf);

 seqn_w++;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="set_ssh_error">set_ssh_error</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>msg</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function set_ssh_error(msg)
{
 _ssh_error = msg;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_close_channel">ssh_close_channel</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>end</dt>
			
		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_close_channel(socket,end)
{
 local_var payload;

 # session = &quot;session&quot;
 # sender channel = 4444  / should we try different number on failure ?
 # initial window size = 32768
 # maximum packet size = 32768
 payload = raw_int32(i:remote_channel);

 # SSH_MSG_CHANNEL_CLOSE == 97
 send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:97));

 if (!end)
 {
   # SSH_MSG_CHANNEL_CLOSE == 97
   payload = recv_ssh_packet(socket:socket);
   while((ord(payload[0]) != 97) &amp;&amp; (ord(payload[0]) != 0))
     payload = recv_ssh_packet(socket:socket);

   if (ord(payload[0]) != 97)
   {
     set_ssh_error(msg:string( &quot;Received code was not  SSH_MSG_CHANNEL_CLOSE (97). It was : &quot; , ord(payload[0])));
     return -1;
   }
 }

 # all is ok, user is authenticated
 return 0;

}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_close_connection">ssh_close_connection</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_close_connection()
{
}


# Open an ssh connection and return the socket on success.

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_cmd">ssh_cmd</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>cmd</dt>
			
		
			<dt>nosh</dt>
			
		
			<dt>pattern</dt>
			
		
			<dt>pty</dt>
			
		
			<dt>retry</dt>
			
		
			<dt>return_errors</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>timeout</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_cmd(socket,cmd,timeout,nosh,return_errors,pty,pattern,retry)
{
 local_var payload, ret, tempbuf, end, cret, messid_data, ret_payload, ret_ssh_buf, pty;

 if( ! cmd )
 {
   set_kb_item( name: &quot;nvt_debug_empty/&quot; + get_script_oid(), value:get_script_oid() + &quot;#-#cmd#-#ssh_cmd&quot; );
   return;
 }

 if(get_kb_item(&quot;ssh/cmd_exec_error&quot;) ) nosh = TRUE; # NX-OS/IOS/JunOS/F5

 if( get_kb_item( &quot;no_linux_shell&quot; ) )
 {
   nosh = TRUE;
   if( cmd =~ &quot;^(/bin|/sbin|cat |perl |cmd /|netstat |find |which |whereis |locate |/opt/slad)&quot; ) return FALSE; # don&#39;t run find, which ... if target doesn&#39;t support it
 }

 if( ! nosh )
 {
   cmd = str_replace(string:cmd, find:&quot;&#39;&quot;, replace:&#39;&quot;&#39;);
   cmd = string(&quot;/bin/sh -c &quot;, &quot;&#39;LANG=C; LC_ALL=C; &quot; , cmd , &quot;&#39;&quot;);
 }

  if( ! pty )
    if( get_kb_item( &quot;ssh/force/pty&quot; ) ) pty = TRUE;

 if (_HAVE_LIBSSH) {
     local_var sess;

     sess = ssh_session_id_from_sock(socket);
     if (sess) {
         # Note: Setting stdout and stderr to 0 enables a
         # compatibility mode to be bug compliant to the NASL ssh code.
         if( pty &amp;&amp; defined_func( &quot;ssh_shell_open&quot; ) )
           ret_ssh_buf = ssh_cmd_pty( sess:sess, cmd:cmd, pattern:pattern, timeout:timeout, retry:retry );
         else
           ret_ssh_buf = ssh_request_exec(sess, cmd:cmd, stdout:0, stderr:0);

         if( get_kb_item( &quot;global_settings/ssh/debug&quot; ) )
         {
           debug_str = &#39;SSH DEBUG: &#39; + get_host_ip() + &#39;:\n&#39; +
                       &#39;PTY:  &#39; + pty + &#39;\n&#39; +
                       &#39;NOSH: &#39; + nosh + &#39;\n&#39; +
                       &#39;CMD:  &#39; + cmd + &#39;\n&#39; +
                       &#39;RES:  &#39; + ret_ssh_buf + &#39;\n&#39; +
                       &#39;---------------------------------------------------------\n\n&#39;;
           display(debug_str);
         }

         if(&quot;Cmd exec error&quot; &gt;&lt; ret_ssh_buf ||
            &quot;error: unknown command&quot; &gt;&lt; ret_ssh_buf ||
            &quot;Unknown command: &quot; &gt;&lt; ret_ssh_buf ||
            &quot;Invalid input detected&quot; &gt;&lt; ret_ssh_buf ||
            &quot;: No such command&quot; &gt;&lt; ret_ssh_buf ||
            &quot;-----unknown keyword &quot; &gt;&lt; ret_ssh_buf ||
            &quot;Unknown action 0&quot; &gt;&lt; ret_ssh_buf ||
            &quot;Syntax Error: unexpected argument&quot; &gt;&lt; ret_ssh_buf ) { # NX-OS/IOS/JunOS/F5
           set_kb_item(name:&quot;ssh/cmd_exec_error&quot;, value:TRUE); # force nosh
           if( ! return_errors )
             return &#39;&#39;;
         }

         if( &quot;: not found&quot; &gt;&lt; ret_ssh_buf )
         {
           if( ! return_errors )
             return &#39;&#39;;
         }

         return ret_ssh_buf;
     }
 }


 # Flash error buffer
 _ssh_cmd_error = &quot;&quot;;

 # Message id flag
 messid_data = 0;

 # Open channel
 ret = ssh_open_channel(socket:socket);
 if(ret != 0)
 {
   _ssh_cmd_error = &quot;OpenVAS failed to open a new SSH channel. &quot; + get_ssh_error();
   return NULL;
 }

 payload = raw_int32(i:remote_channel) + putstring(buffer:&quot;exec&quot;) + raw_int8(i:0) +
	   putstring(buffer:cmd);

 # SSH_MSG_CHANNEL_REQUEST == 98
 send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:98));

 ret = NULL;

 # SSH_MSG_CHANNEL_SUCCESS == 99
 # while for previous useless messages (SSH_MSG_CHANNEL_WINDOW_ADJUST, ...)
 payload = recv_ssh_packet(socket:socket, timeout:timeout);
 while((ord(payload[0]) == 93) || (ord(payload[0]) == 95) || (ord(payload[0])  == 98))
 {
  if(ord(payload[0]) == 95)
  {
    payload = getstring(buffer:payload, pos:9);
    _ssh_cmd_error += payload;
    ret_payload += payload;
    val = update_window_size(socket:socket,size:strlen(payload));
    if (val != 0)
      break;
  }
  payload = recv_ssh_packet(socket:socket, timeout:timeout);
  if(&quot;exit-signal&quot; &gt;&lt; payload) ret_payload += string(payload);
 }

 while((ord(payload[0]) != 97) &amp;&amp; (ord(payload[0]) != 0))
 {
  if(ord(payload[0]) == 98)
  {
    payload = getstring(buffer:payload, pos:5);
    if (&quot;exit-status&quot; &gt;!&lt; payload)
      break;
  }
  else if((ord(payload[0]) == 94) || (ord(payload[0]) == 95))
  {
    tempbuf = getstring(buffer:payload, pos:5);
    if(ord(payload[0]) == 94)
    {
      ret += tempbuf;
      messid_data = 1;
    }
    val = update_window_size(socket:socket,size:strlen(tempbuf));
    if(val != 0) {
      break;
    }
  }
  else if(ord(payload[0]) == 96){
     if(messid_data == 0){
        ret += ret_payload;
     }
  }

  payload = recv_ssh_packet(socket:socket, timeout:timeout);
 }

 end = 0;
 if (ord(payload[0]) == 97)
   end = 1;

 # Close channel
 cret = ssh_close_channel(socket:socket, end:end);
 if (cret != 0)
 {
   _ssh_cmd_error = &quot;OpenVAS failed to close SSH channel. &quot; + get_ssh_error();
   return NULL;
 }

 return ret;

}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_cmd_error">ssh_cmd_error</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_cmd_error()
{
 return _ssh_cmd_error;
}



#------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_cmd_exec">ssh_cmd_exec</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>cmd</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_cmd_exec(cmd)
{
  local_var sess;

  if ( ! _HAVE_LIBSSH )
      return NULL; # No, we can&#39;t use this function.

  if( ! cmd )
  {
    set_kb_item( name: &quot;nvt_debug_empty/&quot; + get_script_oid(), value:get_script_oid() + &quot;#-#cmd#-#ssh_cmd_exec&quot; );
    return;
  }

  login = kb_ssh_login();
  password = kb_ssh_password();
  priv = kb_ssh_privatekey();
  passphrase = kb_ssh_passphrase();

  sess = ssh_connect();
  if (!sess)
      return NULL;
  if (ssh_userauth(sess, login:login, password:password, privatekey:priv, passphrase:passphrase)) {
      ssh_disconnect(sess);
      return NULL;
  }
  result = ssh_request_exec(sess, cmd:cmd, stdout:1, stderr:1);
  ssh_disconnect(sess);
  return result;
}


# Workaround to get the server banner from a freshly opened socket.

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_cmd_pty">ssh_cmd_pty</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>cmd</dt>
			
		
			<dt>pattern</dt>
			
		
			<dt>retry</dt>
			
		
			<dt>sess</dt>
			
		
			<dt>timeout</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_cmd_pty( sess, cmd, pattern, timeout, retry )
{
  local_var sess, cmd, pattern, ret, timeout, retry;

  if( ! cmd )
  {
    set_kb_item( name: &quot;nvt_debug_empty/&quot; + get_script_oid(), value:get_script_oid() + &quot;#-#cmd#-#ssh_cmd_pty&quot; );
    return FALSE;
  }

  if( ! sess ) sess = _last_libssh_sess;
  if( ! sess || int( sess ) &lt; 1 ) return FALSE;

  sess = ssh_shell_open( sess );
  if ( ! sess ) return FALSE;

  if( ! timeout ) timeout = 15;
  if( ! retry ) retry = 3;

  if( get_kb_item( &quot;ssh/send_extra_ln&quot; ) )
  {
    ssh_shell_write( sess, cmd: &#39;\n&#39; );
    sleep( 1 );
  }

  ssh_shell_write( sess, cmd:cmd + &#39;\n&#39; );
  sleep( 1 );

  if( ! ret = ssh_read_from_shell( sess:sess, pattern:pattern, timeout:timeout, retry:retry ) )
  {
    if( defined_func( &quot;ssh_shell_close&quot; ) ) ssh_shell_close( sess );
    return FALSE;
  }

  if( defined_func( &quot;ssh_shell_close&quot; ) ) ssh_shell_close( sess );

  return ret;

}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_dss_verify">ssh_dss_verify</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
			<dt>g</dt>
			
		
			<dt>p</dt>
			
		
			<dt>pub</dt>
			
		
			<dt>q</dt>
			
		
			<dt>signature</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_dss_verify(p, q, g, pub, signature, data)
{
 local_var sigtype, next, tmp_sig, siglen, r, s, hash;

 sigtype = getstring(buffer:signature, pos:0);
 if (sigtype &gt;!&lt; &quot;ssh-dss&quot;)
   return 0;

 next = 4 + strlen(sigtype);
 tmp_sig = getstring(buffer:signature,pos:next);
 siglen = strlen(tmp_sig);

 r = substr(tmp_sig, 20, 39);
 s = substr(tmp_sig, 40, 59);

 hash = SHA1(data);

 return dsa_do_verify(p:p,g:g,q:q,pub:pub,r:r,s:s,data:hash);
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_exchange_identification">ssh_exchange_identification</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_exchange_identification(socket)
{
 local_var buf, sshversion, num, prot;

 buf = recv_line(socket:socket, length:1024);

 if (!buf)
 {
   set_ssh_error(msg: &quot;OpenVAS did not receive server&#39;s version&quot;);
   return 0;
 }

 # server ident : SSH-%d.%d-servername #
 if (!ereg(string:buf, pattern:&quot;^SSH-*[0-9]\.*[0-9]-*[^\n]&quot;))
 {
   set_ssh_error(msg: &quot;Remote service is not a valid SSH service&quot;);
   return 0;
 }

 sshversion = split(buf, sep:&quot;-&quot;, keep:0);
 num = split(sshversion[1], sep:&quot;.&quot;, keep:0);

 # version supported = 2 &amp; 1.99
 if ((num[0] != 2) &amp;&amp; !((num[0] == 1) &amp;&amp; (num[1] == 99)))
 {
   set_ssh_error(msg: &quot;OpenVAS only supports SSHv2&quot;);
   return 0;
 }

 # We use 2.0 protocol
 prot = &quot;SSH-2.0-OpenVAS&quot;+raw_string(0x0a);
 send(socket:socket, data:prot);

 if ( &#39;\r\n&#39; &gt;&lt; buf ) buf = buf - &#39;\r\n&#39;;
   else buf = buf - &#39;\n&#39;;

 if (is_sshd_bugged(banner:buf))
 {
   bugged_sshd = 1;
 }

 # all is correct
 return buf;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_hack_get_server_version">ssh_hack_get_server_version</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_hack_get_server_version(socket)
{
 local_var buf;

 if( ! socket )
 {
   set_kb_item( name: &quot;nvt_debug_empty/&quot; + get_script_oid(), value:get_script_oid() + &quot;#-#socket#-#ssh_hack_get_server_version&quot; );
 }

 buf = recv_line(socket:socket, length:1024);

 if (!buf)
 {
   set_ssh_error(msg: &quot;OpenVAS did not receive server&#39;s version&quot;);
   return 0;
 }

 # server ident : SSH-%d.%d-servername #
 if (!ereg(string:buf, pattern:&quot;^SSH-*[0-9]\.*[0-9]-*[^\n]&quot;))
 {
   set_ssh_error(msg: &quot;Remote service is not a valid SSH service&quot;);
   return 0;
 }

 if ( &#39;\r\n&#39; &gt;&lt; buf )
     buf = buf - &#39;\r\n&#39;;
 else
     buf = buf - &#39;\n&#39;;

 return buf;
}

function ssh_reconnect( sock )

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_hex2raw">ssh_hex2raw</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>s</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_hex2raw(s)
{
 local_var i, j, ret, l;

 s = chomp(s);  # remove trailing blanks, CR, LF...
 l = strlen(s);
 if (l % 2) display(&quot;ssh_hex2raw: odd string: &quot;, s, &quot;\n&quot;);
 for(i=0;i&lt;l;i+=2)
 {
  if(ord(s[i]) &gt;= ord(&quot;0&quot;) &amp;&amp; ord(s[i]) &lt;= ord(&quot;9&quot;))
        j = int(s[i]);
  else
        j = int((ord(s[i]) - ord(&quot;a&quot;)) + 10);

  j *= 16;
  if(ord(s[i+1]) &gt;= ord(&quot;0&quot;) &amp;&amp; ord(s[i+1]) &lt;= ord(&quot;9&quot;))
        j += int(s[i+1]);
  else
        j += int((ord(s[i+1]) - ord(&quot;a&quot;)) + 10);
  ret += raw_string(j);
 }
 return ret;
}

function kb_ssh_login()

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_kex2">ssh_kex2</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>server_version</dt>
			
		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_kex2(socket,server_version)
{
 local_var packetlen, paddinglen, msgcode, len, len2;
 local_var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p;
 local_var skexkex, kexr, skexr, gex, gexr, nk, nkey;
 local_var sinit, scookie, ccookie, cinit;
 local_var payload;
 local_var keys, shared;
 local_var alg_type, type;
 local_var start, next, correct, groupex;
 local_var rsa_e, rsa_n, dsa_p, dsa_q, dsa_g, dsa_pub_key;
 local_var server_dh_public_key, signed_h, to_hash, hash;


 # supported algorithms
 key_exchange_algo        = &quot;diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1&quot;;
 server_host_key_algo     = &quot;ssh-rsa,ssh-dss&quot;;
 enc_alg_client_to_server = &quot;blowfish-cbc&quot;;
 enc_alg_server_to_client = &quot;blowfish-cbc&quot;;
 mac_alg_client_to_server = &quot;hmac-sha1&quot;;
 mac_alg_server_to_client = &quot;hmac-sha1&quot;;
 cmp_alg_client_to_server = &quot;none&quot;;
 cmp_alg_server_to_client = &quot;none&quot;;

 # version
 client_version = &quot;SSH-2.0-OpenVAS&quot;;


### Key exchange send client Init ###

 skex = ssh_recv(socket:socket, length:2000);

 if(isnull(skex)) {
   set_ssh_error(msg: &quot;ssh_recv() failed in function ssh_kex2()&quot;);
   return -1;
 }

 packetlen = ntol (buffer:skex, begin:0);
 paddinglen = ord(skex[4]);
 msgcode = ord(skex[5]);
 if (msgcode != 20)
 {
   set_ssh_error(msg:string(&quot;Received code was not SSH_MSG_KEXINIT (20). It was : &quot;, msgcode));
   return -1;
 }

 sinit = substr(skex,6,packetlen+4-paddinglen-1);

 scookie = substr(skex,6,21);

 len = check_pattern(buffer:skex, pattern:&quot;diffie-hellman-group-exchange-sha1&quot;, length:22);
 if (len == -1)
 {
   len = check_pattern(buffer:skex, pattern:&quot;diffie-hellman-group1-sha1&quot;, length:22);
   if (len == -1)
   {
     set_ssh_error(msg:&quot;Remote SSH server does not support DH exchanges (bugged ?)&quot;);
     return -1;
   }
   groupex = 0;
 }
 else
 {
  groupex = 1;
 }

 len2 = check_pattern(buffer:skex, pattern:&quot;ssh-rsa&quot;, length:len);
 if (len2 == -1)
 {
   len2 = check_pattern(buffer:skex, pattern:&quot;ssh-dss&quot;, length:len);
   if (len2 == -1)
   {
     set_ssh_error(msg:&quot;Remote SSH server does not support DSA and RSA (bugged ?)&quot;);
     return -1;
   }
 }

 len = check_pattern(buffer:skex, pattern:enc_alg_client_to_server, length:len2);
 if (len == -1)
 {
  set_ssh_error(msg:&quot;Remote SSH server does not support blowfish-cbc encryption&quot;);
  return -1;
 }

 len2 = check_pattern(buffer:skex, pattern:enc_alg_server_to_client, length:len);
 if (len2 == -1)
 {
  set_ssh_error(msg:&quot;Remote SSH server does not support blowfish-cbc encryption&quot;);
  return -1;
 }

 len = check_pattern(buffer:skex, pattern:mac_alg_client_to_server, length:len2);
 if (len == -1)
 {
  set_ssh_error(msg:&quot;Remote SSH server does not support hmac-sha1 encryption&quot;);
  return -1;
 }

 len2 = check_pattern(buffer:skex, pattern:mac_alg_server_to_client, length:len);
 if (len2 == -1)
 {
  set_ssh_error(msg:&quot;Remote SSH server does not support hmac-sha1 encryption&quot;);
  return -1;
 }

 len = check_pattern(buffer:skex, pattern:cmp_alg_client_to_server, length:len2);
 if (len == -1)
 {
  set_ssh_error(msg:&quot;Remote SSH server only supports compressed packets&quot;);
  return -1;
 }

 len2 = check_pattern(buffer:skex, pattern:cmp_alg_server_to_client, length:len);
 if (len2 == -1)
 {
  set_ssh_error(msg:&quot;Remote SSH server only supports compressed packets&quot;);
  return -1;
 }


### Key exchange recv server Init ###

 ccookie = &quot;&quot;;
 for (i=0;i&lt;16;i++)
    ccookie = ccookie + raw_int8(i:(rand() % 256));

 cinit =
    # cookie (random)
    ccookie +
    # key algorithms (length + string)
    raw_int32(i:strlen(key_exchange_algo)) + key_exchange_algo +
    # server host key algorithms (length + string)
    raw_int32(i:strlen(server_host_key_algo)) + server_host_key_algo +
    # encryption algorithms client to server (length + string)
    raw_int32(i:strlen(enc_alg_client_to_server)) + enc_alg_client_to_server +
    # encryption algorithms server to client (length + string)
    raw_int32(i:strlen(enc_alg_server_to_client)) + enc_alg_server_to_client +
    # mac algorithms client to server (length + string)
    raw_int32(i:strlen(mac_alg_client_to_server)) + mac_alg_client_to_server +
    # mac algorithms server to client (length + string)
    raw_int32(i:strlen(mac_alg_server_to_client)) + mac_alg_server_to_client +
    # compression algorithms client to server (length + string)
    raw_int32(i:strlen(cmp_alg_client_to_server)) + cmp_alg_client_to_server +
    # compression algorithms server to client (length + string)
    raw_int32(i:strlen(cmp_alg_server_to_client)) + cmp_alg_server_to_client +
    # languages client to server (length)
    raw_int32(i:0) +
    # languages server to client (length)
    raw_int32(i:0) +
    # payload
    crap(data:raw_string(0x00), length:5);

 # msg code (20 = key exchange init)
 kex = kex_packet(payload:cinit,code:raw_string(0X14));

 send(socket:socket, data:kex);
 seqn_w++;

 if (groupex)
 {
  ### Key exchange Request : Diffie-Hellman GEX Request ###

  payload = raw_string(0x00,0x00,0x04,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x20,0x00);
  # msg code (34 = Diffie-Hellman GEX Request)
  kexr = kex_packet(payload:payload,code:raw_string(34));

  send(socket:socket, data:kexr);
  seqn_w++;

  ### Key exchange Reply : Diffie-Hellman Key Exchange Reply ###

  skexr = ssh_recv(socket:socket, length:1000);

  # code = 31 (Diffie-Hellman Key Exchange Reply)
  payload = packet_payload(packet:skexr, code:31);
  if (!payload)
  {
   set_ssh_error(msg:&quot;Received code was not SSH_MSG_KEXDH_REPLY (31)&quot;);
   return -1;
  }

  # get p bignum for dh group
  p = getstring (buffer:payload,pos:0);

  # get g bignum for dh group
  start = 4+strlen(p);
  g = getstring(buffer:payload,pos:start);
 }
 else
 {
  p = raw_string (0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                  0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
                  0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
                  0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
                  0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,
                  0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
                  0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,
                  0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
                  0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
                  0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
                  0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,
                  0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
                  0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,
                  0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
                  0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81,
                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);

  g = raw_int8(i:2);
 }
 # generate public and private keys
 ret = dh_gen_key(p:p,g:g);
 if (ret != 0)
  {
   set_ssh_error(msg:&quot;Error during DH keys generation&quot;);
   return -1;
  }

### Diffie Hellman GEX Init ###

 payload = raw_int32(i:strlen(dh_pub)) + dh_pub;

 if (groupex)
   codereq = raw_int8(i:32);
 else
   codereq = raw_int8(i:30);

 # msg code (32 = Diffie-Hellman GEX Init)
 gex = kex_packet(payload:payload,code:codereq);

 send(socket:socket, data:gex);
 seqn_w++;

### Diffie Hellman GEX Reply ###

 gexr = ssh_recv(socket:socket, length:2000);

 if (groupex)
   codereq = 33;
 else
   codereq = 31;
 payload = packet_payload(packet:gexr, code:codereq);
 if (!payload)
 {
  set_ssh_error(msg:&quot;Received code was not SSH_MSG_KEXDH_REPLY (31 or 33)&quot;);
  return -1;
 }

 # server host key blob
 server_host_key_blob = getstring (buffer:payload,pos:0);

 # extract server host key
 alg_type = getstring (buffer:server_host_key_blob, pos:0);
 next = 4 + strlen(alg_type);

 if (alg_type &gt;&lt; &quot;ssh-rsa&quot;)
  {
   # rsa type == 0
   type = 0;

   # e
   rsa_e = getstring (buffer:server_host_key_blob,pos:next);
   next = next + 4 + strlen(rsa_e);

   # n
   rsa_n = getstring (buffer:server_host_key_blob,pos:next);
   next = next + 4 + strlen(rsa_n);
  }
 else
  {
   if (alg_type &gt;&lt; &quot;ssh-dss&quot;)
    {
     # dsa type == 1
     type = 1;

     # p
     dsa_p = getstring (buffer:server_host_key_blob,pos:next);
     next = next + 4 + strlen(dsa_p);

     # q
     dsa_q = getstring (buffer:server_host_key_blob,pos:next);
     next = next + 4 + strlen(dsa_q);

     # g
     dsa_g = getstring (buffer:server_host_key_blob,pos:next);
     next = next + 4 + strlen(dsa_g);

     # pub key
     dsa_pub_key = getstring (buffer:server_host_key_blob,pos:next);
     next = next + 4 + strlen(dsa_pub_key);
    }
   else
    # bad key algo - should not occur
   {
     set_ssh_error(msg:&quot;Server&#39;s host keys format is not supported&quot;);
     return -1;
   }
  }


 # server dh public key
 start = 4 + strlen(server_host_key_blob);
 server_dh_public_key = getstring(buffer:payload,pos:start);

 # signed H
 start = start + 4 + strlen(server_dh_public_key);
 signed_h = getstring(buffer:payload,pos:start);

 if (!dh_valid_key(key:server_dh_public_key, p:p))
 {
   set_ssh_error(msg:&quot;Server DH public key is not valid!&quot;);
   return -1;
 }

 # shared secret #
 shared = dh_compute_key(p:p,g:g,dh_server_pub:server_dh_public_key,
  pub_key:dh_pub,priv_key:dh_priv);
 if (!shared)
 {
   set_ssh_error(msg:&quot;Error during shared secret computing&quot;);
   return -1;
 }

 # hash data
 to_hash =
	# client version
	putstring(buffer:client_version) +
	# server version
	putstring(buffer:server_version) +
	# client cookie (cookielen,SSH_MSG_KEXINIT,cookie)
	raw_int32(i:(strlen(cinit)+1)) + raw_int8(i:20) + cinit +
	# server cookie (cookielen,SSH_MSG_KEXINIT,cookie)
	raw_int32(i:(strlen(sinit)+1)) + raw_int8(i:20) + sinit +
	# server host key blob
	putstring(buffer:server_host_key_blob);

 if (groupex)
 {
  to_hash +=
	# min,wantbits,max
	raw_string(0x00,0x00,0x04,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x20,0x00) +
	# p bignum
	putbignum(buffer:p) +
	# g bignum
	putbignum(buffer:g);
 }

 to_hash +=
	# public key bignum
	putbignum(buffer:dh_pub) +
	# server dh public key bignum
	putbignum(buffer:server_dh_public_key) +
	# shared bignum
	putbignum(buffer:shared);

 hash = SHA1(to_hash);

 if (type == 0)
   correct = ssh_rsa_verify(e:rsa_e, n:rsa_n, signature:signed_h, data:hash);
 else
   # Not implemented
   correct = ssh_dss_verify(p:dsa_p, q:dsa_q, g:dsa_g, pub:dsa_pub_key, signature:signed_h, data:hash);

 if (!correct)
 {
   set_ssh_error(msg:&quot;Server&#39;s signature is not valid!&quot;);
   return -1;
 }

 session_id = hash;
 enc_keys = derive_keys(hash:hash,shared:shared,session_id:session_id);

### New keys ###

 nkey = ssh_recv(socket:socket, length:1000);
 # msg code (21 = New keys)
 payload = packet_payload(packet:nkey, code:21);
 if (!payload)
 {
  set_ssh_error(msg:&quot;Received code was not SSH_MSG_NEWKEYS (21)&quot;);
  return -1;
 }

 payload = NULL;

 # msg code (21 = New keys)
 nk = kex_packet(payload:payload,code:raw_string(0x15));

 send(socket:socket, data:nk);
 seqn_w++;

 # all is correct
 return 0;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_login">ssh_login</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>keytype</dt>
			
		
			<dt>login</dt>
			
		
			<dt>passphrase</dt>
			
		
			<dt>password</dt>
			
		
			<dt>priv</dt>
			
		
			<dt>pub</dt>
			
		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_login(socket, login, password, pub, priv, passphrase, keytype)
{
 local_var server_user, ret, sess;

 # Divert to the libssh based code if available.
 if (_HAVE_LIBSSH) {
     sess = ssh_connect( socket:socket, keytype:keytype );
     if (!sess)
         return -1;
     _last_libssh_sess = sess;

     if (ssh_userauth(sess, login:login, password:password, privatekey:priv, passphrase:passphrase))
         return -1;

     # none method fix
     ssh_supported_authentication =  get_ssh_supported_authentication(sess_id:sess);
     if(ssh_supported_authentication == &quot;&quot; ||
       ssh_supported_authentication == &quot;none&quot; ||
       ord(ssh_supported_authentication) == &quot;0&quot;) {
       return -2;
     }
     # end none method fix

     return 0;
 }

# server_user = tolower(login); # commented out because i don&#39;t see any
# reason for this. This break uppercase logins. (mime)

 server_user = login;

 init();

 # Exchange protocol version identification strings with the server.
 server_version = ssh_exchange_identification(socket:socket);
 if (!server_version)
  return -1;

 _ssh_server_version = server_version;

 # key exchange
 # authenticate user
 ret = ssh_kex2(socket:socket, server_version:server_version);
 if (ret != 0)
   return -1;

 ret = ssh_userauth2(socket:socket, server_user:server_user, password:password, pub:pub, priv:priv, passphrase:passphrase);
 if (ret != 0)
   return -1;

 # all is ok
 return 0;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_login_or_reuse_connection">ssh_login_or_reuse_connection</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_login_or_reuse_connection()
{
 local_var soc, sess;
 local_var login, password, pub, priv, passphrase;


 login = kb_ssh_login();
 password = kb_ssh_password();
 pub = kb_ssh_publickey();
 priv = kb_ssh_privatekey();
 passphrase = kb_ssh_passphrase();

 if( ! login &amp;&amp; ( ! password &amp;&amp; ! priv ) )
     return 0;

 if (_HAVE_LIBSSH)
 {
     # The new libssh functions are available.  Use them instead.
     sess = ssh_connect();
     if (!sess)
         return 0;
     if (ssh_userauth(sess, login:login, password:password, privatekey:priv, passphrase:passphrase))
     {
         ssh_disconnect(sess);
         last_sess = 0;
         return 0;
     }
     soc = ssh_get_sock(sess);
 }
 else
 {
     soc = open_sock_tcp(kb_ssh_transport());
     if ( ! soc ) return 0;
     if ( ssh_login(socket:soc, login:login, password:password,
                    pub:pub, priv:priv, passphrase:passphrase) != 0 )
     {
         close(soc);
         return 0;
     }
 }

 _last_libssh_sess = sess;
 return soc;
}

# Connect to the host HOSTNAME via TCP and setup an ssh connection.

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_open_channel">ssh_open_channel</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_open_channel(socket)
{
 local_var payload, i;

 if (bugged_sshd &amp;&amp; !bugged_first)
 {
   local_channel++;
   if (local_channel &gt; 10)
     return -1;
   l_window_size = 32768;
   received_size = 0;
   remote_channel = bugged_channels[local_channel];
   r_window_size = bugged_rws[local_channel];
   r_packet_size = bugged_rps[local_channel];
   return 0;
 }

 local_channel++;

 # session = &quot;session&quot;
 # initial window size = 32768
 # maximum packet size = 32768
 l_window_size = 32768;
 received_size = 0;
 payload = putstring(buffer:&quot;session&quot;) + raw_int32(i:local_channel) +
	raw_int32(i:32768) + raw_int32(i:32768);

 # SSH_MSG_CHANNEL_OPEN == 90
 send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:90));

 # SSH_MSG_CHANNEL_OPEN_CONFIRMATION == 91 (92 == failure)
 payload = recv_ssh_packet(socket:socket);
 if (ord(payload[0]) != 91)
 {
   set_ssh_error(msg:string(&quot;Received code was not  SSH_MSG_CHANNEL_OPEN_CONFIRMATION (91). It was : &quot; , ord(payload[0])));
   return -1;
 }

 remote_channel = ntol(buffer:payload, begin:5);
 r_window_size = ntol(buffer:payload, begin:9);
 r_packet_size = ntol(buffer:payload, begin:13);

 # For bugged channel like Sun_SSH_1.0 we create 10 channels at startup
 # Sun_SSH supports only 10 channels at the same time.
 if (bugged_sshd)
 {
   bugged_first = 0;
   bugged_channels = bugged_rws = bugged_rps = NULL;
   bugged_channels[0] = 0;
   bugged_rws[0] = 0;
   bugged_rps[0] = 0;
   bugged_channels[local_channel] = remote_channel;
   for (i=local_channel+1; i &lt; 11; i++)
   {
      payload = putstring(buffer:&quot;session&quot;) + raw_int32(i:i) +
	  raw_int32(i:32768) + raw_int32(i:32768);

      send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:90));

      payload = recv_ssh_packet(socket:socket);
      if (ord(payload[0]) != 91)
      {
        set_ssh_error(msg:string(&quot;Received code was not  SSH_MSG_CHANNEL_OPEN_CONFIRMATION (91). It was : &quot; , ord(payload[0])));
        return -1;
      }

      bugged_channels[i] = ntol(buffer:payload, begin:5);
      bugged_rws[i] = ntol(buffer:payload, begin:9);
      bugged_rps[i] = ntol(buffer:payload, begin:13);
   }
 }

 # all is ok, user is authenticated
 return 0;
}

#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_read_from_shell">ssh_read_from_shell</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pattern</dt>
			
		
			<dt>retry</dt>
			
		
			<dt>sess</dt>
			
		
			<dt>timeout</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_read_from_shell( sess, pattern, timeout, retry )
{
  local_var sess, timeout, t, x, ret, buf, pattern, retry;

  if( ! sess )
  {
    set_kb_item( name: &quot;nvt_debug_empty/&quot; + get_script_oid(), value:get_script_oid() + &quot;#-#sess#-#ssh_read_from_shell&quot; );
    return FALSE;
  }

  if( ! timeout ) timeout = 15;
  if( ! retry )   retry = 3;

  x = 1;

  while ( TRUE )
  {
    buf = del_esc_seq( data:ssh_shell_read( sess ) );

    len = strlen( buf );
    t++;

    if( len &gt; 0 )
    {
      ret += buf;
      x = 1;
    }
    else
    {
      if( x++ &gt;= retry ) return ret;
    }

    if( pattern &amp;&amp; ret )
      if( eregmatch( pattern:pattern, string: ret ) ) return ret;

    if( t &gt;= timeout ) return ret;

    sleep( 1 );

    if( &quot;Press Enter to continue&quot; &gt;&lt; ret || &quot;--More&quot; &gt;&lt; ret || &quot;&lt;--- More ---&gt;&quot; &gt;&lt; ret ) ssh_shell_write( sess, cmd: &#39;\n&#39; );
 }

  return ret;

}

function ssh_cmd_pty( sess, cmd, pattern, timeout, retry )

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_reconnect">ssh_reconnect</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>sock</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_reconnect( sock )
{
  if( ! sock ) return;
 
  ssh_disconnect( ssh_session_id_from_sock( sock ) );
  sleep( 1 );
  sock = ssh_login_or_reuse_connection();
  
  if( ! sock ) return;

  return sock;

}


		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_recv">ssh_recv</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>length</dt>
			
		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_recv(socket, length)
{
  local_var header, len, trailer, cmpt, payload, ret;

  header = recv(socket:socket, length:4, min:4);
  if (strlen(header) &lt; 4)return(NULL);
  len = ntol (buffer:header, begin:0);
  if ((len == 0) || (len &gt; 32768)) return(header);
  trailer = recv(socket:socket, length:len, min:len);
  if(strlen(trailer) &lt; len )return(NULL);

  seqn_r++;

  # SSH servers can send IGNORE (code 2) or BANNER (code 53) msg
  ret = ord(trailer[1]);
  if ((ret == 2) || (ret == 53))
  {
    if (ret == 53)
      _ssh_banner += getstring (buffer:trailer, pos:2);

    return ssh_recv(socket:socket, length:length);
  }

  return strcat(header, trailer);
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_reuse_connection">ssh_reuse_connection</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_reuse_connection()
{
}


#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_rsa_verify">ssh_rsa_verify</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
			<dt>e</dt>
			
		
			<dt>n</dt>
			
		
			<dt>signature</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_rsa_verify(e, n, signature, data)
{
 local_var hash, id_sha1, sigtype, nlen,
	next, tmp_sig, siglen, len, sig,
	hdecoid, hshaoid, hhash, decrypted ;

#comes directly from OpenBSD
 id_sha1 = raw_string(
	0x30, 0x21,
	0x30, 0x09,
	0x06, 0x05,
	0x2b, 0x0e, 0x03, 0x02, 0x1a,
	0x05, 0x00,
	0x04, 0x14
	);

 if (!n)
   return 0;

 sigtype = getstring(buffer:signature, pos:0);
 if (sigtype &gt;!&lt; &quot;ssh-rsa&quot;)
   return 0;

 nlen = strlen(n);
 if (ord(n[0]) == 0)
   nlen--;

 # check minimum n size
 if ( (nlen*8) &lt; 768 )
   return 0;

 next = 4 + strlen(sigtype);
 tmp_sig = getstring(buffer:signature,pos:next);
 siglen = strlen(tmp_sig);

 # bad signature (should be less than n)
 if (siglen &gt; nlen)
   return 0;

 # Add padding if needed
 if (siglen &lt; nlen)
 {
   len = nlen - siglen;
   sig = crap(data:raw_string(0x00), length:len) + tmp_sig;
 }
 else
   sig = tmp_sig;

 hash = SHA1(data);

 if (strlen(hash) != 20)
   return 0;

 # must call RSA_public_decrypt from openssl, so convert arg - see ssh-rsa.c
 decrypted = rsa_public_decrypt(sig:sig,e:e,n:n);
 if (!decrypted)
   return 0;

 if (strlen(decrypted) != (strlen(id_sha1)+20))
   return 0;

 hdecoid = hexstr(substr(decrypted,0,strlen(id_sha1)-1));
 hshaoid = hexstr(id_sha1);

 if (hdecoid &gt;!&lt; hshaoid)
   return 0;

 hdecoid = hexstr(substr(decrypted,strlen(id_sha1),strlen(decrypted)-1));
 hhash = hexstr(hash);

 if (hdecoid &gt;!&lt; hhash)
   return 0;

 return 1;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ssh_userauth2">ssh_userauth2</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>passphrase</dt>
			
		
			<dt>password</dt>
			
		
			<dt>priv</dt>
			
		
			<dt>pub</dt>
			
		
			<dt>server_user</dt>
			
		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function ssh_userauth2(socket, server_user, password, pub, priv, passphrase)
{
 local_var payload, buf, support, pass, pkey, kb, authenticated, blobpub, signature, blobpriv, privkey, typestr, next, e, n, hash2, hash, public, line, num, pubtab, i, crap, kb_ok;

 pass = pkey = authenticated = kb = 0;

 payload = putstring(buffer:&quot;ssh-userauth&quot;);

 # code 5 (SSH_MSG_SERVICE_REQUEST)
 send_ssh_packet(socket:socket, payload:payload, code:raw_string(0x05));

 # code 6 (SSH_MSG_SERVICE_ACCEPT)
 payload = recv_ssh_packet(socket:socket);
 if (ord(payload[0]) != 6)
 {
   set_ssh_error(msg:string(&quot;Server does not support ssh-userauth service. Received code was : &quot; , ord(payload[0])));
   return -1;
 }

 # service accepted
 # code 50 (SSH_MSG_USERAUTH_REQUEST)
 # none request: we need to know what authentication server supports
 payload = putstring(buffer:server_user) + putstring(buffer:&quot;ssh-connection&quot;) +
	putstring(buffer:&quot;none&quot;);
 send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:50));

 # (51 == SSH_MSG_USERAUTH_FAILURE)
 payload = recv_ssh_packet(socket:socket);
 if (ord(payload[0]) != 51)
 {
   set_ssh_error(msg:string(&quot;Server did not reject none authentication method. Received code was : &quot; , ord(payload[0])));
   return -1;
 }

 support = getstring(buffer:payload,pos:1);

 _ssh_supported_authentication = support;

 if (pub &amp;&amp; priv)
 {
   if (ereg(string:support, pattern:&quot;publickey&quot;))
     pkey = 1;
   else
   {
     set_ssh_error(msg:string(&quot;Error : Remote server does not support publickey authentication method! It supports : &quot; , support));
     return -1;
   }
 }
 else if (password)
 {
   if (ereg(string:support, pattern:&quot;password&quot;))
     pass = 1;
   else if (ereg(string:support, pattern:&quot;keyboard-interactive&quot;))
     kb = 1;
   else
   {
     set_ssh_error(msg:string(&quot;Error : Remote server does not support one of the following password authentication methods : password, keyboard-interactive. It supports : &quot; , support));
     return -1;
   }
 }
 else
 {
   set_ssh_error(msg:&quot;OpenVAS needs public and private keys or a password!&quot;);
   return -1;
 }


 if (pass)
 {
  # code 50 (SSH_MSG_USERAUTH_REQUEST)
  ###### need extra pad !!!! ######
  ###### Is it useful ?? #####
  payload = putstring(buffer:server_user) + putstring(buffer:&quot;ssh-connection&quot;) +
	putstring(buffer:&quot;password&quot;) + raw_int8(i:0) + putstring(buffer:password)
	;

  send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:50));

  # code 52 (SSH_MSG_USERAUTH_SUCCESS)
  payload = recv_ssh_packet(socket:socket);
  if (ord(payload[0]) == 52)
     authenticated = 1;

  if (!authenticated)
  {
    set_ssh_error(msg:&quot;Password authentication failed. Please check Username and Password.&quot;);
    return -1;
  }
 }
 else if (kb)
 {
  # code 50 (SSH_MSG_USERAUTH_REQUEST)
  payload = putstring(buffer:server_user) + putstring(buffer:&quot;ssh-connection&quot;) +
	putstring(buffer:&quot;keyboard-interactive&quot;) + putstring(buffer:&quot;en-US&quot;) + putstring(buffer:&quot;&quot;)
	;

  send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:50));

  # code 60 (SSH_MSG_USERAUTH_INFO_REQUEST)
  payload = recv_ssh_packet(socket:socket);
  if (ord(payload[0]) != 60)
  {
    set_ssh_error(msg:string(&quot;Server did not reply with SSH_MSG_USERAUTH_INFO_REQUEST during keyboard-interactive exchange. It replied with :&quot;, ord(payload[0])));
    return -1;
  }

  # Method name
  crap = getstring (buffer:payload,pos:1);
  next = 1 + 4 + strlen(crap);

  # Method name complement
  crap = getstring (buffer:payload,pos:next);
  next = next + 4 + strlen(crap);

  # Language
  crap = getstring (buffer:payload,pos:next);
  next = next + 4 + strlen(crap);

  # Number of request
  num = ntol(buffer:payload, begin:next);
  next += 4;

  kb_ok = 0;
  if (num &gt; 0)
  {
    crap = getstring (buffer:payload,pos:next);
    if (&quot;Password:&quot; &gt;&lt; crap)
      kb_ok = 1;
  }

  if (!kb_ok)
  {
    set_ssh_error(msg:&quot;Remote server keyboard-interactive method does not support Password.&quot;);
    return -1;
  }

  # code 61 (SSH_MSG_USERAUTH_INFO_RESPONSE)
  payload = raw_int32(i:1) + putstring(buffer:password);

  send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:61));

  payload = recv_ssh_packet(socket:socket);

  # From draft-ietf-secsh-auth-kbdinteract-06.txt document :
  # Server should now send SSH_MSG_USERAUTH_INFO_REQUEST.
  # REQUEST can ask additionnal informations (like a new password).
  # But if all is correct num-prompts is set to 0 and client must
  # reply with an empty SSH_MSG_USERAUTH_INFO_RESPONSE.
  # So we just send an empty response and look if authentication
  # works. If remote server asked for additionnal informations,
  # authentication will just failed.
  if (ord(payload[0]) == 60)
  {
   # code 61 (SSH_MSG_USERAUTH_INFO_RESPONSE)
   payload = raw_int32(i:0);
   send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:61));
   payload = recv_ssh_packet(socket:socket);
  }
  if (ord(payload[0]) != 52)
  {
    set_ssh_error(msg:string(&quot;Server did not reply with SSH_MSG_USERAUTH_SUCCESS during keyboard-interactive exchange. It replied with :&quot;,ord(payload[0])));
    return -1;
  }

  authenticated = 1;
 }

 else if (!authenticated &amp;&amp; pkey)
 {
  # SSH Public Key File Format (draft-ietf-secsh-publickeyfile-05.txt)
  # ---- BEGIN SSH2 PUBLIC KEY ----
  # Comment: &quot;1024-bit RSA, converted from OpenSSH by galb@test1&quot;
  # AAAAB3NzaC1yc2EAAAABIwAAAIEA1on8gxCGJJWSRT4uOrR13mUaUk0hRf4RzxSZ1zRbYY
  # Fw8pfGesIFoEuVth4HKyF8k1y4mRUnYHP1XNMNMJl1JcEArC2asV8sHf6zSPVffozZ5TT4
  # SfsUu/iKy9lUcCfXzwre4WWZSXXcPff+EHtWshahu3WzBdnGxm5Xoi89zcE=
  # ---- END SSH2 PUBLIC KEY ----
  if (&quot;---&quot; &gt;&lt; pub)
  {
    public = &quot;&quot;;
    pubtab = split(pub, sep:&#39;\n&#39;, keep:0);
    num = max_index(pubtab);
    for (i=0; i&lt;num; i++)
    {
      line = pubtab[i];
      if ((&quot;---&quot; &gt;!&lt; line) &amp;&amp; (&quot;:&quot; &gt;!&lt; line))
      {
        if (&#39;\r&#39; &gt;&lt; line)
          line -= &#39;\r&#39;;
        public += line;
      }
    }
  }
  else
  {
    # OpenSSH Public key file format
    public = ereg_replace(pattern:&quot;[^ ]* ([^ ]*) [^ ]*$&quot;,
	                  string:pub,
		          replace:&quot;\1&quot;);
  }

  blobpub = base64decode(str:public);

  # code 50 (SSH_MSG_USERAUTH_REQUEST)
  ###### need extra pad !!!! ######
  ###### Is it useful ?? #####

  payload = putstring(buffer:server_user) + putstring(buffer:&quot;ssh-connection&quot;) +
	putstring(buffer:&quot;publickey&quot;) + raw_int8(i:1) ;

  to_hash = putstring(buffer:session_id) + raw_int8(i:50);

  typestr = getstring(buffer:blobpub, pos:0);
  if (&quot;ssh-rsa&quot; &gt;&lt; typestr)
  {
    next = 4 + strlen(typestr);
    e = getstring(buffer:blobpub, pos:next);
    next = next + 4 + strlen(e);
    n = getstring(buffer:blobpub, pos:next);

    privkey = pem_to_rsa(priv:priv, passphrase:passphrase);
    if (!privkey)
     {
      set_ssh_error(msg:&quot;OpenVAS failed to load SSH private key (RSA)&quot;);
      return -1;
     }

    payload += putstring(buffer:&quot;ssh-rsa&quot;) + putstring(buffer:blobpub);

    to_hash += payload;

    hash = SHA1(to_hash);
    # FIXME: rsa_sign was changed to use the private key in priv
    # directly.  The above code to extract the parameters n, e and
    # privkey can probably be removed.
    signature = rsa_sign(priv:priv, passphrase:passphrase, data:hash);
    if (!signature)
    {
      set_ssh_error(msg:&quot;Error during client&#39;s RSA signature computing&quot;);
      return -1;
    }

    signature = putstring(buffer:&quot;ssh-rsa&quot;) + putstring(buffer:signature);
  }
  else if (&quot;ssh-dss&quot; &gt;&lt; typestr)
  {
    # p
    next = 4 + strlen(typestr);
    p = getstring (buffer:blobpub,pos:next);
    next = next + 4 + strlen(p);

    # q
    q = getstring (buffer:blobpub,pos:next);
    next = next + 4 + strlen(q);

    # g
    g = getstring (buffer:blobpub,pos:next);
    next = next + 4 + strlen(g);

    # pub key
    pub_key = getstring (buffer:blobpub,pos:next);

    privkey = pem_to_dsa(priv:priv, passphrase:passphrase);
    if (!privkey)
    {
      set_ssh_error(msg:&quot;OpenVAS failed to load SSH private key (DSA)&quot;);
      return -1;
    }

    payload += putstring(buffer:&quot;ssh-dss&quot;) + putstring(buffer:blobpub);

    to_hash += payload;

    hash = SHA1(to_hash);
    signature = dsa_do_sign(p:p, q:q, g:g, pub:pub_key, priv:privkey, data:hash);
    if (!signature)
     {
      set_ssh_error(msg:&quot;Error during client&#39;s DSA signature computing&quot;);
      return -1;
     }

    signature = putstring(buffer:&quot;ssh-dss&quot;) + putstring(buffer:signature);

  }
  else
  {
    set_ssh_error(msg:&quot;Client&#39;s private key type is not supported&quot;);
    return -1;
  }

  payload += putstring(buffer:signature);

  send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:50));

  # code 60 (SSH_MSG_USERAUTH_PK_OK)
  payload = recv_ssh_packet(socket:socket);
  if ((ord(payload[0]) == 52) || (ord(payload[0]) == 60))
     authenticated = 1;

  if (!authenticated)
  {
    payload = &quot;Public key authentication failed.&quot;;
    if (password)
    {
      payload += &#39;
It seems you provided both public/private keys and password.
In this case OpenVAS only use your public and private keys.
OpenVAS did not try both. As password authentication is
vulnerable to Man-In-The-Middle attack, that implies your keys
are useless (a &quot;malicious server&quot; will just reject your public
key authentication and accept any provided password).
&#39;;
    }
    set_ssh_error(msg:payload);

    return -1;
  }
 }

 # all is ok, user is authenticated
 return 0;
}


#-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="update_window_size">update_window_size</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>size</dt>
			
		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function update_window_size(socket,size)
{
 local_var len;

 l_window_size -= size;
 received_size += size;

 # Maximum allocated memory is 20 MB
 # A correct server will send 32768 bytes packet. So we stop before
 # to get data.
 # A non standard server will just be stopped by openvasd.
 if (received_size &gt; 19000000)
   return -1;

 if (l_window_size &lt; 1000)
 {
   len = 32768 - l_window_size;
   payload = raw_int32(i:remote_channel) + raw_int32(i:len);

   # SSH_MSG_CHANNEL_WINDOW_ADJUST == 93
   send_ssh_packet(socket:socket, payload:payload, code:raw_int8(i:93));

   l_window_size += len;
 }

 return 0;
}

function del_esc_seq( data )

		</pre>
		<a href="#top">top</a>
		<hr>
		
		
		
		
		

	</div><!--/span-->
	</div><!--/row-->

	<hr>

	<footer>
		<p>&copy; Tenable Network Security 2014</p>
	</footer>

  </div><!--/.fluid-container-->

  <!-- Le javascript
  ================================================== -->
  <!-- Placed at the end of the document so the pages load faster -->
  <script type="text/javascript" src="js/jquery-1.8.2.js"></script>
  <script type="text/javascript" src="js/bootstrap.min.js"></script>
  <script type="text/javascript" src="js/shCore.js"></script>
  <script type="text/javascript" src="js/shBrushNasl.js"></script>

  <script type="text/javascript">
    SyntaxHighlighter.defaults['collapse'] = true;
    SyntaxHighlighter.defaults['gutter'] = false;
    SyntaxHighlighter.all();
  </script>

  </body>
</html>
