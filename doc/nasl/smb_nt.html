



<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <title>nasldoc: nasl</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Le styles -->
  <style type="text/css">
	body {
	padding-top: 60px;
	padding-bottom: 40px;
	}
	.sidebar-nav {
	padding: 9px 0;
	}
  </style>

  <link href="css/bootstrap.min.css" rel="stylesheet">
  <link href="css/shCore.css" rel="stylesheet" type="text/css" />
  <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />

  <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
	<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <!-- Fav and touch icons -->
  <link rel="shortcut icon" href="ico/favicon.ico">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/apple-touch-icon-144-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/apple-touch-icon-114-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/apple-touch-icon-72-precomposed.png">
  <link rel="apple-touch-icon-precomposed" href="ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

	<div class="navbar navbar-inverse navbar-fixed-top">
	  <div class="navbar-inner">
		<div class="container-fluid">
		  <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		  </a>
		  <a class="brand" href="index.html">nasldoc</a>
		  <div class="nav-collapse collapse">
			<ul class="nav">
			  <li class="active"><a href="index.html">Home</a></li>
			</ul>
		  </div><!--/.nav-collapse -->
		</div>
	  </div>
	</div>

  <div class="container-fluid">
	<div class="row-fluid">
	<div class="span3">
	  <div class="well sidebar-nav">
	  <ul class="nav nav-list">
		
			
			
			<li class="even">
			  <a href="GSHB_BruteForce.html">GSHB_BruteForce.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="GSHB_read_file.html">GSHB_read_file.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="bad_ssh_host_keys.html">bad_ssh_host_keys.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="bad_ssh_keys.html">bad_ssh_keys.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="bin.html">bin.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="byte_func.html">byte_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="cisco_ios.html">cisco_ios.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="cpe.html">cpe.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="default_account.html">default_account.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="default_credentials.html">default_credentials.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="dump.html">dump.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="ftp_func.html">ftp_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="gb_openssl_heartbeat.html">gb_openssl_heartbeat.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="global_settings.html">global_settings.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="gvr_apps_auth_func.html">gvr_apps_auth_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="host_details.html">host_details.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="hp_printers.html">hp_printers.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="http_func.html">http_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="http_keepalive.html">http_keepalive.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="imap_func.html">imap_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="itg.html">itg.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="junos.html">junos.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="kyocera_printers.html">kyocera_printers.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="ldap.html">ldap.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="lexmark_printers.html">lexmark_printers.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="misc_func.html">misc_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="netop.html">netop.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="network_func.html">network_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="nfs_func.html">nfs_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="nmap.html">nmap.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="nntp_func.html">nntp_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="os_eol.html">os_eol.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pingpong.html">pingpong.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="pkg-lib-bsd.html">pkg-lib-bsd.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pkg-lib-deb.html">pkg-lib-deb.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="pkg-lib-gentoo.html">pkg-lib-gentoo.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pkg-lib-hpux.html">pkg-lib-hpux.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="pkg-lib-macosx.html">pkg-lib-macosx.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pkg-lib-rpm.html">pkg-lib-rpm.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="pkg-lib-slack.html">pkg-lib-slack.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="pop3_func.html">pop3_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="revisions-lib.html">revisions-lib.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="rsync_func.html">rsync_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="secpod_activex.html">secpod_activex.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="secpod_ie_supersede.html">secpod_ie_supersede.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="secpod_reg.html">secpod_reg.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="secpod_smb_func.html">secpod_smb_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="secpod_ssl_ciphers.html">secpod_ssl_ciphers.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="sharp_printers.html">sharp_printers.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="sip.html">sip.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="smb_default_credentials.html">smb_default_credentials.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="smb_nt.html">smb_nt.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="smbcl_func.html">smbcl_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="smtp_func.html">smtp_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="snmp_func.html">snmp_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="solaris.html">solaris.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="ssh_func.html">ssh_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="ssl_funcs.html">ssl_funcs.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="telnet_func.html">telnet_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="tftp.html">tftp.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="uddi.html">uddi.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="url_func.html">url_func.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="version_func.html">version_func.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="vmware_esx.html">vmware_esx.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wmi_file.html">wmi_file.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="wmi_hardware.html">wmi_hardware.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wmi_misc.html">wmi_misc.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="wmi_os.html">wmi_os.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wmi_proc.html">wmi_proc.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="wmi_rsop.html">wmi_rsop.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wmi_svc.html">wmi_svc.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="wmi_user.html">wmi_user.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="wordlist.html">wordlist.inc</a>
			</li>
		
			
			
			<li class="odd">
			  <a href="xerox_printers.html">xerox_printers.inc</a>
			</li>
		
			
			
			<li class="even">
			  <a href="xml.html">xml.inc</a>
			</li>
		
	  </ul>
	  </div><!--/.well -->
	</div><!--/span-->
	<div class="span9">

		<a name="top"></a>
		<h1>Overview of smb_nt.inc</h1>
		

		

		
		

		<h1>Public Variable Summary</h1>

		
		<p>Public variables are intended to be accessed by the code that imports
		this library.</p>
		

		<table class="nopad">
		  <tr class="TableHeadingColor">
			<th>Name</th>
			<th>Summary</th>
		  </tr>
		  
		  <tr>
			<td><a href="#g_mhi">g_mhi</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#g_mlo">g_mlo</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#initial">initial</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#isSignActive">isSignActive</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#multiplex_id">multiplex_id</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ntlmssp_flag">ntlmssp_flag</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ntlmv2_flag">ntlmv2_flag</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#s_sign_key">s_sign_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#seq_number">seq_number</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#sign_key">sign_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb">smb</a></td>
			<td></td>
		  </tr>
		  
		</table>
		
		
		
		

		
		
		<h1>Public Function Summary</h1>

		
		<p>Public functions are intended to be called by the code that imports
		this library.</p>
		

		<table class="nopad">
		  <tr class="TableHeadingColor">
			<th>Name</th>
			<th>Summary</th>
		  </tr>
		  
		  <tr>
			<td><a href="#FindFirst2">FindFirst2</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#GetFileVersion">GetFileVersion</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#OpenAndX">OpenAndX</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#OpenAndX2_NTLMSSP">OpenAndX2_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#OpenAndX_NTLMSSP">OpenAndX_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#OpenPipeToSamr">OpenPipeToSamr</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ReadAndX">ReadAndX</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ReadAndX1_NTLMSSP">ReadAndX1_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#ReadAndX2_NTLMSSP">ReadAndX2_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrConnect2">SamrConnect2</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrDom2Sid">SamrDom2Sid</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrLookupNames">SamrLookupNames</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrOpenBuiltin">SamrOpenBuiltin</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrOpenDomain">SamrOpenDomain</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrOpenUser">SamrOpenUser</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrQueryDomainInfo">SamrQueryDomainInfo</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrQueryUserAliases">SamrQueryUserAliases</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrQueryUserGroups">SamrQueryUserGroups</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#SamrQueryUserInfo">SamrQueryUserInfo</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#hextodec">hextodec</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_smb_domain">kb_smb_domain</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_smb_login">kb_smb_login</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_smb_name">kb_smb_name</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_smb_password">kb_smb_password</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#kb_smb_transport">kb_smb_transport</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#netbios_encode">netbios_encode</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#netbios_name">netbios_name</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#netbios_redirector_name">netbios_redirector_name</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#pipe1_accessible_registry">pipe1_accessible_registry</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#pipe2_accessible_registry">pipe2_accessible_registry</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#pipe2_accessible_registry_NTLMSSP">pipe2_accessible_registry_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#pipe_accessible_registry">pipe_accessible_registry</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#pipe_accessible_registry_NTLMSSP">pipe_accessible_registry_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_close">registry1_close</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_decode_binary">registry1_decode_binary</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_decode_dword">registry1_decode_dword</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_decode_sz">registry1_decode_sz</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_enum_key">registry1_enum_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_get_item_dword">registry1_get_item_dword</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_get_item_sz">registry1_get_item_sz</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_get_key">registry1_get_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_get_key_security">registry1_get_key_security</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry1_open_hklm">registry1_open_hklm</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_close">registry2_close</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_close_NTLMSSP">registry2_close_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_decode_binary">registry2_decode_binary</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_decode_dword">registry2_decode_dword</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_decode_sz">registry2_decode_sz</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_enum_key">registry2_enum_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_get_item_dword">registry2_get_item_dword</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_get_item_sz">registry2_get_item_sz</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_get_key">registry2_get_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_get_key_security">registry2_get_key_security</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_open_hklm">registry2_open_hklm</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry2_open_hklm_NTLMSSP">registry2_open_hklm_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_close">registry_close</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_close_NTLMSSP">registry_close_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_decode_binary">registry_decode_binary</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_decode_dword">registry_decode_dword</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_decode_sz">registry_decode_sz</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_delete_key">registry_delete_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_delete_value">registry_delete_value</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_enum_key">registry_enum_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_enum_value">registry_enum_value</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_flush">registry_flush</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_flush_NTLMSSP">registry_flush_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_get_acl">registry_get_acl</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_get_binary">registry_get_binary</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_get_dword">registry_get_dword</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_get_item_dword">registry_get_item_dword</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_get_item_sz">registry_get_item_sz</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_get_key">registry_get_key</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_get_key_security">registry_get_key_security</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_get_sz">registry_get_sz</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_key_exists">registry_key_exists</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_key_writeable_by_non_admin">registry_key_writeable_by_non_admin</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_open_hklm">registry_open_hklm</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_open_hklm_NTLMSSP">registry_open_hklm_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_open_hku">registry_open_hku</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_open_hku_NTLMSSP">registry_open_hku_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#registry_shutdown">registry_shutdown</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#samr_smbreadx">samr_smbreadx</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#samr_smbwritex">samr_smbwritex</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#samr_smbwritex_NTLMSSP">samr_smbwritex_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#samr_uc">samr_uc</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#session_extract_sessionid">session_extract_sessionid</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#session_extract_uid">session_extract_uid</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb1_close_request">smb1_close_request</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb1_get_file_size_NTLMSSP">smb1_get_file_size_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb1ntcreatex">smb1ntcreatex</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_close_request">smb2_close_request</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_get_file_size_NTLMSSP">smb2_get_file_size_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_neg_prot">smb2_neg_prot</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_session_setup">smb2_session_setup</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_session_setup_NTLMSSP_AUTH">smb2_session_setup_NTLMSSP_AUTH</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_session_setup_NTLMSSP_NEGOT">smb2_session_setup_NTLMSSP_NEGOT</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_tconx">smb2_tconx</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_tconx_NTLMSSP">smb2_tconx_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2_tconx_extract_tid">smb2_tconx_extract_tid</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2ntcreatex">smb2ntcreatex</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2ntcreatex_NTLMSSP">smb2ntcreatex_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb2ntcreatex_extract_pipe">smb2ntcreatex_extract_pipe</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_close_request">smb_close_request</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_get_file_size">smb_get_file_size</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_get_systemroot">smb_get_systemroot</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot">smb_neg_prot</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot_NTLMSSP">smb_neg_prot_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot_NTLMv1">smb_neg_prot_NTLMv1</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot_anonymous">smb_neg_prot_anonymous</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot_cleartext">smb_neg_prot_cleartext</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot_cs">smb_neg_prot_cs</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot_domain">smb_neg_prot_domain</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot_sm">smb_neg_prot_sm</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_neg_prot_value">smb_neg_prot_value</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_recv">smb_recv</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_request">smb_session_request</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup">smb_session_setup</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup_NTLMSSP_AUTH">smb_session_setup_NTLMSSP_AUTH</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup_NTLMSSP_NEGOT">smb_session_setup_NTLMSSP_NEGOT</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup_NTLMSSP_auth_flags">smb_session_setup_NTLMSSP_auth_flags</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup_NTLMSSP_extract_addrlist">smb_session_setup_NTLMSSP_extract_addrlist</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup_NTLMSSP_extract_chal">smb_session_setup_NTLMSSP_extract_chal</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup_NTLMSSP_extract_flag">smb_session_setup_NTLMSSP_extract_flag</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup_NTLMvN">smb_session_setup_NTLMvN</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_session_setup_cleartext">smb_session_setup_cleartext</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_tconx">smb_tconx</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_tconx_NTLMSSP">smb_tconx_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smb_tconx_cleartext">smb_tconx_cleartext</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smbntcreatex">smbntcreatex</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smbntcreatex_NTLMSSP">smbntcreatex_NTLMSSP</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#smbntcreatex_extract_pipe">smbntcreatex_extract_pipe</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#tconx_extract_tid">tconx_extract_tid</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#unicode">unicode</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#unicode2">unicode2</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#unicode3">unicode3</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#unicode4">unicode4</a></td>
			<td></td>
		  </tr>
		  
		</table>
		
		
		
		<h1>Private Function Summary</h1>

		
		<p>Private functions are not intended to be called by the code that
		imports this library. There is no functional difference between private
		and public functions, only convention, and they may be called as
		normal. </p>
		

		<table class="nopad">
		  <tr class="TableHeadingColor">
			<th>Name</th>
			<th>Summary</th>
		  </tr>
		  
		  <tr>
			<td><a href="#_ExtractTime">_ExtractTime</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#_SamrDecodeUserInfo">_SamrDecodeUserInfo</a></td>
			<td></td>
		  </tr>
		  
		  <tr>
			<td><a href="#_SamrEnumDomains">_SamrEnumDomains</a></td>
			<td></td>
		  </tr>
		  
		</table>
		
		

		
		
		<h1>Public Variable Details</h1>
		
		<h2 id="g_mhi">g_mhi</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="g_mlo">g_mlo</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="initial">initial</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="isSignActive">isSignActive</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="multiplex_id">multiplex_id</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="ntlmssp_flag">ntlmssp_flag</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="ntlmv2_flag">ntlmv2_flag</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="s_sign_key">s_sign_key</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="seq_number">seq_number</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="sign_key">sign_key</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb">smb</h2>
		

		

		<a href="#top">top</a>
		<hr>
		
		
		
		
		

		
		
		<h1>Public Function Details</h1>
		
		<h2 id="FindFirst2">FindFirst2</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pattern</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function FindFirst2(socket, uid, tid, pattern)
 {
 	local_var uid_lo, uid_hi, tid_lo, tid_hi, r, r2;
	local_var t, nxt, off, name, ret, bcc, bcc_lo, bcc_hi;
	local_var len, len_lo, len_hi;
	local_var unicode_pattern, i;
	local_var data_off, data_off_lo, data_off_hi, bcc2, bcc2_lo, bcc2_hi;
	local_var eof, search_id, err;
 
 	if(isnull(pattern))pattern = &quot;\*&quot;;
 
	for(i=0; i&lt;strlen(pattern); i++){
		unicode_pattern += pattern[i] + raw_string(0);
  	}
	unicode_pattern += raw_string(0, 0);
 	ret = NULL;
  
	bcc = 15 + strlen(unicode_pattern);
	bcc2 = bcc - 3;
	len  = 80 + strlen(unicode_pattern);
 
	uid_lo = uid % 256; uid_hi = uid / 256;
	tid_lo = tid % 256; tid_hi = tid / 256;
	bcc_lo = bcc % 256; bcc_hi = bcc / 256;
	bcc2_lo = bcc2 % 256; bcc2_hi = bcc2 / 256;
	len_lo = len % 256; len_hi = len / 256;
 
	data_off = 80 + strlen(unicode_pattern);
	data_off_lo = data_off % 256; data_off_hi = data_off / 256;
 
	req = raw_string(0x00, 0x00, len_hi, len_lo,   0xFF, 0x53,
 			 0x4D, 0x42, 0x32, 0x00, 0x00, 0x00, 0x00, 0x08);
	if(ntlmssp_flag &amp;&amp; isSignActive)
                req += raw_string(0x05, 0xC0);
        else
                req += raw_string(0x01, 0xC0);
	
	req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi);
	if(ntlmssp_flag){
		g_mhi = multiplex_id / 256;
                g_mlo = multiplex_id % 256;
		req += raw_string(0x33, 0x0c);
	}
	else{
		req += raw_string(0x00, 0x28);
	}
	req += raw_string(uid_lo, uid_hi, g_mlo, g_mhi, 0x0F, bcc2_lo,
			 bcc2_hi, 0x00, 0x00, 0x0A, 0x00, 0x04, 0x11, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, bcc2_lo, bcc2_hi, 0x44, 0x00, 0x00, 0x00, data_off_lo,
			 data_off_hi, 0x01, 0x00, 0x01, 0x00, bcc_lo, bcc_hi, 0x00,
			 0x44, 0x20, 0x16, 0x00, 0x00, 0x02, 0x06, 0x00,
			 0x04, 0x01, 0x00, 0x00, 0x00, 0x00) + unicode_pattern;
	if(ntlmssp_flag &amp;&amp; isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }
	
	send(socket:socket, data:req);
	r = smb_recv(socket:socket, length:65535);
	if(strlen(r) &lt; 80){
		return(NULL);
	}
	if(ntlmssp_flag){
		multiplex_id += 1;
        	if(isSignActive){
          		# verify signature
          		seq_number += 1;
          		len = strlen(r);
          		server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          		orig_sign = substr(r, 18, 23);
          		serv_sign = substr(server_resp, 18, 23);
          		if(orig_sign != serv_sign){
                   		return(FALSE);
          		}
        	}

	}

	err = substr(r, 11, 12);
	if(hexstr(err) != &quot;0000&quot;){
		return NULL;
	}
 
	search_id = substr(r, 60, 61);
	off = 72;
	while(TRUE)
	{
		eof = ord(r[64]);
		while(TRUE)
		{
			t = 1;
			nxt = 0;

			if(off + i + 4 &gt;= strlen(r)){
				break;
			}
 
			for(i=0; i&lt;4; i++)
 			{
				nxt += ord(r[off+i]) * t;
				t *= 256;
 			}
 
 			t = 1;
			len = 0;
 
			if(off+4+4+8+8+8+8+8+8+4+i+4 &gt;= strlen(r)){
				break;
			}
 
			for(i=0; i&lt;4; i++)
			{
				len += ord(r[off+4+4+8+8+8+8+8+8+4+i]) * t;
				t *= 256;
 			}

			if(len &gt;= strlen(r)){
				break;
			}
 			name = NULL;
 
			if(off+4+4+8+8+8+8+8+8+4+4+1+1+24+i+len &gt; strlen(r)){
				break;
			}

			for(i=0; i&lt;len; i+=2){
 				name += r[off+4+4+8+8+8+8+8+8+4+4+4+1+1+24+i];
			}
 
			if(!isnull(name))
			{
				if(isnull(ret)){
					ret = make_list(name);
				}
				else {
					ret = make_list(ret, name);
				}
 			}
 
			off = off + nxt;
			if(nxt == 0)break;
			if((off &gt;= strlen(r)) || off &lt; 0 ){
				return ret;
			}
		 }
		if(eof){
			break;
		}
		else
		{
			req = raw_string(0x00, 0x00, 0x00, 0x52, 0xff, 0x53, 0x4d, 0x42,
					 0x32, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0xC0,
					 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28,
					 uid_lo, uid_hi, g_mlo, g_mhi, 0x0f, 0x0e, 0x00, 0x00,
					 0x00, 0x0a, 0x00, 0x04, 0x11, 0x00, 0x00, 0x00, 
					 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
					 0x00, 0x44, 0x00, 0x00, 0x00, 0x52, 0x00, 0x01,
					 0x00, 0x02, 0x00, 0x11, 0x00, 0x00, 0x44, 0x20) + search_id +
			      raw_string(0x00, 0x02, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00);

			send(socket:socket, data:req);
			r = smb_recv(socket:socket, length:65535);
			if(r){
				err = substr(r, 11, 12);
			}
			if(hexstr(err) != &quot;0000&quot;){
				return NULL;
			}
			if(strlen(r) &lt;= 64  &amp;&amp; hexstr(substr(r, 9, 12)) == &quot;00000000&quot;){
				r = smb_recv(socket:soc, length:65535);
			}
			else if(strlen(r) &lt;= 64){
				break;
			}
			off = 68;
		}
 	}
	return ret;
 }

 #

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="GetFileVersion">GetFileVersion</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>fid</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function GetFileVersion(socket, uid, tid, fid)
 {
 	local_var i, fsize, data, off, tmp, version, v, len;

	fsize = smb_get_file_size(socket:socket, uid:uid, tid:tid, fid:fid);
	if(fsize &lt; 180224){
		off = 0;
	}
	else {
		off = fsize - 180224;
	}

 	for(i = 0; off &lt; fsize; i ++ )
	{
		tmp = ReadAndX(socket:socket, uid:uid, tid:tid, fid:fid, count:16384, off:off);
		if(tmp)
   		{ 
			tmp = str_replace(find:raw_string(0), replace:&quot;&quot;, string:tmp);
			data += tmp;
			version = strstr(data, &quot;ProductVersion&quot;);
			if(version)
   			{
				len = strlen(version);
				for(i=strlen(&quot;ProductVersion&quot;); i&lt;len; i++)
				{
					if((ord(version[i]) &lt; ord(&quot;0&quot;) ||
					    ord(version[i]) &gt; ord(&quot;9&quot;)) &amp;&amp; 
					    version[i] != &quot;.&quot;) {
						return (v);
					}
					else {
						v += version[i];
					}
     				}
   			}
   			off += 16384;
   		}
 	}
	return NULL;
 }

function smb_get_systemroot() {

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="OpenAndX">OpenAndX</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>file</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function OpenAndX(socket, uid, tid, file)
 {
   if(ntlmssp_flag)
   {
     if (strlen(uid) == 8)
     {
        response = OpenAndX2_NTLMSSP(socket:socket, uid:uid, tid:tid, file:file);
        return(response);
     }
     else{
                response = OpenAndX_NTLMSSP(socket:socket, uid:uid, tid:tid, file:file);
                return(response);
        }
   }
 
 	local_var req, tid_lo, tid_hi, uid_lo, uid_hi, len_lo, len_hi, rep;
	local_var fid_lo, fid_hi;

	len_lo = (66 + strlen(file)) % 256;
	len_hi = (66 + strlen(file)) / 256;
 
	tid_lo = tid % 256;
	tid_hi = tid / 256;
 
	uid_lo = uid % 256;
	uid_hi = uid / 256;
 
	bcc_lo = strlen(file) % 256;
	bcc_hi = strlen(file) / 256;
 
 	req = raw_string(0x00, 0x00, len_hi, len_lo,   0xFF, 0x53,
 			 0x4D, 0x42, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x08,
			 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi,
			 0x00, 0x28, uid_lo, uid_hi, g_mlo, g_mhi, 0x0F, 0xFF,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x06,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, bcc_lo, bcc_hi) + file +
	      raw_string(0x00);

	send(socket:socket, data:req);
	rep = smb_recv(socket:socket, length:4096);
	if(strlen(rep) &lt; 65){
		return(NULL);
	}

	else
 	{
 		fid_lo = ord(rep[41]);
		fid_hi = ord(rep[42]);
		return(fid_lo + (fid_hi * 256));
	}
 }

 #

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="OpenAndX2_NTLMSSP">OpenAndX2_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>file</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function OpenAndX2_NTLMSSP(socket, uid, tid, file)
 {
        local_var req, tid_lo, tid_hi, uid_lo, uid_hi, len_lo, len_hi, rep;
        local_var fid_lo, fid_hi;

        g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;
        file_le = strlen(file) +1;
        file = substr(file, 1, file_le);

        file_len = strlen(file) + strlen(file);

        bcc_lo = file_len % 256;
        bcc_hi = file_len / 256;
        uc = unicode(data:file);


        req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x60, 0x1f);

        if(isSignActive){
                      req += raw_string(0x08, 0x00, 0x00, 0x00);
        }
        else {
                     req += raw_string(0x00, 0x00, 0x00, 0x00);
        }

                     req += raw_string(0x00, 0x00, 0x00, 0x00,
                         g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, tid, uid);

        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
        namelen = strlen(name)+1;
        name_hi = namelen / 256;
        name_lo = namelen % 256;

        req += raw_string(0x39, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
                          0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x78, 0x00, bcc_lo, bcc_hi,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00) + uc;


   if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, (strlen(req)/256), (strlen(req)%256)) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, (strlen(req)/256), (strlen(req)%256)) + req;
    }

        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4000);
        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }

        if(always_return_blob){
                return(r);
        }
        if(strlen(r) &lt; 10){
                return(FALSE);
        }

        multiplex_id += 1;
        if(isSignActive){
            # verify signature
            seq_number += 1;
             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);

             orig_sign = substr(r, 48, 63);

             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else {
               r = r_head + r ;
             }
         }

        if(strlen(r) &lt; 65){
          return(NULL);
        }
        else
        {
        return( smbntcreatex_extract_pipe(reply:r));
        }
 }



 function OpenAndX(socket, uid, tid, file)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="OpenAndX_NTLMSSP">OpenAndX_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>file</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function OpenAndX_NTLMSSP(socket, uid, tid, file)
 {
        local_var req, tid_lo, tid_hi, uid_lo, uid_hi, len_lo, len_hi, rep;
        local_var fid_lo, fid_hi;

 	g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        len_lo = (66 + strlen(file)) % 256;
        len_hi = (66 + strlen(file)) / 256;

        tid_lo = tid % 256;
        tid_hi = tid / 256;

        uid_lo = uid % 256;
        uid_hi = uid / 256;

        bcc_lo = strlen(file) % 256;
        bcc_hi = strlen(file) / 256;

        req = raw_string(0x00, 0x00, len_hi, len_lo,   0xFF, 0x53,
                         0x4D, 0x42, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x08);

	if(isSignActive)
                req += raw_string(0x05, 0x40);
        else
                req += raw_string(0x01, 0x40);

        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi,
                         0x33, 0x0c, uid_lo, uid_hi, g_mlo, g_mhi, 0x0F, 0xFF,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x06,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, bcc_lo, bcc_hi) + file +
              raw_string(0x00);

	if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }

        send(socket:socket, data:req);
        rep = smb_recv(socket:socket, length:4096);
	multiplex_id += 1;
        if(rep &amp;&amp; isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(rep);
          server_resp = get_signature(key:s_sign_key, buf:rep, buflen:len, seq_number:seq_number);
          orig_sign = substr(rep, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
          }
        }

        if(strlen(rep) &lt; 65){
                return(NULL);
        }

        else
        {
                fid_lo = ord(rep[41]);
                fid_hi = ord(rep[42]);
                return(fid_lo + (fid_hi * 256));
        }
 }

function OpenAndX2_NTLMSSP(socket, uid, tid, file)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="OpenPipeToSamr">OpenPipeToSamr</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function OpenPipeToSamr(soc, uid, tid)
 {
	tid_hi = tid / 256;
	tid_lo = tid % 256;
 
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
 	req = raw_string(0x00, 0x00,
 			 0x00, 0x60, 0xFF, 0x53, 0x4D, 0x42, 0xA2, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi);
	if(ntlmssp_flag){
		 g_mhi = multiplex_id / 256;
        	 g_mlo = multiplex_id % 256;
                req += raw_string(0x33, 0x0c);
	}
        else
                req += raw_string(0x00, 0x28);

	req += raw_string(uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x18, 0xFF, 0x00, 0xDE, 0xDE, 0x00,
			 0x0A, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 
			 0x00, 0x00, 0x9F, 0x01, 0x02, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00,
			 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00,
			 0x00, 0x00, 0x03, 0x0D, 0x00, 0x00, 0x5C, 0x00,
			 0x73, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x72, 0x00,
			 0x00, 0x00);
	if(ntlmssp_flag &amp;&amp; isSignActive){
              len = strlen(req);
              seq_number += 1;
              packet = req;
              req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }
 	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(ntlmssp_flag){
                multiplex_id += 1;
                if(r &amp;&amp; isSignActive){
                      # verify signature
                      seq_number += 1;
                      len = strlen(r);
                      server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                      orig_sign = substr(r, 18, 23);
                      serv_sign = substr(server_resp, 18, 23);
                      if(orig_sign != serv_sign){
                              return(FALSE);
                      }
                }
        }

	if(strlen(r) &lt; 42){
		return(FALSE);
	}
	else
	{
		low = ord(r[42]);
		hi  = ord(r[43]);
		ret = hi * 256;
		ret = ret + low;
		return(ret);
	}
 }
 function samr_smbwritex_NTLMSSP(soc, tid, uid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ReadAndX">ReadAndX</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>count</dt>
			
		
			<dt>fid</dt>
			
		
			<dt>off</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function ReadAndX(socket, uid, tid, fid, count, off)
 {
  if(ntlmssp_flag)
  {
    if (strlen(uid) == 8)
    {
        response = ReadAndX2_NTLMSSP(socket:socket, uid:uid, tid:tid, fid:fid, count:count, off:off);
        return(response);
    }
    else{
        response = ReadAndX1_NTLMSSP(socket:socket, uid:uid, tid:tid, fid:fid, count:count, off:off);
        return(response);
    }

  }

  local_var r, req, uid_lo, uid_hi, tid_lo, tid_hi, fid_lo, fid_hi, off_hi, off_lo, ret, i;
 
	uid_lo = uid % 256; uid_hi = uid / 256;
	tid_lo = tid % 256; tid_hi = tid / 256;
	fid_lo = fid % 256; fid_hi = fid / 256;
	cnt_lo = count % 256; cnt_hi = count / 256;
 
	off_lo_lo = off % 256;  off /= 256;
	off_lo_hi = off % 256;  off /= 256;
	off_hi_lo = off % 256;  off /= 256;
	off_hi_hi = off;
 
	req = raw_string(0x00, 0x00, 0x00, 0x37, 0xFF, 0x53,
 			 0x4D, 0x42, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x08,
			 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi,
			 0x00, 0x28, uid_lo, uid_hi, g_mlo, g_mhi, 0x0A, 0xFF,
			 0x00, 0x00, 0x00, fid_lo, fid_hi, off_lo_lo, off_lo_hi, off_hi_lo, 
			 off_hi_hi, cnt_lo, cnt_hi, cnt_lo, cnt_hi, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
 
	send(socket:socket, data:req);
	r = smb_recv(socket:socket, length:65535);
	ret = &quot;&quot;;
	if(strlen(r) &lt; 37 + 28){
		return(NULL);
	}
	return (substr(r, 36+28, strlen(r) - 1));	  
 }

 function smb_close_request(soc, uid, tid, fid)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ReadAndX1_NTLMSSP">ReadAndX1_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>count</dt>
			
		
			<dt>fid</dt>
			
		
			<dt>off</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function ReadAndX1_NTLMSSP(socket, uid, tid, fid, count, off)
 {
        local_var r, req, uid_lo, uid_hi, tid_lo, tid_hi, fid_lo, fid_hi, off_hi, off_lo, ret, i;
	g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        uid_lo = uid % 256; uid_hi = uid / 256;
        tid_lo = tid % 256; tid_hi = tid / 256;
        fid_lo = fid % 256; fid_hi = fid / 256;
        cnt_lo = count % 256; cnt_hi = count / 256;

        off_lo_lo = off % 256;  off /= 256;
        off_lo_hi = off % 256;  off /= 256;
        off_hi_lo = off % 256;  off /= 256;
        off_hi_hi = off;

        req = raw_string(0x00, 0x00, 0x00, 0x37, 0xFF, 0x53,
                         0x4D, 0x42, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x08);
	if(isSignActive)
                req += raw_string(0x05, 0x40);
        else
                req += raw_string(0x01, 0x40);	
        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi,
                         0x33, 0x0c, uid_lo, uid_hi, g_mlo, g_mhi, 0x0A, 0xFF,
                         0x00, 0x00, 0x00, fid_lo, fid_hi, off_lo_lo, off_lo_hi, off_hi_lo,
                         off_hi_hi, cnt_lo, cnt_hi, cnt_lo, cnt_hi, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

	if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }

        send(socket:socket, data:req);
        r = smb_recv(socket:socket, length:65535);
	multiplex_id += 1;
        if(r &amp;&amp; isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(r);
          server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          orig_sign = substr(r, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
          }
        }

        ret = &quot;&quot;;
        if(strlen(r) &lt; 37 + 28){
                return(NULL);
        }
        return(substr(r, 36+28, strlen(r) - 1));
 }

 function ReadAndX(socket, uid, tid, fid, count, off)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="ReadAndX2_NTLMSSP">ReadAndX2_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>count</dt>
			
		
			<dt>fid</dt>
			
		
			<dt>off</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function ReadAndX2_NTLMSSP(socket, uid, tid, fid, count, off)
 {
    g_mhi = multiplex_id / 256;
    g_mlo = multiplex_id % 256;
    cnt_lo_lo = count % 256; count /= 256;
    cnt_lo_hi = count % 256; count /= 256;
    cnt_hi_lo = count % 256; count /= 256;
    cnt_hi_hi = count;


    off_lo_lo = off % 256;  off /= 256;
    off_lo_lo_lo = off % 256;  off /= 256;
    off_lo_lo_hi = off % 256;  off /= 256;
    off_lo_hi = off % 256;  off /= 256;
    off_lo_hi_lo = off % 256;  off /= 256;
    off_lo_hi_hi = off % 256;  off /= 256;
    off_hi_lo = off % 256;  off /= 256;
    off_hi_hi = off;

    req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x60, 0x1f);
   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }
    req += raw_string(0x00, 0x00, 0x00, 0x00,
                     g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, tid, uid);

        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
        namelen = strlen(name)+1;
        name_hi = namelen / 256;
        name_lo = namelen % 256;

        req += raw_string(0x31, 0x00, 0x50, 0x00, cnt_lo_lo, cnt_lo_hi, cnt_hi_lo, cnt_hi_hi,
                          off_lo_lo, off_lo_lo_lo, off_lo_lo_hi, off_lo_hi,
                          off_lo_hi_lo, off_lo_hi_hi, off_hi_lo, off_hi_hi,
                          fid, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

   if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + req ;
    }
        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4000);
        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }

        if(always_return_blob){
                return(r);
        }
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
        multiplex_id += 1;
        if(isSignActive){
                # verify signature
                seq_number += 1;
             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);

             orig_sign = substr(r, 48, 63);
             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else {
               r = r_head + r;
          }
        }
        return(substr(r, 84, strlen(r) - 1));
 }

 function ReadAndX1_NTLMSSP(socket, uid, tid, fid, count, off)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrConnect2">SamrConnect2</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>name</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrConnect2(soc, tid, uid, pipe, name)
 {
	local_var i;
 	samr_smbwritex(soc:soc, tid:tid, uid:uid, pipe:pipe);
	samr_smbreadx(soc:soc, tid:tid, uid:uid, pipe:pipe);
 
	l = strlen(name);
	odd = l % 2;
 
	if(odd){
		p = 0;
	}
	else {
		p = 2;
	}
 
	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
 	l = 3 + strlen(name);
	l_h = l / 256;
	l_l = l % 256;

	tot_len = 134 + strlen(name) + strlen(name) + p;
	tot_len_h = tot_len / 256;
	tot_len_l = tot_len % 256;
 
	bcc = 67 + strlen(name) + strlen(name) + p;
	bcc_lo = bcc % 256;
	bcc_hi = bcc / 256;
 
	total_data_count = 50 + strlen(name) + strlen(name) + p;
	total_data_count_lo = total_data_count % 256;
	total_data_count_hi = total_data_count / 256;
 
	req = raw_string(0x00, 0x00,
 			 tot_len_h, tot_len_l, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00,total_data_count_lo, total_data_count_hi, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, total_data_count_lo, total_data_count_hi, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, bcc_lo, bcc_hi, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0xAF, 0x47, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, total_data_count_lo, total_data_count_hi,
			 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x28, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x39, 0x00, 0x60, 0x60,
			 0x13, 0x00, l_l, l_h, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, l_l, l_h, 0x00, 0x00, 0x5C, 0x00,
			 0x5C) + samr_uc(name:name) + raw_string(0x00, 0x00, 0x00);
		  
	if(p){
		req = req + raw_string(0xC9, 0x11); # 0x02, 0x00, 0x00, 0x00);
	}
  
	req = req +  raw_string(0x30, 0x00, 0x00, 0x00);
	#display(strlen(req), &quot;\n&quot;);		  
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);		  
	#display(&quot;---&gt;&quot;, strlen(r), &quot;\n&quot;);

 	# We return a handle to the remote SAM
	samrhdl = &quot;&quot;;
	_len = strlen(r);
	if(_len &lt; 24){
		return(FALSE);
	}
	
	_len = _len - 24;
	for(i=0; i&lt;20; i=i+1)
	{
		samrhdl = samrhdl + raw_string(ord(r[i+_len]));
		#display(hex(ord(r[i+_len])), &quot; &quot;);
	}
	#display(&quot;\n&quot;);
	#display(&quot;samhdl : &quot;, strlen(samrhdl), &quot;\n&quot;);
	return (samrhdl);
 }

 #--------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrDom2Sid">SamrDom2Sid</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>dom</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>samrhdl</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrDom2Sid(soc, tid, uid, pipe, samrhdl, dom)
 {
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
	#display(strlen(dom), &quot;&lt;-dom\n&quot;);
	tot_len = 148 + strlen(dom);
	tot_len_hi = tot_len / 256;
	tot_len_lo = tot_len % 256;
 
	bcc = 81 + strlen(dom);
	bcc_lo = bcc % 256;
	bcc_hi = bcc / 256;
 
	tot_dat_count = 64 + strlen(dom);
	tot_dat_count_lo = tot_dat_count % 256;
	tot_dat_count_hi = tot_dat_count / 256;
 
	dom_len = strlen(dom);
	dom_len = dom_len / 2;
	dom_len_lo = dom_len % 256;
	dom_len_hi = dom_len / 256;
  
	dom_t_len =  dom_len + 1;
	dom_t_len_lo = dom_t_len % 256;
	dom_t_len_hi = dom_t_len / 256;
 
	dom_m_len = dom_len * 2;
	dom_m_len_lo = dom_m_len % 256;
	dom_m_len_hi = dom_m_len / 256;
 
	dom_mm_len = dom_m_len + 2;
	dom_mm_len_lo = dom_mm_len % 256;
	dom_mm_len_hi = dom_mm_len / 256;
 
 	req = raw_string(0x00, 0x00,
 			 tot_len_hi, tot_len_lo, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, tot_dat_count_lo, tot_dat_count_hi, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, tot_dat_count_lo, tot_dat_count_hi, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, bcc_lo, bcc_hi, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0xAF, 0x47, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, tot_dat_count_lo, tot_dat_count_hi,
			 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x38, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x05, 0x00) + samrhdl + 
	      raw_string(dom_m_len_lo, dom_m_len_hi, dom_mm_len_lo, dom_mm_len_hi, 0x40, 0x7B,
			 0x13, 0x00, dom_t_len_lo, dom_t_len_hi, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, dom_len_lo, dom_len_hi, 0x00) + dom + raw_string(0x00);
		 
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(strlen(r) &lt; 88){
		return(FALSE);
	}
	#display(ord(r[88]), &quot;\n&quot;);  
  	_sid = &quot;&quot;;
  	for(i=0; i&lt;28; i=i+1)
	{
		_sid = _sid + raw_string(ord(r[88+i]));
		 #display(hex(ord(r[88+i])),  &quot; &quot;);
  	}
	#display(&quot;\n&quot;);
	return (_sid);
 }

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrLookupNames">SamrLookupNames</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>domhdl</dt>
			
		
			<dt>name</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrLookupNames(soc, uid, tid, pipe, name, domhdl)
 {
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
	usr = samr_uc(name:name);
	len = 164 + strlen(usr);
	len_hi = len / 256;
	len_lo = len % 256;
 
	tdc = 80 + strlen(usr);
	tdc_l = tdc % 256;
	tdc_h = tdc / 256;
 
	bcc = tdc + 17;
	bcc_l = bcc % 256;
	bcc_h = bcc / 256;
 
	x = strlen(usr) / 2;
	x_h = x / 256;
	x_l = x % 256;
 
	y = x + 1;
	y_h = y / 256;
	y_l = y % 256;
 
	z = strlen(usr);
	z_l = z % 256;
	z_h = z / 256;
 
	t = z + 2;
	t_l = t % 256;
	t_h = t / 256;
 
	req = raw_string(0x00, 0x00, 
 			 len_hi, len_lo, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, tdc_l, tdc_h, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, tdc_l, tdc_h, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, bcc_l, bcc_h, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0xAF, 0x47, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, tdc_l, tdc_h,
			 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x44, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x11, 0x00) + domhdl +
	      raw_string(0x01, 0x00, 0x00, 0x00, 0xE8, 0x03,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
			 0x00, 0x00, z_l, z_h, t_l, t_h, 0xD8, 0x0E, 
			 0x41, 0x00, y_l, y_h, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, x_l, x_h, 0x00) + usr + 
              raw_string(0x00);

	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);		
 
	if(strlen(r) &lt; 100){
		return(FALSE);
	}
 
	_rid = &quot;&quot;;
	#display(&quot;RID : &quot;);
	_z = 0;
	for(i=0; i&lt;4; i=i+1)
	{
		if(ord(r[96+i]) == 0){	
			_z = _z + 1;
		}
		#display(hex(ord(r[96+i])), &quot; &quot;);
		_rid = _rid + raw_string(ord(r[96+i]));
	}
	#display(&quot;\n&quot;);
	if(_z == 4){
		return(NULL);
	} 
	return(_rid);
 }

 #--------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrOpenBuiltin">SamrOpenBuiltin</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>samrhdl</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrOpenBuiltin(soc, tid, uid, pipe, samrhdl)
 {
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;

	req = raw_string(0x00, 0x00,
 			 0x00, 0x94, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x40, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x40, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, 0x51, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00,
			 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x28, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x07, 0x00) + samrhdl +
	      raw_string(0x80, 0x02, 0x00, 0x00, 0x01, 0x00,
			 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x05, 0x20, 0x00, 0x00, 0x00);
		  
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	builtinhdl = &quot;&quot;;
	_len = strlen(r);
	_len = _len - 24;
	_z  = 0;
	for(i=0; i&lt;20; i=i+1)
 	{
		if(ord(r[i+_len]) == 0){
			_z = _z + 1;
		}
		builtinhdl = builtinhdl + raw_string(ord(r[i+_len]));
		#display(hex(ord(r[i+_len])), &quot; &quot;);
 	}
	if(_z == 20){
		return(NULL);
	}
	#display(&quot;\n&quot;);
	#display(&quot;builtinhdl : &quot;, strlen(builtinhdl), &quot;\n&quot;);
	return(builtinhdl);
 }

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrOpenDomain">SamrOpenDomain</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>samrhdl</dt>
			
		
			<dt>sid</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrOpenDomain(soc, tid, uid, pipe, samrhdl, sid)
 {
 	#display(&quot;sid = &quot;, strlen(sid), &quot;\n&quot;);
	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
 	len = 132 + strlen(sid);
	len_h = len / 256;
	len_l = len % 256;

	tdc = 48 + strlen(sid);
	tdc_l = tdc % 256;
	tdc_h = tdc / 256;
 
	bcc = tdc + 17;
	bcc_l = bcc % 256;
	bcc_h = bcc / 256;
	req = raw_string(0x00, 0x00,
 			 0x00, 0xA0, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x4C, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x4C, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, 0x5D, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x33, 0x00, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x34, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x07, 0x00) + samrhdl +
	      raw_string(0x00, 0x02, 0x00, 0x00) + sid;
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(strlen(r) &lt; 30){
		return(FALSE);
	}
 	#display(strlen(r),&quot;\n&quot;);
	samrhdl = &quot;&quot;;
	_len = strlen(r);
	_len = _len - 24;
	_z = 0;
	for(i=0; i&lt;20; i=i+1)
 	{
		if(ord(r[i+_len]) == 0)_z = _z + 1;
		samrhdl = samrhdl + raw_string(ord(r[i+_len]));
		#display(hex(ord(r[i+_len])), &quot; &quot;);
	}
	#display(&quot;\n&quot;);
	#display(&quot;samhdl : &quot;, strlen(samrhdl), &quot;\n&quot;);
	if(_z == 20){
		return(NULL);
	}
 	return(samrhdl);
 }

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrOpenUser">SamrOpenUser</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>rid</dt>
			
		
			<dt>samrhdl</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrOpenUser(soc, uid, tid, pipe, samrhdl, rid)
 {
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
	len = 176;
	len_hi = len / 256;
	len_lo = len % 256;
 
	req = raw_string(0x00, 0x00,
 			 0x00, 0x88, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x34, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x34, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, 0x45, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x33, 0x00, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x34, 0x00,
			 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1c, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x22, 0x00) + samrhdl +
	      raw_string(0x1B, 0x01, 0x02, 0x00) + rid;

	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(strlen(r) &lt; 100){
		return(FALSE);
	}
 
	_usrhdl = &quot;&quot;;
	_len = strlen(r);
	_len = _len - 24;
	#display(&quot;usrhdl = &quot;);
	_z = 0;
	for(i=0; i&lt;20; i=i+1)
	{
		if(ord(r[i+_len]) == 0){
			_z = _z + 1;
		}
		_usrhdl = _usrhdl + raw_string(ord(r[i+_len]));
		#display(hex(ord(r[i+_len])), &quot; &quot;);
 	}
 	if(_z == 20){
		return(NULL);
	}
	#display(&quot;\n&quot;);
	return(_usrhdl);
 }

 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrQueryDomainInfo">SamrQueryDomainInfo</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>level</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>samrhdl</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrQueryDomainInfo(soc, tid, uid, pipe, samrhdl, level)
 {
 	#display(&quot;sid = &quot;, strlen(sid), &quot;\n&quot;);
	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
 	req = raw_string(0x00, 0x00,
 			 0x00, 0x82, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x2e, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x2e, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, 0x3f, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x45, 0x00, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x2E, 0x00,
			 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x16, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x08, 0x00) + samrhdl +
	      raw_string(level % 256, level / 256);

	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(strlen(r) &lt; 30){
		return(FALSE);
	}
	return r;	
 }


 function SamrOpenBuiltin(soc, tid, uid, pipe, samrhdl)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrQueryUserAliases">SamrQueryUserAliases</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>rid</dt>
			
		
			<dt>sid</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
			<dt>usrhdl</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrQueryUserAliases(soc, uid, tid, pipe, usrhdl, sid, rid)
 {
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
	subsid = &quot;&quot;;
 
	for(i=0; i&lt;20; i=i+1)
	{
		subsid = subsid + raw_string(ord(sid[8+i]));
		#display(hex(ord(sid[8+i])), &quot; &quot;);
	}
	#display(&quot;\n&quot;);
 
	req = raw_string(0x00, 0x00, 
 			 0x00, 0xB0, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x5C, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x5C, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, 0x6D, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x5C, 0x00,
			 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x44, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x10, 0x00) + usrhdl +
	      raw_string(0x01, 0x00, 0x00, 0x00, 0x88, 0x7C,
       	 		 0x13, 0x00, 0x01, 0x00, 0x00, 0x00, 0x98, 0x7C,
			 0x13, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x05,
			 0x00, 0x00) + subsid + rid;
		  
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
 
	if(strlen(r) &lt; 100)
	{
 		#display(&quot;=====&gt;&quot;, strlen(r), &quot;&lt;====\n&quot;);
		return(FALSE);
	}
 
 	num_lo = ord(r[92]);
	num_hi = ord(r[93]);
 
	num = num_hi * 256;
	num = num + num_lo;
	#display(&quot;NUM EGAL : &quot;, num, &quot;\n&quot;);
	base = 96;
	rids = &quot;&quot;;
	for(i=0; i&lt;num; i=i+1)
 	{
		_rid = string(hex(ord(r[base+3])), &quot;-&quot;,
  			      hex(ord(r[base+2])), &quot;-&quot;,
			      hex(ord(r[base+1])), &quot;-&quot;,
			      hex(ord(r[base])));
  		rids = rids + _rid + string(&quot;\n&quot;);		
		base = base + 4;		
	}
	return(rids);
 }

 function _ExtractTime(buffer, base)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrQueryUserGroups">SamrQueryUserGroups</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
			<dt>usrhdl</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrQueryUserGroups(soc, uid, tid, pipe, usrhdl)
 {
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
	req = raw_string(0x00, 0x00,
 			 0x00, 0x80, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x2C, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x2C, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26, 
			 0x00, pipe_lo, pipe_hi, 0x3D, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x2C, 0x00,
			 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x14, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x27, 0x00) + usrhdl;
 	send(socket:soc, data:req);
	r = recv(socket:soc, length:4096); 
 
 	num_lo = ord(r[88]);
	num_hi = ord(r[89]);
 
	num = num_hi * 256;
	num = num + num_lo;
 
	# Ok. Our user is in &lt;num&gt; groups. Let&#39;s decode their RID
 
	if(strlen(r) &lt; 103){
		return(FALSE);
	}
	base = 100;
	rids = &quot;&quot;;
	for(i=0; i&lt;num; i=i+1)
	{
		g_rid = string(hex(ord(r[base+3])), &quot;-&quot;, 
		hex(ord(r[base+2])), &quot;-&quot;,
		hex(ord(r[base+1])), &quot;-&quot;,
		hex(ord(r[base])));
	   
		base = base + 8;
		rids = rids + g_rid + string(&quot;\n&quot;);
 	}	
	return(rids);
 }

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="SamrQueryUserInfo">SamrQueryUserInfo</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
			<dt>usrhdl</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function SamrQueryUserInfo(soc, uid, tid, pipe, usrhdl)
 {
	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
	req = raw_string(0x00, 0x00,
 			 0x00, 0x82, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x2E, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x2E, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, 0x3F, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x33, 0x00, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x2E, 0x00,
			 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x16, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x24, 0x00) + usrhdl +
	      raw_string(0x15, 0x00);

	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);

	return (r);
 }

 #-----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="hextodec">hextodec</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>str</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function hextodec(str)
 {
        local_var flag, i;
        str_up = toupper(str);
        digits = &quot;0123456789ABCDEF&quot;;
        len = strlen(str_up) - 1;
        for(i=0; i&lt;=len; i++)
        {
                for(j=0;j&lt;strlen(digits); j++)
                {
                        if(str_up[i] == digits[j])
                        {
                                flag += j*(16**(len - i));
                        }
                 }
        }
        return(flag);
 }


 global_var multiplex_id, g_mhi, g_mlo, s_sign_key, initial, seq_number, ntlmssp_flag, ntlmv2_flag, isSignActive, sign_key, smb;

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_smb_domain">kb_smb_domain</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function kb_smb_domain(){
 	return string(get_kb_item(&quot;SMB/domain&quot;));
 }

 function kb_smb_login(){

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_smb_login">kb_smb_login</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function kb_smb_login(){
 	return string(get_kb_item(&quot;SMB/login&quot;));
 }

 function kb_smb_password(){

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_smb_name">kb_smb_name</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function kb_smb_name(){
  return string(get_kb_item(&quot;SMB/name&quot;));
 }

 function kb_smb_domain(){

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_smb_password">kb_smb_password</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function kb_smb_password(){
 	return string(get_kb_item(&quot;SMB/password&quot;));
 }

 function kb_smb_transport()

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="kb_smb_transport">kb_smb_transport</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function kb_smb_transport()
 {
	local_var r;
	r = get_kb_item(&quot;SMB/transport&quot;);
	if(r){
		return int(r);
	}
	else {
		return 445;
	}
 }


 #-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="netbios_encode">netbios_encode</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
			<dt>service</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function netbios_encode(data,service)
 {
	local_var tmpdata, ret, i;

	ret = &quot;&quot;;
	tmpdata = data;

	while(strlen(tmpdata) &lt; 15){
		tmpdata += &quot; &quot;;
	}

	tmpdata += raw_string(service);
	for(i=0; i&lt;16; i=i+1)
	{
		o = ord(tmpdata[i]);
		odiv = o/16;
		odiv = odiv + ord(&quot;A&quot;);
		omod = o%16;
		omod = omod + ord(&quot;A&quot;);
		c = raw_string(odiv, omod);
		ret = ret+c;
	}
	return(ret);
 }

 #-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="netbios_name">netbios_name</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>orig</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function netbios_name(orig){
 	return netbios_encode(data:orig, service:0x20); 
 }

 #--------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="netbios_redirector_name">netbios_redirector_name</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function netbios_redirector_name()
 {
 	ret = crap(data:&quot;CA&quot;, length:30);
 	ret = ret+&quot;AA&quot;;
 	return(ret); 
 }

 #-------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="pipe1_accessible_registry">pipe1_accessible_registry</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function pipe1_accessible_registry(soc, uid, tid, pipe)
{
   if(ntlmssp_flag)
   {
     response = pipe_accessible_registry_NTLMSSP(soc:soc, uid:uid, tid:tid, pipe:pipe);
     return(response);
   }
   else
   {
        tid_low = tid % 256;
        tid_high = tid / 256;
        uid_low = uid % 256;
        uid_high = uid / 256;
        pipe_low = pipe % 256;
        pipe_high = pipe / 256;

        req = raw_string(0x00, 0x00,
                         0x00, 0x94, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
                         0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x1B, 0x81,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
                         g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x48, 0x00, 0x00,
                         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4C,
                         0x00, 0x48, 0x00, 0x4C, 0x00, 0x02, 0x00, 0x26,
                         0x00, pipe_low, pipe_high, 0x51, 0x00, 0x5C, 0x50, 0x49,
                         0x50, 0x45, 0x5C, 0x00, 0x00, 0x00, 0x05, 0x00,
                         0x0B, 0x00, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x16,
                         0x30, 0x16, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0xd0,
                         0x8c, 0x33, 0x44, 0x22, 0xF1, 0x31, 0xAA, 0xAA,
                         0x90, 0x00, 0x38, 0x00, 0x10, 0x03, 0x01, 0x00,
                         0x00, 0x00, 0x04, 0x5D, 0x88, 0x8A, 0xEB, 0x1C,
                         0xc9, 0x11, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10,
                         0x48, 0x60, 0x02, 0x00, 0x00, 0x00);

        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4096);
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
        if(ord(r[9])==0){
                return(r);
        }
        else {
                return(FALSE);
        }
   }
 }

 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="pipe2_accessible_registry">pipe2_accessible_registry</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function pipe2_accessible_registry(soc, uid, tid, pipe)
 {
   if(ntlmssp_flag)
   {
     response = pipe2_accessible_registry_NTLMSSP(soc:soc, uid:uid, tid:tid, pipe:pipe);
     return(response);
   }
   else
   {
      tid_low = tid % 256;
      tid_high = tid / 256;
      uid_low = uid % 256;
      uid_high = uid / 256;
      pipe_low = pipe % 256;
      pipe_high = pipe / 256;

      req = raw_string(0x00, 0x00,
                       0x00, 0x94, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
                       0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x1B, 0x81,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
                       g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x48, 0x00, 0x00,
                       0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4C,
                       0x00, 0x48, 0x00, 0x4C, 0x00, 0x02, 0x00, 0x26,
                       0x00, pipe_low, pipe_high, 0x51, 0x00, 0x5C, 0x50, 0x49,
                       0x50, 0x45, 0x5C, 0x00, 0x00, 0x00, 0x05, 0x00,
                       0x0B, 0x00, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x16,
                       0x30, 0x16, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0xd0,
                       0x8c, 0x33, 0x44, 0x22, 0xF1, 0x31, 0xAA, 0xAA,
                       0x90, 0x00, 0x38, 0x00, 0x10, 0x03, 0x01, 0x00,
                       0x00, 0x00, 0x04, 0x5D, 0x88, 0x8A, 0xEB, 0x1C,
                       0xc9, 0x11, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10,
                       0x48, 0x60, 0x02, 0x00, 0x00, 0x00);

     send(socket:soc, data:req);
     r = smb_recv(socket:soc, length:4096);
     if(strlen(r) &lt; 10){
          return(FALSE);
     }
     if(ord(r[12])==0){
         return(r);
     }
     else {
           return(FALSE);
     }
   }
 }


 function pipe_accessible_registry(soc, uid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="pipe2_accessible_registry_NTLMSSP">pipe2_accessible_registry_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function pipe2_accessible_registry_NTLMSSP(soc, uid, tid, pipe)
{
   g_mhi = multiplex_id / 256;
   g_mlo = multiplex_id % 256;

   req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }
   req += raw_string(0x00, 0x00, 0x00, 0x00,
                    g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

   #IOCTL Req

   ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                          pipe, 0x78, 0x00, 0x00, 0x00, 0x48,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
                          0x0b, 0x03, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x16,
                          0x30, 0x16, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0xd0,
                          0x8c, 0x33, 0x44, 0x22, 0xF1, 0x31, 0xAA, 0xAA,
                          0x90, 0x00, 0x38, 0x00, 0x10, 0x03, 0x01, 0x00,
                          0x00, 0x00, 0x04, 0x5D, 0x88, 0x8A, 0xEB, 0x1C,
                          0xc9, 0x11, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10,
                          0x48, 0x60, 0x02, 0x00, 0x00, 0x00);

   req = req + ioctl_req;


    if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + req ;
    }

   send(socket:soc, data:req);
   r = smb_recv(socket:soc, length:4096);

        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }

   if(strlen(r) &lt; 10){
     return(FALSE);
   }
   multiplex_id += 1;
   if(isSignActive){
     # verify signature
     seq_number += 1;

             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);

             orig_sign = substr(r, 48, 63);
             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else {
               r = r_head + r ;
             }
   }


   if(ord(r[12])==0){
        return(r);
   }
        else {
             return(FALSE);
   }
 }


function pipe2_accessible_registry(soc, uid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="pipe_accessible_registry">pipe_accessible_registry</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function pipe_accessible_registry(soc, uid, tid, pipe)
 {
   if (strlen(uid) == 8)
   {
     res = pipe2_accessible_registry(soc:soc, uid:uid, tid:tid, pipe:pipe);
     return(res);
   }
   else{
     res = pipe1_accessible_registry(soc:soc, uid:uid, tid:tid, pipe:pipe);
     return(res);
   }
 }

function pipe1_accessible_registry(soc, uid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="pipe_accessible_registry_NTLMSSP">pipe_accessible_registry_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function pipe_accessible_registry_NTLMSSP(soc, uid, tid, pipe)
 {
 	tid_low = tid % 256;
 	tid_high = tid / 256;
 	uid_low = uid % 256;
 	uid_high = uid / 256;
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
	g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;
 
	req = raw_string(0x00, 0x00,
 		 	 0x00, 0x94, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18);
	if(isSignActive){
                        req += raw_string(0x07, 0x00);
        }
        else
                req += raw_string(0x03, 0x00);
	req += raw_string(0x1b, 0x81,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_low, tid_high, 0x33, 0x0c, uid_low, uid_high,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x48, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4C,
			 0x00, 0x48, 0x00, 0x4C, 0x00, 0x02, 0x00);
	req += raw_string(0x26, 0x00,
			 pipe_low, pipe_high, 0x51, 0x00, 0x5C, 0x50, 0x49,
			 0x50, 0x45, 0x5C, 0x00, 0x00, 0x00, 0x05, 0x00,
			 0x0B, 0x00, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x16,
			 0x30, 0x16, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0xd0,
			 0x8c, 0x33, 0x44, 0x22, 0xF1, 0x31, 0xAA, 0xAA,
			 0x90, 0x00, 0x38, 0x00, 0x10, 0x03, 0x01, 0x00,
			 0x00, 0x00, 0x04, 0x5D, 0x88, 0x8A, 0xEB, 0x1C,
			 0xc9, 0x11, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10,
			 0x48, 0x60, 0x02, 0x00, 0x00, 0x00);
	if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:packet, buflen:len, seq_number:seq_number);
        }

	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
 	if(strlen(r) &lt; 10){
		return(FALSE);
	}
	multiplex_id += 1;
	if(isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(r);
          server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          orig_sign = substr(r, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
          }
        }

	if(ord(r[9])==0){
		return(r);
	}
	else {
		return(FALSE);
	}
 }

function pipe2_accessible_registry_NTLMSSP(soc, uid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_close">registry1_close</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry1_close(soc, uid, tid, pipe, reply)
{
   if(ntlmssp_flag){
     response = registry_close_NTLMSSP(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
     return(response);
   }
   else{
      local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, name, data, i, len;

      tid_low = tid % 256;
      tid_high = tid / 256;
      uid_low = uid % 256;
      uid_high = uid / 256;
      pipe_low = pipe % 256;
      pipe_high = pipe / 256;

      magic = raw_string(ord(reply[84]));
      for(i=1; i&lt;20; i=i+1){
         magic = magic + raw_string(ord(reply[84+i]));
      }

      req = raw_string(0x00, 0x00, 0x00, 0x78, 0xFF, 0x53, 0x4D,
                       0x42, 0x25, 0x00, 0x00, 0x00, 0x00, 0x08,
                       0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       tid_low, tid_high, 0x00, 0x28, uid_low,
                       uid_high, g_mlo, g_mhi, 0x10, 0x00,
                       0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x08,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x00,
                       0x2c, 0x00, 0x4c, 0x00, 0x02, 0x00, 0x26,
                       0x00, pipe_low, pipe_high, 0x35, 0x00, 0x5c,
                       0x50, 0x49, 0x50, 0x45, 0x5c, 0x00, 0x00,
                       0x00, 0x05, 0x00, 0x00, 0x03, 0x10, 0x00,
                       0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0xcf, 0x01,
                       0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x05, 0x00) + magic;

      send(socket:soc, data:req);
      r = smb_recv(socket:soc, length:65535);
      if(r){
         return substr(r, strlen(r) - 4, strlen(r) - 1);
      }
   }
 }

###SMB2 Registry close#####

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_decode_binary">registry1_decode_binary</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry1_decode_binary(data)
 {
    local_var i, o, len, index;
    len = ord(data[2])*256;
    len = len + ord(data[3]);
    if(len &lt; 130){
        return(NULL);
    }
    data_offset = ord(data[52])*256;
    data_offset = data_offset + ord(data[51]) + 4;
    data_len = ord(data[data_offset+43]);
    data_len = data_len * 256;
    data_len = data_len + ord(data[data_offset+44]);
    index = data_offset + 48;
    o = &quot;&quot;;
    for(i=0; i&lt;data_len; i=i+1){
        o = string(o, raw_string(ord(data[index+i])));
    }
    return(o);
 }

 function registry2_decode_binary(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_decode_dword">registry1_decode_dword</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry1_decode_dword(data)
{
	local_var i;
 	len = ord(data[2])*256;
	len = len + ord(data[3]);
	if(len &lt; 126)return(NULL);
 
	data_offset = ord(data[52])*256;
	data_offset = data_offset + ord(data[51]) + 4;
	data_len = ord(data[data_offset+43]);
	data_len = data_len * 256;
	data_len = data_len + ord(data[data_offset+44]);
	index = data_offset + 48;
	o = &quot;&quot;;
	for(i=data_len; i&gt;0; i=i-1)
	{
		t *= 256;
		t += ord(data[index+i-1]);
	}
	return(t);
 }

function registry2_decode_dword(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_decode_sz">registry1_decode_sz</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry1_decode_sz(data)
{
   local_var i, o, len, index;

   len = ord(data[2])*256;
   len = len + ord(data[3]);
   if(len &lt; 128){
     return(NULL);
   }

   data_offset = ord(data[52])*256;
   data_offset = data_offset + ord(data[51]) + 4;
   data_len = ord(data[data_offset+47]);
   data_len = data_len * 256 + ord(data[data_offset+46]);
   data_len = data_len * 256 + ord(data[data_offset+45]);
   data_len = data_len * 256 + ord(data[data_offset+44]);
   index = data_offset + 48;
   o = &quot;&quot;;
   data_len = data_len - 2;

   for(i=0; i&lt;data_len; i=i+2){
   o = string(o, raw_string(ord(data[index+i])));
   }
   return(o);
 }

function registry2_decode_sz(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_enum_key">registry1_enum_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry1_enum_key(soc, uid, tid, pipe, reply)
{

local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, name, data, list, i, j;
list = make_list();
tid_low = tid % 256;
tid_high = tid / 256;

uid_low = uid % 256;
uid_high = uid / 256;

pipe_low = pipe % 256;
	pipe_high = pipe / 256;
 
	magic = raw_string(ord(reply[84]));		  
	for(i=1; i&lt;20; i=i+1){
  		magic = magic + raw_string(ord(reply[84+i]));
  	}

 	for(j=0; j&gt;=0; j++)
 	{
		req = raw_string(0x00, 0x00, 0x00, 0xa8, 0xFF, 0x53, 
				 0x4D, 0x42, 0x25, 0x00, 0x00, 0x00, 0x00, 0x08);
		if(isSignActive)
                	req += raw_string(0x05, 0x40);
        	else
                	req += raw_string(0x01, 0x40);	
		req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_low, tid_high);
		if(ntlmssp_flag)
                	req += raw_string(0x33, 0x0c);
        	else
                	req += raw_string(0x00, 0x28);
		req += raw_string(uid_low, uid_high, g_mlo, g_mhi, 0x10, 0x00,
				 0x00, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x4c, 0x00, 0x5c, 0x00, 0x4c,
				 0x00, 0x02, 0x00, 0x26, 0x00, pipe_low, pipe_high, 0x65,
				 0x00, 0x5c, 0x50, 0x49, 0x50, 0x45, 0x5c, 0x00,
				 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0x10, 0x00,
				 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0xff, 0x00,
				 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x09, 0x00);

		req2= magic + raw_string(j % 256, j / 256, 0x00, 0x00,  # key ID
					 0x00, 0x00, 		    # key name len
					 0x14, 0x04,  		    # unknown
					 0x01, 0x00, 0x00, 0x00,   # ptr
					 0x0a, 0x02, 0x00, 0x00,   # unknown_2
					 0x00, 0x00, 0x00, 0x00,   # padding
					 0x00, 0x00, 0x00, 0x00,   # padding
					 0x01, 0x00, 0x00, 0x00,   # ptr2
					 0x00, 0x00, 0x00, 0x00,   # padding2
					 0x00, 0x00, 0x00, 0x00,   # padding2
					 0x01, 0x00, 0x00, 0x00,   # ptr3 
					 0xff, 0xff, 0xff, 0xff,   # smb_io_time low
					 0xff, 0xff, 0xff, 0x7f);   # smb_io_time high

	 	req += req2;
		if(ntlmssp_flag &amp;&amp; isSignActive){
                	len = strlen(req);
                	seq_number += 1;
                	packet = req;
                	req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        	}
 		send(socket:soc, data:req);
		r = smb_recv(socket:soc, length:65535);
		if(strlen(r) &lt; 80){
			return(NULL);
		}
		if(ntlmssp_flag){
                	multiplex_id += 1;
                	if(r &amp;&amp; isSignActive){
                        	# verify signature
                        	seq_number += 1;
                        	len = strlen(r);
                        	server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                        	orig_sign = substr(r, 18, 23);
                        	serv_sign = substr(server_resp, 18, 23);
                        	if(orig_sign != serv_sign){
                                	return(FALSE);
                        	}
                	}
        	}


		len = ord(r[60+24+16]);
		if(!len){
			break;
		}

		name = &quot;&quot;;
		for(i=0; i&lt;len - 1; i++){
			name += r[60+43+i*2+1];
		}
		list = make_list(list, name);
	}
	return list;

 }

 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_get_item_dword">registry1_get_item_dword</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry1_get_item_dword(soc, uid, tid, pipe, item, reply)
 {
 	local_var item_len, item_len_lo, item_len_hi, uc2, len, len_lo, len_hi, tid_low, tid_high, uid_low, uid_high;
	local_var pipe_low, pipe_high, bcc, bcc_lo, bcc_hi, y, y_lo, y_hi, z, z_lo, z_hi, req, i;
	local_var magic, x, x_lo, x_hi;
	item_len = strlen(item) + 1;
	item_len_lo = item_len % 256;
	item_len_hi = item_len / 256;
 
	uc2 = unicode2(data:item);
	len = 188 + strlen(uc2);
	len_lo = len % 256;
	len_hi = len / 256;
 
	tid_low = tid % 256;
	tid_high = tid / 256;
	uid_low = uid % 256;
	uid_high = uid / 256;
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
 
	bcc = 121 + strlen(uc2);
	bcc_lo = bcc % 256;
	bcc_hi = bcc / 256;
 
	y = 80 + strlen(uc2);
	y_lo = y % 256;
	y_hi = y / 256;
 
	z = 104 + strlen(uc2);
	z_lo = z % 256;
	z_hi = z / 256;

	req = raw_string(0x00, 0x00,
 			 len_hi, len_lo, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18);
	if(ntlmssp_flag){
                g_mhi = multiplex_id / 256;
                g_mlo = multiplex_id % 256;
                if(isSignActive)
                        req += raw_string(0x07, 0x80);
                else
                        req += raw_string(0x03, 0x80);
        }
        else{
                req += raw_string(0x03, 0x80);
        }
	req += raw_string(0x1D, 0x83,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_low, tid_high);
	if(ntlmssp_flag)
                req += raw_string(0x33, 0x0c);
        else
                req += raw_string(0x00, 0x28);

	req += raw_string(uid_low, uid_high,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, z_lo, z_hi, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, z_lo, z_hi, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_low, pipe_high, bcc_lo, bcc_hi, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, z_lo, z_hi,
			 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, y_lo, y_hi,
			 0x00, 0x00, 0x00, 0x00, 0x11, 0x00);
		  
	magic = raw_string(ord(reply[84]));
	for(i=1; i&lt;20; i=i+1){
   		magic = magic + raw_string(ord(reply[84+i]));
	}

 	x = 2 + strlen(item) + strlen(item);
	x_lo = x % 256;
	x_hi = x / 256;
  
	y = y + 3;
	y_lo = y % 256;
	y_hi = y / 256;
 
	req = req + magic +
	      raw_string(x_lo, x_hi, 0x0A, 0x02, 0x00, 0xEC,
			 0xFD, 0x7F, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, item_len_lo, item_len_hi, 0x00) + uc2 + 
	      raw_string(0x00, 0x34, 0xFF,
			 0x12, 0x00, 0xEF, 0x10, 0x40, 0x00, 0x18, 0x1E,
			 0x7c, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0xFF,
			 0x12, 0x00, 0x00, 0x04, 0x00, 0x00, 0x30, 0xFF,
			 0x12, 0x00, 0x00, 0x00, 0x00, 0x00);
		
	if(ntlmssp_flag &amp;&amp; isSignActive){
              len = strlen(req);
              seq_number += 1;
              packet = req;
              req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }

	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4000);		
	if(ntlmssp_flag){
            multiplex_id += 1;
            if(r &amp;&amp; isSignActive){
                      # verify signature
                      seq_number += 1;
                      len = strlen(r);
                      server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                      orig_sign = substr(r, 18, 23);
                      serv_sign = substr(server_resp, 18, 23);
                      if(orig_sign != serv_sign){
                              return(FALSE);
                      }
           }
        }

	return(r);
 }	  


 function registry2_get_item_dword(soc, uid, tid, pipe, item, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_get_item_sz">registry1_get_item_sz</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry1_get_item_sz(soc, uid, tid, pipe, item, reply)
 {
   local_var i;
   item_len = strlen(item) + 1;
   item_len_lo = item_len % 256;
   item_len_hi = item_len / 256;

   uc2 = unicode2(data:item);
   len = 188 + strlen(uc2);
   len_lo = len % 256;
   len_hi = len / 256;
   tid_low = tid % 256;
   tid_high = tid / 256;
   uid_low = uid % 256;
   uid_high = uid / 256;
   pipe_low = pipe % 256;
   pipe_high = pipe / 256;

   bcc = 121 + strlen(uc2);
   bcc_lo = bcc % 256;
   bcc_hi = bcc / 256;

   y = 80 + strlen(uc2);
   y_lo = y % 256;
   y_hi = y / 256;

   z = 104 + strlen(uc2);
   z_lo = z % 256;
   z_hi = z / 256;
   req = raw_string(0x00, 0x00, len_hi, len_lo, 0xFF, 0x53,
                    0x4D, 0x42, 0x25, 0x00, 0x00, 0x00, 0x00, 0x18);
   if(ntlmssp_flag){
   g_mhi = multiplex_id / 256;
   g_mlo = multiplex_id % 256;
   if(isSignActive)
     req += raw_string(0x07, 0x80);
   else
     req += raw_string(0x03, 0x80);
   }
   else{
     req += raw_string(0x03, 0x80);
   }
   req += raw_string(0x1D, 0x83, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, tid_low, tid_high);
   if(ntlmssp_flag)
     req += raw_string(0x33, 0x0c);
   else
     req += raw_string(0x00, 0x28);

  req +=  raw_string(uid_low, uid_high, g_mlo, g_mhi, 0x10, 0x00,
                     0x00, z_lo, z_hi, 0x00, 0x00, 0x00, 0x04, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x54, 0x00, z_lo, z_hi, 0x54,
                     0x00, 0x02, 0x00, 0x26, 0x00, pipe_low, pipe_high,
                     bcc_lo, bcc_hi, 0x00, 0x5C, 0x00, 0x50, 0x00, 0x49,
                     0x00, 0x50, 0x00, 0x45, 0x00, 0x5C, 0x00, 0x00, 0x00,
                     0x00, 0x5C, 0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00,
                     0x00, z_lo, z_hi, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
                     y_lo, y_hi, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00);

  if(strlen(reply) &lt; 104){
    return(FALSE);
  }
  magic = raw_string(ord(reply[84]));
  for(i=1;i&lt;20;i=i+1){
    magic = magic + raw_string(ord(reply[84+i]));
  }

  x = 2 + strlen(item) + strlen(item);
  x_lo = x % 256;
  x_hi = x / 256;

  y = y + 3;
  y_lo = y % 256;
  y_hi = y / 256;

  req = req + magic + raw_string(x_lo, x_hi, 0x0A, 0x02, 0x00, 0xEC,
                      0xFD, 0x7F, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, item_len_lo, item_len_hi, 0x00) + uc2 +
                      raw_string(0x00, 0x34, 0xFF, 0x12, 0x00, 0xEF, 0x10,
                      0x40, 0x00, 0x18, 0x1E, 0x7c, 0x00, 0x00, 0x04, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x3C, 0xFF, 0x12, 0x00, 0x00, 0x04, 0x00, 0x00, 0x30,
                      0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00);

  if(ntlmssp_flag){
    if(isSignActive){
       len = strlen(req);
       seq_number += 1;
       packet = req;
       req = get_signature(key:s_sign_key, buf:packet, buflen:len, seq_number:seq_number);
    }
  }

  send(socket:soc, data:req);
  r = smb_recv(socket:soc, length:4000);		
  if(ntlmssp_flag){
     multiplex_id += 1;
     if(isSignActive){
       # verify signature
       seq_number += 1;
       len = strlen(r);
       server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
       orig_sign = substr(r, 18, 23);
       serv_sign = substr(server_resp, 18, 23);
       if(orig_sign != serv_sign){
         return(FALSE);
       }
     }
  }

  return(r);
}

function registry2_get_item_sz(soc, uid, tid, pipe, item, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_get_key">registry1_get_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>key</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
			<dt>write</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry1_get_key(soc, uid, tid, pipe, key, reply, write)
 {
   local_var _na_start, i, error, access_mask;

   key_len = strlen(key) + 1;
   key_len_hi = key_len / 256;
   key_len_lo = key_len % 256;

   tid_low = tid % 256;
   tid_high = tid / 256;
   uid_low = uid % 256;
   uid_high = uid / 256;
   pipe_low = pipe % 256;
   pipe_high = pipe / 256;
   uc = unicode(data:key);

   if(write){
     access_mask = raw_string(0x19, 0x00, 0x02, 0x02);
   }
   else {
    access_mask = raw_string(0x19, 0x00, 0x02, 0x00);
   }

   uc += access_mask;
   len = 148 + strlen(uc);

   len_hi = len / 256;
   len_lo = len % 256;

   z = 40 + strlen(uc);
   z_lo = z % 256;
   z_hi = z / 256;

   y = 81 + strlen(uc);
   y_lo = y % 256;
   y_hi = y / 256;

   x = 64 + strlen(uc);
   x_lo = x % 256;
   x_hi = x / 256;

   if(strlen(reply) &lt; 17){
     return NULL;
   }
   magic1 = raw_string(ord(reply[16]), ord(reply[17]));

   req = raw_string(0x00, 0x00, len_hi, len_lo, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
            0x00, 0x00, 0x00, 0x18);
   if(ntlmssp_flag){
   g_mhi = multiplex_id / 256;
   g_mlo = multiplex_id % 256;
   if(isSignActive)
     req += raw_string(0x07, 0x80);
   else
     req += raw_string(0x03, 0x80);
   }
   else
     req += raw_string(0x03, 0x80);
     req += magic1 + raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00,tid_low, tid_high);
    if(ntlmssp_flag)
    req+= raw_string(0x33, 0x0c);
    else
     req+= raw_string(0x00, 0x28);
     req += raw_string(uid_low, uid_high,
 g_mlo, g_mhi, 0x10, 0x00, 0x00, x_lo, x_hi, 0x00,
 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
0x00, x_lo, x_hi, 0x54, 0x00, 0x02, 0x00, 0x26,
 0x00, pipe_low, pipe_high, y_lo, y_hi, 0x00, 0x5C, 0x00,
0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
0x5C, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x05, 0x00,
0x00, 0x03, 0x10, 0x00, 0x00, 0x00, x_lo, x_hi,
0x00, 0x00, 0x02, 0x00, 0x00, 0x00, z_lo, z_hi,
0x00, 0x00, 0x00, 0x00, 0x0F, 0x00);

magic = raw_string(ord(reply[84]));
for(i=1; i&lt;20; i=i+1){
  magic = magic + raw_string(ord(reply[84+i]));
}
x = strlen(key) + strlen(key) + 2;
x_lo = x % 256;
x_hi = x / 256;

req = req + magic +
      raw_string(x_lo, x_hi, 0x0A, 0x02, 0x00, 0xEC,
  0xFD, 0x7F, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, key_len_lo, key_len_hi, 0x00, 0x00) + uc;

if(ntlmssp_flag){
if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:packet, buflen:len, seq_number:seq_number);
        }
}

send(socket:soc, data:req);
r = smb_recv(socket:soc, length:4096);
if(strlen(r) &lt; 10){
return(FALSE);
}
if(ntlmssp_flag){
multiplex_id += 1;
        if(isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(r);
          server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          orig_sign = substr(r, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
          }
        }
}

len = ord(r[2])*256;
len = len + ord(r[3]);
if(len &lt; 100){
return(FALSE);
}

# pull the last 4 bytes off the end
_na_start = (strlen(r) - 4);
for (_na_cnt = 0; _na_cnt &lt; 4; _na_cnt++){
_na_data = _na_data + r[_na_start + _na_cnt];
}

# access denied, returned by Windows XP+
if(_na_data == raw_string(0x05,0x00,0x00,0x00) ||
   _na_data == raw_string(0x02, 0x00, 0x00, 0x00)){
return(FALSE);
}

if(ord(r[9])==0){
return(r);
}
else {
return(FALSE);
}
 }


##########SMB2 Registry get key################

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_get_key_security">registry1_get_key_security</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry1_get_key_security(soc, uid, tid, pipe, reply)
{
 	local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high;
 
	tid_low = tid % 256;
	tid_high = tid / 256;
 
	uid_low = uid % 256;
	uid_high = uid / 256;
 
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
 
	req = raw_string(0x00, 0x00,
 			 0x00, 0x90, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18);
	if(ntlmssp_flag){
                g_mhi = multiplex_id / 256;
                g_mlo = multiplex_id % 256;
                if(isSignActive)
                        req += raw_string(0x07, 0x80);
                else
                        req += raw_string(0x03, 0x80);
        }
        else{
                req += raw_string(0x03, 0x80);
        }
	req += raw_string(0x00, 0x83,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_low, tid_high);
	if(ntlmssp_flag)
        	req += raw_string(0x33, 0x0c);
        else
                req += raw_string(0x00, 0x28);
	req += raw_string(uid_low, uid_high,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x3C, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x3C, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_low, pipe_high, 0x4D, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0xEE, 0xD5, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x3C, 0x00,
			 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x24, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00);

	if(strlen(reply) &lt; 104){
		return(FALSE);
	}
 
	magic = raw_string(ord(reply[84]));		  
	for(i=1;i&lt;20;i=i+1){
		magic = magic + raw_string(ord(reply[84+i]));
	}
 
	req = req + magic + raw_string(0x04) + crap(data:raw_string(0), length:15);
 
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:65535);
 
	len1 =  ord(r[strlen(r) - 16]);
	len2 = ord(r[strlen(r) - 15]);
	len3 = ord(r[strlen(r) - 14]);
	len4 = ord(r[strlen(r) - 13]);
	req = raw_string(0x00, 0x00,
 			 0x00, 0x9C, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x03, 0x80, 0x00, 0x83,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x48, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x48, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_low, pipe_high, 0x59, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0xEE, 0xD5, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00,
			 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x30, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00);
		  
 	req = req + magic +
	      raw_string(0x04, 0x00, 0x00, 0x00, 0x38, 0x8d,
			 0x07, 0x00, len1, len2, len3, len4, 0x00, 0x00,
			 0x00, 0x00, len1, len2, len3, len4, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
	if(ntlmssp_flag &amp;&amp; isSignActive){
              len = strlen(req);
              seq_number += 1;
              packet = req;
              req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:65535);
	if(strlen(r) &lt; 150){
		return(NULL);
	}
	if(ntlmssp_flag){
                multiplex_id += 1;
                if(r &amp;&amp; isSignActive){
                      # verify signature
                      seq_number += 1;
                      len = strlen(r);
                      server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                      orig_sign = substr(r, 18, 23);
                      serv_sign = substr(server_resp, 18, 23);
                      if(orig_sign != serv_sign){
                              return(FALSE);
                      }
                }
        }

	return(r);
 }

 function registry2_get_key_security(soc, uid, tid, pipe, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry1_open_hklm">registry1_open_hklm</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry1_open_hklm(soc, uid, tid, pipe)
{
   if(ntlmssp_flag)
   {
        response = registry_open_hklm_NTLMSSP(soc:soc, uid:uid, tid:tid, pipe:pipe);
        return(response);
   }

        local_var req, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, r;

        tid_low = tid % 256;
        tid_high = tid / 256;
        uid_low = uid % 256;
        uid_high = uid / 256;
        pipe_low = pipe % 256;
        pipe_high = pipe / 256;

        req = raw_string(0x00, 0x00,
                         0x00, 0x78, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
                         0x00, 0x00, 0x00, 0x18, 0x03, 0x80, 0x1D, 0x83,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
                         g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x24, 0x00, 0x00,
                         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
                         0x00, 0x24, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
                         0x00, pipe_low, pipe_high, 0x35, 0x00, 0x00, 0x5c, 0x00,
                         0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
                         0x5C, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x05, 0x00,
                         0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
                         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0xFF,
                         0x12, 0x00, 0x30, 0x39, 0x01, 0x00, 0x00, 0x00,
                         0x00, 0x02);

        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4096);
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
        if(ord(r[9])==0){
                return(r);
        }
        else {
                return(FALSE);
        }
 }

function registry2_open_hklm(soc, ssid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_close">registry2_close</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_close(soc, uid, tid, pipe, reply)
 {
   if(ntlmssp_flag){
     response = registry2_close_NTLMSSP(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
     return(response);
   }
   else{
      local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, name, data, i, len;

      magic = raw_string(ord(reply[84]));
      for(i=1; i&lt;20; i=i+1){
         magic = magic + raw_string(ord(reply[84+i]));
      }

      req = raw_string(0x00, 0x00, 0x00, 0x78, 0xFF, 0x53, 0x4D,
                       0x42, 0x25, 0x00, 0x00, 0x00, 0x00, 0x08,
                       0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       tid_low, tid_high, 0x00, 0x28, uid_low,
                       uid_high, g_mlo, g_mhi, 0x10, 0x00,
                       0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x08,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x00,
                       0x2c, 0x00, 0x4c, 0x00, 0x02, 0x00, 0x26,
                       0x00, pipe_low, pipe_high, 0x35, 0x00, 0x5c,
                       0x50, 0x49, 0x50, 0x45, 0x5c, 0x00, 0x00,
                       0x00, 0x05, 0x00, 0x00, 0x03, 0x10, 0x00,
                       0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0xcf, 0x01,
                       0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x05, 0x00) + magic;
      send(socket:soc, data:req);
      r = smb_recv(socket:soc, length:65535);
      if(r){
         return substr(r, strlen(r) - 4, strlen(r) - 1);
      }
   }
 }



 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_close_NTLMSSP">registry2_close_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_close_NTLMSSP(soc, uid, tid, pipe, reply)
{
   local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, name, data, i, len;

   g_mhi = multiplex_id / 256;
   g_mlo = multiplex_id % 256;

        req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

        if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
        }
        else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
        }

                 req += raw_string(0x00, 0x00, 0x00, 0x00,
                         g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

        # Ioctl Req
        ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                              pipe, 0x78, 0x00, 0x00, 0x00);

        # Distributed Computing Environment / Remote Procedure Calls
        dcerpc_req1 = raw_string(0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00);
        dcerpc_req2 = raw_string(0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x34, 0x00,
                                 0x00, 0x00, 0x00, 0x00, 0x05, 0x00);

          if(strlen(reply) &gt; 140){ 
            magic = raw_string(ord(reply[140]));
            for(i=1; i&lt;20; i=i+1){
               magic = magic + raw_string(ord(reply[140+i]));
           }
         }

        x = strlen(key) + strlen(key) + 2;
        x_lo = x % 256;
        x_hi = x / 256;

        # Remote Registry Service Req
        rrs_req = magic ;

        len_rrs = strlen(rrs_req) + strlen(dcerpc_req1) + strlen(dcerpc_req2) + 2;
        len_rrs_lo = len_rrs % 256;
        len_rrs_hi = len_rrs / 256;

        dcerpc_req = dcerpc_req1 + raw_string(len_rrs_lo, len_rrs_hi) + dcerpc_req2;

        ioctl_req += raw_string(len_rrs_lo, len_rrs_hi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00);

        req = req + ioctl_req + dcerpc_req + rrs_req;
        req_l = strlen(req);
        len_lo =  req_l % 256;
        len_hi = req_l / 256;

        if(isSignActive)
        {
           sig = get_smb2_signature(buf:req, key: sign_key);
           req = raw_string(0x00, 0x00, len_hi, len_lo) + sig;
        }
        else{
           req = raw_string(0x00, 0x00, len_hi, len_lo) + req;
        }

        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:65535);
        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }

        multiplex_id += 1;
        if(r &amp;&amp; isSignActive){
             # verify signature
             seq_number += 1;

             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);

             orig_sign = substr(r, 48, 63);
             

             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else {
               r = r_head + r ;
             }
         }

        if(r){
                return(substr(r, strlen(r) - 4, strlen(r) - 1));
        }
 }


 function registry_close(soc, uid, tid, pipe, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_decode_binary">registry2_decode_binary</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry2_decode_binary(data)
{

    local_var i, o, len, index;
    local_var i, o, len, index;
    len = ord(data[2])*256;
    len = len + ord(data[3]);
    if(len &lt; 181){
        return(NULL);
    }

   data_offset = ord(data[101])*256;
   data_offset = data_offset + ord(data[100]) + 4;
   data_len = ord(data[data_offset+47]);
   data_len = data_len * 256 + ord(data[data_offset+46]);
   data_len = data_len * 256 + ord(data[data_offset+45]);
   data_len = data_len * 256 + ord(data[data_offset+44]);
   index = data_offset + 48;
   o = &quot;&quot;;

   for(i=0; i&lt;data_len; i=i+1){
   o = string(o, raw_string(ord(data[index+i])));
   }

   return(o);

}

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_decode_dword">registry2_decode_dword</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_decode_dword(data)
{
  local_var i;
  len = ord(data[2])*256;
  len = len + ord(data[3]);
  if(len &lt; 126)return(NULL);
  data_offset = ord(data[103])*256;
  data_offset = data_offset + ord(data[102])*256;
  data_offset = data_offset + ord(data[101])*256;
  data_offset = data_offset + ord(data[100]) + 4;

  data_len = ord(data[data_offset+43]);
  data_len = data_len * 256;
  data_len = data_len + ord(data[data_offset+44]);

  index = data_offset + 48;
  o = &quot;&quot;;
  for(i=data_len; i&gt;0; i=i-1)
  {
    t *= 256;
    t += ord(data[index+i-1]);
  }
  return(t);
}
 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_decode_sz">registry2_decode_sz</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_decode_sz(data)
 {
   local_var i, o, len, index;

   len = ord(data[2])*256;
   len = len + ord(data[3]);
   if(len &lt; 128){
     return(NULL);
   }

   data_offset = ord(data[101])*256;
   data_offset = data_offset + ord(data[100]) + 4;
   data_len = ord(data[data_offset+47]);
   data_len = data_len * 256 + ord(data[data_offset+46]);
   data_len = data_len * 256 + ord(data[data_offset+45]);
   data_len = data_len * 256 + ord(data[data_offset+44]);
   index = data_offset + 48;
   o = &quot;&quot;;
   data_len = data_len - 2;

   for(i=0; i&lt;data_len; i=i+2){
   o = string(o, raw_string(ord(data[index+i])));
   }

   return(o);
 }



 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_enum_key">registry2_enum_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_enum_key(soc, uid, tid, pipe, reply)
{
  local_var req, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, r;
  list = make_list();
  magic = raw_string(ord(reply[140]));
  for(i=1; i&lt;20; i=i+1){
      magic = magic + raw_string(ord(reply[140+i]));
  }


  for(j=0; j&gt;=0; j++)
  {
    g_mhi = multiplex_id / 256;
    g_mlo = multiplex_id % 256;

    req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }


   req += raw_string(0x00, 0x00, 0x00, 0x00,
                     g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    # Ioctl Req
    ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                         pipe, 0x78, 0x00, 0x00, 0x00);

    # Distributed Computing Environment / Remote Procedure Calls
    dcerpc_req1 = raw_string(0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00);
    dcerpc_req2 = raw_string(0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                           0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00);


    x = strlen(key) + strlen(key) + 2;
    x_lo = x % 256;
    x_hi = x / 256;

    # Remote Registry Service Req
    rrs_req = magic + raw_string(j % 256, j / 256, 0x00, 0x00,  # key ID
                                  0x00, 0x00,     # key name len
                                  0x14, 0x04,      # unknown
                                  0x01, 0x00, 0x00, 0x00,   # ptr
                                  0x0a, 0x02, 0x00, 0x00,   # unknown_2
                                  0x00, 0x00, 0x00, 0x00,   # padding
                                  0x00, 0x00, 0x00, 0x00,   # padding
                                  0x01, 0x00, 0x00, 0x00,   # ptr2
                                  0x00, 0x00, 0x00, 0x00,   # padding2
                                  0x00, 0x00, 0x00, 0x00,   # padding2
                                  0x01, 0x00, 0x00, 0x00,   # ptr3
                                  0xff, 0xff, 0xff, 0xff,   # smb_io_time low
                                  0xff, 0xff, 0xff, 0x7f);   # smb_io_time high


    len_rrs = strlen(rrs_req) + strlen(dcerpc_req1) + strlen(dcerpc_req2) + 2;
    len_rrs_lo = len_rrs % 256;
    len_rrs_hi = len_rrs / 256;

    dcerpc_req = dcerpc_req1 + raw_string(len_rrs_lo, len_rrs_hi) + dcerpc_req2;

    ioctl_req += raw_string(len_rrs_lo, len_rrs_hi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00);

    req = req + ioctl_req + dcerpc_req + rrs_req;
    req_l = strlen(req);
    len_lo =  req_l % 256;
    len_hi = req_l / 256;

    if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, len_hi, len_lo) + sig;

    }
    else{
         req = raw_string(0x00, 0x00, len_hi, len_lo) + req;
    }

    send(socket:soc, data:req);

    r = smb_recv(socket:soc, length:4096);

   ##If status is pending
    ##if status is pending , wait for response
    status = ord(r[12]);
    status2 = ord(r[13]);      
    while(status == 3 &amp;&amp; status2 == 1)
    {
      ##PDU will arrive late
      r = smb_recv(socket:soc, length:4096);
      status = ord(r[12]);
      status2 = ord(r[13]);    
    }

    if(strlen(r) &lt; 80)
    {
      return(NULL);
    }
    multiplex_id += 1;
    if(isSignActive){
             # verify signature
             seq_number += 1;
             
             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);

             orig_sign = substr(r, 48, 63);
             

             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else {
               r = r_head + r;
             }
    }

    len = ord(r[156]);
    if(!len){
     break;
    }

    name = &quot;&quot;;
    for(i=0; i&lt;len - 1; i++){
      name += r[159+i*2+1];
    }
    list = make_list(list, name);
  }
  return list;
}


function registry1_enum_key(soc, uid, tid, pipe, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_get_item_dword">registry2_get_item_dword</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry2_get_item_dword(soc, uid, tid, pipe, item, reply)
 {
    g_mhi = multiplex_id / 256;
    g_mlo = multiplex_id % 256;
    item_len = strlen(item) + 1;
    item_len_lo = item_len % 256;
    item_len_hi = item_len / 256;
    uc2 = unicode2(data:item);

    req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }
    req += raw_string(0x00, 0x00, 0x00, 0x00,
                     g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    # Ioctl Req
    ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                         pipe, 0x78, 0x00, 0x00, 0x00);

    # Distributed Computing Environment / Remote Procedure Calls
    dcerpc_req1 = raw_string(0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00);
    dcerpc_req2 = raw_string(0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                           0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00);

    magic = raw_string(ord(reply[140]));
    for(i=1; i&lt;20; i=i+1){
      magic = magic + raw_string(ord(reply[140+i]));
    }

    x = 2 + strlen(item) + strlen(item);
    x_lo = x % 256;
    x_hi = x / 256;

    # Remote Registry Service Req
    rrs_req =  magic + raw_string(x_lo, x_hi, 0x0A, 0x02, 0x00, 0xEC,
                               0xFD, 0x7F, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
                               0x00, 0x00, item_len_lo, item_len_hi, 0x00) + uc2
               + raw_string(0x00, 0x34, 0xFF, 0x12, 0x00, 0xEF, 0x10, 0x40, 0x00, 0x18, 0x1E,
                            0x7c, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0xFF,
                            0x12, 0x00, 0x00, 0x04, 0x00, 0x00, 0x30, 0xFF,
                            0x12, 0x00, 0x00, 0x00, 0x00, 0x00);


    len_rrs = strlen(rrs_req) + strlen(dcerpc_req1) + strlen(dcerpc_req2) + 2;
    len_rrs_lo = len_rrs % 256;
    len_rrs_hi = len_rrs / 256;

    dcerpc_req = dcerpc_req1 + raw_string(len_rrs_lo, len_rrs_hi) + dcerpc_req2;

    ioctl_req += raw_string(len_rrs_lo, len_rrs_hi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00);

    req = req + ioctl_req + dcerpc_req + rrs_req;
    req_l = strlen(req);
    len_lo =  req_l % 256;
    len_hi = req_l / 256;

   if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, len_hi, len_lo) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, len_hi, len_lo) + req ;
    }

    send(socket:soc, data:req);

    r = smb_recv(socket:soc, length:4096);
        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }

    if(strlen(r) &lt; 80){
      return(FALSE);
    }
    multiplex_id += 1;
    if(isSignActive){
      # verify signature
      seq_number += 1;

             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);
             orig_sign = substr(r, 48, 63);
             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else {
               r = r_head + r;
             }
      }

  return (r);
}


 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_get_item_sz">registry2_get_item_sz</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_get_item_sz(soc, uid, tid, pipe, item, reply)
{
  local_var i;
  item_len = strlen(item) + 1;
  item_len_lo = item_len % 256;
  item_len_hi = item_len / 256;
  uc2 = unicode2(data:item);
  len = 188 + strlen(uc2);
  len_lo = len % 256;
  len_hi = len / 256;

  bcc = 121 + strlen(uc2);
  bcc_lo = bcc % 256;
  bcc_hi = bcc / 256;

  y = 80 + strlen(uc2);
  y_lo = y % 256;
  y_hi = y / 256;

  z = 104 + strlen(uc2);
  z_lo = z % 256;
  z_hi = z / 256;

  g_mhi = multiplex_id / 256;
  g_mlo = multiplex_id % 256;

  # SMB2 Header
  req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }
   req += raw_string(0x00, 0x00, 0x00, 0x00,
                   g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

  if(ntlmssp_flag){
    g_mhi = multiplex_id / 256;
    g_mlo = multiplex_id % 256;
  }

  # Ioctl Req
  ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                         pipe, 0x78, 0x00, 0x00, 0x00);

  # Distributed Computing Environment / Remote Procedure Calls
#  dcerpc_req = raw_string(0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00,
 #                         0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  #                        0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00);

  dcerpc_req1 = raw_string(0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00);
  dcerpc_req2 = raw_string(0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x34, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x11, 0x00);

  magic = raw_string(ord(reply[140]));
  for(i=1; i&lt;20; i=i+1){
      magic = magic + raw_string(ord(reply[140+i]));
  }

  x = strlen(item) + strlen(item) + 2;
  x_lo = x % 256;
  x_hi = x / 256;

  # Remote Registry Service Req
  rrs_req = magic + raw_string(x_lo, x_hi, 0x0A, 0x02, 0x00, 0xEC,
                               0xFD, 0x7F, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
                               0x00, 0x00, item_len_lo, item_len_hi, 0x00) + uc2
                  + raw_string(0x00, 0x34, 0xFF, 0x12, 0x00, 0xEF, 0x10,
                      0x40, 0x00, 0x18, 0x1E, 0x7c, 0x00, 0x00, 0x04, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x3C, 0xFF, 0x12, 0x00, 0x00, 0x04, 0x00, 0x00, 0x30,
                      0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00);

  len_rrs = strlen(rrs_req) + strlen(dcerpc_req1) + strlen(dcerpc_req2) + 2;
  len_rrs_lo = len_rrs % 256;
  len_rrs_hi = len_rrs / 256;

  dcerpc_req = dcerpc_req1 + raw_string(len_rrs_lo, len_rrs_hi) + dcerpc_req2;

  ioctl_req += raw_string(len_rrs_lo, len_rrs_hi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00);

  req = req + ioctl_req + dcerpc_req + rrs_req;
  req_l = strlen(req);
  len_lo =  req_l % 256;
  len_hi = req_l / 256;

  if(isSignActive){
       sig = get_smb2_signature(buf:req, key: sign_key);
       req = raw_string(0x00, 0x00, len_hi, len_lo) + sig;
   }else {
       req = raw_string(0x00, 0x00, len_hi, len_lo) + req;

   }

  send(socket:soc, data:req);
  r = smb_recv(socket:soc, length:4000);
        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }

  if(ntlmssp_flag)
  {
     multiplex_id += 1;
     if(isSignActive){
       # verify signature
             seq_number += 1;
             
             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);

             orig_sign = substr(r, 48, 63);
             

             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else{
               r = r_head + r;
             }
      }
  }
return(r);
}


 function registry1_decode_binary(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_get_key">registry2_get_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>key</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
			<dt>write</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_get_key(soc, uid, tid, pipe, key, reply, write)
{
  local_var _na_start, i, error, access_mask;

  key_len = strlen(key) + 1;
  key_len_hi = key_len / 256;
  key_len_lo = key_len % 256;

  g_mhi = multiplex_id / 256;
  g_mlo = multiplex_id % 256;


  uc = unicode(data:key);

  if(write){
    access_mask = raw_string(0x19, 0x00, 0x02, 0x02);
  }
  else {
    access_mask = raw_string(0x19, 0x00, 0x02, 0x00);
  }

  uc += access_mask;

  if(strlen(reply) &lt; 17){
    return NULL;
  }

# SMB2 Header
  req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }


   req += raw_string(0x00, 0x00, 0x00, 0x00,
                         g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
# Ioctl Req
  ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                         pipe, 0x78, 0x00, 0x00, 0x00);

# Distributed Computing Environment / Remote Procedure Calls
  dcerpc_req1 = raw_string(0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00);
  dcerpc_req2 = raw_string(0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                           0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00);

  magic = raw_string(ord(reply[140]));
  for(i=1; i&lt;20; i=i+1){
      magic = magic + raw_string(ord(reply[140+i]));
  }

  x = strlen(key) + strlen(key) + 2;
  x_lo = x % 256;
  x_hi = x / 256;

# Remote Registry Service Req
  rrs_req = magic + raw_string(x_lo, x_hi, 0x0A, 0x02, 0x00, 0xEC,
                               0xFD, 0x7F, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
                               0x00, 0x00, key_len_lo, key_len_hi, 0x00, 0x00) + uc;

  len_rrs = strlen(rrs_req) + strlen(dcerpc_req1) + strlen(dcerpc_req2) + 2;
  len_rrs_lo = len_rrs % 256;
  len_rrs_hi = len_rrs / 256;

  dcerpc_req = dcerpc_req1 + raw_string(len_rrs_lo, len_rrs_hi) + dcerpc_req2;

  ioctl_req += raw_string(len_rrs_lo, len_rrs_hi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00);

  req = req + ioctl_req + dcerpc_req + rrs_req;
  req_l = strlen(req);
  len_lo =  req_l % 256;
  len_hi = req_l / 256;

   if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, len_hi, len_lo) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, len_hi, len_lo) + req ;
    }

  send(socket:soc, data:req);

  r = smb_recv(socket:soc, length:4096);

   ##If status is pending
    ##if status is pending , wait for response
    status = ord(r[12]);
    status2 = ord(r[13]);
    while(status == 3 &amp;&amp; status2 == 1)
    {
      ##PDU will arrive late
      r = smb_recv(socket:soc, length:4096);
      status = ord(r[12]);
      status2 = ord(r[13]);
    }

  if(strlen(r) &lt; 10){
     return(FALSE);
  }
  if(ntlmssp_flag){
    multiplex_id += 1;
    if(isSignActive){
              # verify signature
              seq_number += 1;
             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);

             orig_sign = substr(r, 48, 63);
             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else{
               r = r_head + r;
             }
   }
}

  len = ord(r[2])*256;
  len = len + ord(r[3]);
  if(len &lt; 100){
   return(FALSE);
  }

  # pull the last 4 bytes off the end
  _na_start = (strlen(r) - 4);
  for (_na_cnt = 0; _na_cnt &lt; 4; _na_cnt++){
  _na_data = _na_data + r[_na_start + _na_cnt];
  }

  # access denied, returned by Windows XP+
  if(_na_data == raw_string(0x05,0x00,0x00,0x00) ||
     _na_data == raw_string(0x02, 0x00, 0x00, 0x00)){
   return(FALSE);
  }
  ## 8 + BIOS-4bytes  
  if(ord(r[12])==0){
    return(r);
  }
  else {
   return(FALSE);
  }
}

 #------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_get_key_security">registry2_get_key_security</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry2_get_key_security(soc, uid, tid, pipe, reply)
 {
   local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high;

   g_mhi = multiplex_id / 256;
   g_mlo = multiplex_id % 256;

  req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }
  req += raw_string(0x00, 0x00, 0x00, 0x00,
                   g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

# Ioctl Req
  ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                         pipe, 0x78, 0x00, 0x00, 0x00);

# Distributed Computing Environment / Remote Procedure Calls
 dcerpc_req1 = raw_string(0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00);
 dcerpc_req2 = raw_string(0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x34, 0x00,
                                 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00);


  magic = raw_string(ord(reply[140]));
  for(i=1; i&lt;20; i=i+1){
      magic = magic + raw_string(ord(reply[140+i]));
  }

  x = strlen(key) + strlen(key) + 2;
  x_lo = x % 256;
  x_hi = x / 256;

# Remote Registry Service Req
  rrs_req = magic + raw_string(0x04) + crap(data:raw_string(0), length:15);

  len_rrs = strlen(rrs_req) + strlen(dcerpc_req1) + strlen(dcerpc_req2) + 2;
  len_rrs_lo = len_rrs % 256;
  len_rrs_hi = len_rrs / 256;

  dcerpc_req = dcerpc_req1 + raw_string(len_rrs_lo, len_rrs_hi) + dcerpc_req2;

  ioctl_req += raw_string(len_rrs_lo, len_rrs_hi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00);

  req = req + ioctl_req + dcerpc_req + rrs_req;
  req_l = strlen(req);
  len_lo =  req_l % 256;
  len_hi = req_l / 256;

   if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, len_hi, len_lo) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, len_hi, len_lo) + req ;
    }

  send(socket:soc, data:req);
  r = smb_recv(socket:soc, length:65535);
        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }


  multiplex_id = multiplex_id + 1;
  g_mhi = multiplex_id / 256;
  g_mlo = multiplex_id % 256;

 len1 =  ord(r[strlen(r) - 16]);
 len2 = ord(r[strlen(r) - 15]);
 len3 = ord(r[strlen(r) - 14]);
 len4 = ord(r[strlen(r) - 13]);

  req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }


   req += raw_string(0x00, 0x00, 0x00, 0x00,
                   g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

# Ioctl Req
  ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                         pipe, 0x78, 0x00, 0x00, 0x00);

# Distributed Computing Environment / Remote Procedure Calls
 dcerpc_req1 = raw_string(0x05, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00);
 dcerpc_req2 = raw_string(0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x34, 0x00,
                                 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00);


  magic = raw_string(ord(reply[140]));
  for(i=1; i&lt;20; i=i+1){
      magic = magic + raw_string(ord(reply[140+i]));
  }

  x = strlen(key) + strlen(key) + 2;
  x_lo = x % 256;
  x_hi = x / 256;

# Remote Registry Service Req
  rrs_req = magic + raw_string(0x04, 0x00, 0x00, 0x00, 0x38, 0x8d, 0x07, 0x00,
            len1, len2, len3, len4, 0x00, 0x00, 0x00, 0x00, len1, len2, len3,
            len4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

  len_rrs = strlen(rrs_req) + strlen(dcerpc_req1) + strlen(dcerpc_req2) + 2;
  len_rrs_lo = len_rrs % 256;
  len_rrs_hi = len_rrs / 256;

  dcerpc_req = dcerpc_req1 + raw_string(len_rrs_lo, len_rrs_hi) + dcerpc_req2;

  ioctl_req += raw_string(len_rrs_lo, len_rrs_hi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00);

  req = req + ioctl_req + dcerpc_req + rrs_req;
  req_l = strlen(req);
  len_lo =  req_l % 256;
  len_hi = req_l / 256;

   if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, len_hi, len_lo) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, len_hi, len_lo) + req ;
    }

  send(socket:soc, data:req);

 r = smb_recv(socket:soc, length:65535);
        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }


 if(strlen(r) &lt; 150){
  return(NULL);
 }
 if(ntlmssp_flag){
          multiplex_id += 1;
          if(r &amp;&amp; isSignActive){
               # verify signature
               seq_number += 1;
             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);

             orig_sign = substr(r, 48, 63);

             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else {
               r = r_head + r ;
             }
        }
    }
 return(r);
 }





 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_open_hklm">registry2_open_hklm</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>ssid</dt>
			
		
			<dt>tid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_open_hklm(soc, ssid, tid, pipe)
 {
   if(ntlmssp_flag)
   {
        response = registry2_open_hklm_NTLMSSP(soc:soc, uid:uid, tid:tid, pipe:pipe);
        return(response);
   }
   else
   {

      local_var req, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, r;
        tid_low = tid % 256;
        tid_high = tid / 256;
        uid_low = uid % 256;
        uid_high = uid / 256;
        pipe_low = pipe % 256;
        pipe_high = pipe / 256;
        req = raw_string(0x00, 0x00,
                         0x00, 0x78, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
                         0x00, 0x00, 0x00, 0x18, 0x03, 0x80, 0x1D, 0x83,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
                         g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x24, 0x00, 0x00,
                         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
                         0x00, 0x24, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
                         0x00, pipe_low, pipe_high, 0x35, 0x00, 0x00, 0x5c, 0x00,
                         0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
                         0x5C, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x05, 0x00,
                         0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
                         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0xFF,
                         0x12, 0x00, 0x30, 0x39, 0x01, 0x00, 0x00, 0x00,
                         0x00, 0x02);

        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4096);
        if(strlen(r) &lt; 10){
           return(FALSE);
        }
        if(ord(r[9])==0){
                return(r);
        }
        else {
                return(FALSE);
        }
  }
 }


 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry2_open_hklm_NTLMSSP">registry2_open_hklm_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry2_open_hklm_NTLMSSP(soc, uid, tid, pipe)
{
  local_var req, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, r;

  g_mhi = multiplex_id / 256;
  g_mlo = multiplex_id % 256;

  req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }


  req += raw_string(0x00, 0x00, 0x00, 0x00,
                   g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

  ioctl_req = raw_string(0x39, 0x00, 0x00, 0x00, 0x17, 0xc0, 0x11, 0x00,
                         pipe, 0x78, 0x00, 0x00, 0x00, 0x24,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
                         0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
                         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x34, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0xFF,
                         0x12, 0x00, 0x30, 0x39, 0x01, 0x00, 0x00, 0x00,
                         0x00, 0x02);

  req = req + ioctl_req;

    if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + req ;
    }

  send(socket:soc, data:req);

  r = smb_recv(socket:soc, length:4096);

        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }

  if(strlen(r) &lt; 10){
    return(FALSE);
  }
  multiplex_id += 1;
  if(isSignActive){

              seq_number += 1;
             r_head = substr(r, 0, 3);
             r = substr(r, 4, strlen(r)-1);
             orig_sign = substr(r, 48, 63);
             server_resp = get_smb2_signature(buf:r, key: sign_key);
             serv_sign = substr(server_resp, 48, 63);
             
             if(orig_sign != serv_sign){
              return(FALSE);
             }
             else {
              r = r_head + r;
             }
   }


   if(ord(r[12])==0){
             return(r);
   }
        else {
             return(FALSE);
   }
 }

 function registry_open_hklm(soc, uid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_close">registry_close</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_close(soc, uid, tid, pipe, reply)
 {
   if (strlen(uid) == 8)
   {
     res = registry2_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
     return(res);
   }
   else{
     res = registry1_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
     return(res);
   }
 }

function registry1_close(soc, uid, tid, pipe, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_close_NTLMSSP">registry_close_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_close_NTLMSSP(soc, uid, tid, pipe, reply)
 {
        local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, name, data, i, len;

        tid_low = tid % 256;
        tid_high = tid / 256;

        uid_low = uid % 256;
        uid_high = uid / 256;

        pipe_low = pipe % 256;
        pipe_high = pipe / 256;

        g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        magic = raw_string(ord(reply[84]));
        for(i=1; i&lt;20; i=i+1){
                magic = magic + raw_string(ord(reply[84+i]));
        }

        req = raw_string(0x00, 0x00, 0x00, 0x78, 0xFF, 0x53,
                         0x4D, 0x42, 0x25, 0x00, 0x00, 0x00, 0x00, 0x08);
        if(isSignActive)
        req += raw_string(0x05, 0x40);
        else
        req += raw_string(0x01, 0x40);
        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_low, tid_high,
                          0x33, 0x0c, uid_low, uid_high, g_mlo, g_mhi, 0x10, 0x00,
                          0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x4c, 0x00, 0x2c, 0x00, 0x4c,
                          0x00, 0x02, 0x00, 0x26, 0x00, pipe_low, pipe_high, 0x35,
                          0x00, 0x5c, 0x50, 0x49, 0x50, 0x45, 0x5c, 0x00,
                          0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0x10, 0x00,
                          0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0xcf, 0x01,
                          0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x05, 0x00) + magic;
        if(isSignActive){
           len = strlen(req);
           seq_number += 1;
           packet = req;
           req = get_signature(key:s_sign_key, buf:packet, buflen:len, seq_number:seq_number);
        }

        send(socket:soc, data:req);

        r = smb_recv(socket:soc, length:65535);

        multiplex_id += 1;
        if(r &amp;&amp; isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(r);
          server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          orig_sign = substr(r, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
          }
        }

        if(r){
                return(substr(r, strlen(r) - 4, strlen(r) - 1));
        }
 }

function registry2_close_NTLMSSP(soc, uid, tid, pipe, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_decode_binary">registry_decode_binary</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_decode_binary(data)
 {

   if (strlen(uid) == 8)
   {
     res = registry2_decode_binary(data:data);
     return(res);
   }
   else{
     res = registry1_decode_binary(data:data);
     return(res);
   }
 }

 function registry_decode_sz(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_decode_dword">registry_decode_dword</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_decode_dword(data)
 {
   if(ord(data[4]) == 254)
   {
    value =  registry2_decode_dword(data:data);
    return(value);
   }
   else{
    value = registry1_decode_dword(data:data);
    return(value);
   }
 }

function registry1_decode_dword(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_decode_sz">registry_decode_sz</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_decode_sz(data)
 {
   if (strlen(uid) == 8)
   {
     res = registry2_decode_sz(data:data);
     return(res);
   }
   else{
     res = registry1_decode_sz(data:data);
     return(res);
   }
 }

function registry1_decode_sz(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_delete_key">registry_delete_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>key</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_delete_key(soc, uid, tid, pipe, key, reply )
 {
 	local_var _na_start, i, error;

	key_len = strlen(key) + 1;
	key_len_hi = key_len / 256;
	key_len_lo = key_len % 256;
 
	tid_low = tid % 256;
	tid_high = tid / 256;
	uid_low = uid % 256;
	uid_high = uid / 256;
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
	uc = unicode3(data:key);
 
	len = 148 + strlen(uc);
 
	len_hi = len / 256;
	len_lo = len % 256;
 
 	z = 40 + strlen(uc);
	z_lo = z % 256;
	z_hi = z / 256;
 
	y = 81 + strlen(uc);
	y_lo = y % 256;
	y_hi = y / 256;
 
	x = 64 + strlen(uc);
	x_lo = x % 256;
	x_hi = x / 256;
 
	if(strlen(reply) &lt; 17){
		return NULL;
	}
	magic1 = raw_string(ord(reply[16]), ord(reply[17]));
 
	req = raw_string(0x00, 0x00,
			 len_hi, len_lo, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18);
	if(ntlmssp_flag){
		g_mhi = multiplex_id / 256;
        	g_mlo = multiplex_id % 256;	
		if(isSignActive)
			req += raw_string(0x07, 0x80);
		else
			req += raw_string(0x03, 0x80);
	}
	else{
		req += raw_string(0x03, 0x80);
	}
	req +=  magic1 +
	      	raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00,tid_low, tid_high);
	if(ntlmssp_flag)
		req += raw_string(0x33, 0x0c);
	else
		req += raw_string(0x00, 0x28);
	req += raw_string(uid_low, uid_high,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, x_lo, x_hi, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, x_lo, x_hi, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_low, pipe_high, y_lo, y_hi, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, x_lo, x_hi,
			 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, z_lo, z_hi,
			 0x00, 0x00, 0x00, 0x00, 0x07, 0x00);
		  
	magic = raw_string(ord(reply[84]));
	for(i=1; i&lt;20; i=i+1){
  		magic = magic + raw_string(ord(reply[84+i]));
 	}

	x = strlen(key) + strlen(key) + 2;
	x_lo = x % 256;
	x_hi = x / 256;
 
	req = req + magic +
	      raw_string(x_lo, x_hi, x_lo, x_hi, 0x01, 0x00,
 			 0x00, 0x00, key_len_lo, key_len_hi, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, key_len_lo, key_len_hi, 0x00) + uc +
	      raw_string(0);
	if(ntlmssp_flag &amp;&amp; isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:packet, buflen:len, seq_number:seq_number);
        }
 
 	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(strlen(r) &lt; 10){
		return(1);
	}
	if(ntlmssp_flag){
		multiplex_id += 1;
        	if(r &amp;&amp; isSignActive){
          		# verify signature
          		seq_number += 1;
          		len = strlen(r);
          		server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          		orig_sign = substr(r, 18, 23);
          		serv_sign = substr(server_resp, 18, 23);
          		if(orig_sign != serv_sign){
                   		return(FALSE);
          		}
        	}

	}	
 	error = substr(r, strlen(r) - 4, strlen(r) - 1);
 	return ((int(ord(error[3])) * 256 + int(ord(error[2]))) * 256 +
		 int(ord(error[1])) * 256) + int(ord(error[0]));
 }

 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_delete_value">registry_delete_value</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
			<dt>value</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_delete_value(soc, uid, tid, pipe, value, reply )
 {
 	local_var _na_start, i, error;

	key_len = strlen(value) + 1;
	key_len_hi = key_len / 256;
	key_len_lo = key_len % 256;
 
 	tid_low = tid % 256;
	tid_high = tid / 256;
	uid_low = uid % 256;
	uid_high = uid / 256;
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
	uc = unicode3(data:value);
 
	len = 148 + strlen(uc);
 
	len_hi = len / 256;
	len_lo = len % 256;
 
 	z = 40 + strlen(uc);
	z_lo = z % 256;
	z_hi = z / 256;
 
	y = 81 + strlen(uc);
	y_lo = y % 256;
	y_hi = y / 256;
 
	x = 64 + strlen(uc);
	x_lo = x % 256;
	x_hi = x / 256;
 
	if(strlen(reply) &lt; 17){
		return NULL;
	}

 	magic1 = raw_string(ord(reply[16]), ord(reply[17]));
 
	req = raw_string(0x00, 0x00,
 			 len_hi, len_lo, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18);
	if(ntlmssp_flag){
                g_mhi = multiplex_id / 256;
                g_mlo = multiplex_id % 256;
                if(isSignActive)
                        req += raw_string(0x07, 0x80);
                else
                        req += raw_string(0x03, 0x80);
        }
        else{
                req += raw_string(0x03, 0x80);
        }

	req += magic1 +
	      	raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00,tid_low, tid_high);
	if(ntlmssp_flag) 
                req += raw_string(0x33, 0x0c);
        else
                req += raw_string(0x00, 0x28);	
	req += raw_string(uid_low, uid_high,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, x_lo, x_hi, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, x_lo, x_hi, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_low, pipe_high, y_lo, y_hi, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, x_lo, x_hi,
			 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, z_lo, z_hi,
			 0x00, 0x00, 0x00, 0x00, 0x08, 0x00);
		  
	magic = raw_string(ord(reply[84]));
	for(i=1; i&lt;20; i=i+1){
  		magic = magic + raw_string(ord(reply[84+i]));
 	}

	x = strlen(value) + strlen(value) + 2;
	x_lo = x % 256;
	x_hi = x / 256;
 
	req = req + magic +
	      raw_string(x_lo, x_hi, x_lo, x_hi, 0x01, 0x00,
 			 0x00, 0x00, key_len_lo, key_len_hi, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, key_len_lo, key_len_hi, 0x00) + uc +
	      raw_string(0);

	if(ntlmssp_flag &amp;&amp; isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:packet, buflen:len, seq_number:seq_number);
        }
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(strlen(r) &lt; 10){
		return(1);
	}
	if(ntlmssp_flag){
                multiplex_id += 1;
                if(r &amp;&amp; isSignActive){
                        # verify signature
                        seq_number += 1;
                        len = strlen(r);
                        server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                        orig_sign = substr(r, 18, 23);
                        serv_sign = substr(server_resp, 18, 23);
                        if(orig_sign != serv_sign){
                                return(FALSE);
                        }
                }

        }
	
	error = substr(r, strlen(r) - 4, strlen(r) - 1);
 
	return ((int(ord(error[3])) * 256 + int(ord(error[2]))) * 256 +
		 int(ord(error[1])) * 256) + int(ord(error[0]));
 }

 #--------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_enum_key">registry_enum_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_enum_key(soc, uid, tid, pipe, reply)
 {
   if (strlen(uid) == 8)
   {
     res = registry2_enum_key(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
     return(res);
   }
   else{
     res = registry1_enum_key(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
     return(res);
   }
 }


function registry2_enum_key(soc, uid, tid, pipe, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_enum_value">registry_enum_value</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_enum_value(soc, uid, tid, pipe, reply)
 {
 	local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, name, data, list, i, j;
 
	tid_low = tid % 256;
	tid_high = tid / 256;
 
	uid_low = uid % 256;
	uid_high = uid / 256;
 
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
 
	magic = raw_string(ord(reply[84]));		  
	for(i=1; i&lt;20; i=i+1){
  		magic = magic + raw_string(ord(reply[84+i]));
	}

	for(j=0; j&gt;=0; j++)
 	{
		req = raw_string(0x00, 0x00,
 				 0x00, 0xC0, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
				 0x00, 0x00, 0x00, 0x18);
		if(ntlmssp_flag){
                	g_mhi = multiplex_id / 256;
                	g_mlo = multiplex_id % 256;
                	if(isSignActive)
                        	req += raw_string(0x07, 0x80);
                	else
                        	req += raw_string(0x03, 0x80);
        	}
        	else{
                	req += raw_string(0x03, 0x80);
        	}

		req += raw_string(0x00, 0x83,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, tid_low, tid_high);
		if(ntlmssp_flag)
                        req += raw_string(0x33, 0x0c);
                else
                        req += raw_string(0x00, 0x28);
		req += raw_string(uid_low, uid_high,
				 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x6C, 0x00, 0x00,
				 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
				 0x00, 0x6C, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
				 0x00, pipe_low, pipe_high, 0x59, 0x00, 0x00, 0x5C, 0x00,
				 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
				 0x5C, 0x00, 0x00, 0x00, 0xEE, 0xD5, 0x05, 0x00,
				 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x6C, 0x00,
				 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x30, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00);

  		req = req + magic +
		      raw_string(j % 256, j / 256, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				 0xcc, 0xf9, 0x06, 0x00, 0x00, 0x01, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0xa0, 0xf9, 0x06, 0x00, 0x59, 0xe6, 0x07, 0x00,
				 0x00, 0xc4, 0x04, 0x01, 0x00, 0x80, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0xb0, 0xf9, 0x06, 0x00, 0x00, 0x80, 0x00, 0x00,
				 0x94, 0xf9, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00); 

		if(ntlmssp_flag &amp;&amp; isSignActive){
                        len = strlen(req);
                        seq_number += 1;
                        packet = req;
                        req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
                }

 		send(socket:soc, data:req);
		r = smb_recv(socket:soc, length:65535);
		if(strlen(r) &lt; 80){
			return(NULL);
		}
		if(ntlmssp_flag){
                	multiplex_id += 1;
                	if(r &amp;&amp; isSignActive){
                        	# verify signature
                        	seq_number += 1;
                        	len = strlen(r);
                        	server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                        	orig_sign = substr(r, 18, 23);
                        	serv_sign = substr(server_resp, 18, 23);
                        	if(orig_sign != serv_sign){
                                	return(FALSE);
                        	}
                	}
        	}


		len = ord(r[60+24]);
		if(!len){
			break;
		}

		name = &quot;&quot;;
		for(i=0; i&lt;len; i=i+2){
			name += r[60+43+i+1];
		}

		if(!ord(r[60+43+len+2])){
			len+=2;
		}

		dlen = ord(r[60+43+len+21]);

		data = &quot;&quot;;
		for(i=0;i&lt;dlen;i = i+2){
			data += r[60+43+len+24+i+1];
		}

		list[j*2] = name;
		list[j*2+1] = data;
	}
	return list;
}

 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_flush">registry_flush</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_flush(soc, uid, tid, pipe, reply)
 {
	if(ntlmssp_flag)
        {
                response = registry_flush_NTLMSSP(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
                return(response);
        }

 	local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, name, data, i, len;
 
 	tid_low = tid % 256;
	tid_high = tid / 256;
 
	uid_low = uid % 256;
	uid_high = uid / 256;
 
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
 
	magic = raw_string(ord(reply[84]));		  
	for(i=1; i&lt;20; i=i+1){
  		magic = magic + raw_string(ord(reply[84+i]));
 	}

 	req = raw_string(0x00, 0x00, 0x00, 0x78, 0xFF, 0x53, 
			 0x4D, 0x42, 0x25, 0x00, 0x00, 0x00, 0x00, 0x08,
			 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_low, tid_high,
			 0x00, 0x28, uid_low, uid_high, g_mlo, g_mhi, 0x10, 0x00,
			 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x4c, 0x00, 0x2c, 0x00, 0x4c,
			 0x00, 0x02, 0x00, 0x26, 0x00, pipe_low, pipe_high, 0x35,
			 0x00, 0x5c, 0x50, 0x49, 0x50, 0x45, 0x5c, 0x00,
			 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0x10, 0x00,
			 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0xcf, 0x01,
			 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x0b, 0x00) + magic;
		  
 	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:65535);
 	if(r){
		return substr(r, strlen(r) - 4, strlen(r) - 1);
 	}
 }
  
 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_flush_NTLMSSP">registry_flush_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_flush_NTLMSSP(soc, uid, tid, pipe, reply)
 {
        local_var magic, req, r, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, name, data, i, len;

        tid_low = tid % 256;
        tid_high = tid / 256;

        uid_low = uid % 256;
        uid_high = uid / 256;

        pipe_low = pipe % 256;
        pipe_high = pipe / 256;
	
	g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        magic = raw_string(ord(reply[84]));
        for(i=1; i&lt;20; i=i+1){
                magic = magic + raw_string(ord(reply[84+i]));
        }

        req = raw_string(0x00, 0x00, 0x00, 0x78, 0xFF, 0x53,
                         0x4D, 0x42, 0x25, 0x00, 0x00, 0x00, 0x00, 0x08);
	if(isSignActive)
		req += raw_string(0x05, 0x40);
	else
                req += raw_string(0x01, 0x40);
	req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_low, tid_high,
                         0x33, 0x0c, uid_low, uid_high, g_mlo, g_mhi, 0x10, 0x00,
                         0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x4c, 0x00, 0x2c, 0x00, 0x4c,
                         0x00, 0x02, 0x00, 0x26, 0x00, pipe_low, pipe_high, 0x35,
                         0x00, 0x5c, 0x50, 0x49, 0x50, 0x45, 0x5c, 0x00,
                         0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0x10, 0x00,
                         0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0xcf, 0x01,
                         0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x0b, 0x00) + magic;
	if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }
	
        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:65535);
	multiplex_id += 1;
        if(r &amp;&amp; isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(r);
          server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          orig_sign = substr(r, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
          }
        }
	
        if(r){
                return substr(r, strlen(r) - 4, strlen(r) - 1);
        }
 }

 function registry_flush(soc, uid, tid, pipe, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_get_acl">registry_get_acl</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>key</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_get_acl(key)
 {
   local_var name, domain, _smb_port, login, pass, soc, r, uid, tid, pipe, ret, prot;

   name =  kb_smb_name();
   if(!name){
     return NULL;
   }

   domain = kb_smb_domain();
   _smb_port = kb_smb_transport();
   if(!_smb_port){
     return NULL;
   }

   if(!get_port_state(_smb_port)){
     return(FALSE);
   }

   login = kb_smb_login();
   pass  = kb_smb_password();

   if(!login){
     login = &quot;&quot;;
   }
   if(!pass){
     pass = &quot;&quot;;
   }

   soc = open_sock_tcp(_smb_port);
   if(!soc){
     return NULL;
   }

   # Request the session
   r = smb_session_request(soc:soc,  remote:name);
   if(!r){
     return(FALSE);
   }

   # Negotiate the protocol
   prot = smb_neg_prot(soc:soc);
   if(!prot){
     return(FALSE);
   }

   # Set up our session
   r = smb_session_setup(soc:soc, login:login, password:pass, domain:domain, prot:prot);
   if(!r){
      return(FALSE);
   }

     # and extract our uid
     uid = session_extract_uid(reply:r);
     if(!uid){
       return(NULL);
     }

     # Connect to the remote IPC and extract the TID
     # we are attributed
     r = smb_tconx(soc:soc, name:name, uid:uid, share:&quot;IPC$&quot;);
     if(!r){
       return(NULL);
     }
     # and extract our tree id
     tid = tconx_extract_tid(reply:r);
     if(!tid){
       return(NULL);
     }

     # Create a pipe to \winreg
     r = smbntcreatex(soc:soc, uid:uid, tid:tid, name:&quot;\winreg&quot;);
     if(!r){
       return(NULL);
     }
     # and extract its ID
     pipe = smbntcreatex_extract_pipe(reply:r);
     if(!pipe){
       return(FALSE);
     }

     # Setup things
     r = pipe_accessible_registry(soc:soc, uid:uid, tid:tid, pipe:pipe);
     if(!r){
       return(FALSE);
     }
     r = registry_open_hklm(soc:soc, uid:uid, tid:tid, pipe:pipe);
     if(!r){
       return(FALSE);
     }

     if(key){
       r2 = registry_get_key(soc:soc, uid:uid, tid:tid, pipe:pipe, key:key, reply:r);
     }
     else {
      r2 = r;
     }

     if(r2)
     {
       r3 = registry_get_key_security(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r2);
       if(!r3){
        return(FALSE);
       }
       registry_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r2);
       registry_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r);
       close(soc);

       if(strlen(r3) &lt; 100){
         return(NULL);
       }
       return(r3);
     }
     return(NULL);
   }
 

 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_get_binary">registry_get_binary</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>key</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_get_binary(key, item)
 {
 	local_var name, _smb_port, login, pass, domain, soc, uid, tid, r, prot, pipe, value;

	if(get_kb_item(&quot;SMB/samba&quot;)){
		return NULL;
	}

	name = kb_smb_name();
	if(!name){
      return NULL;
	}

    _smb_port = kb_smb_transport();
	if(!_smb_port){
      return NULL;
	}

    if(!get_port_state(_smb_port)){
      return(FALSE);
	}

	login = kb_smb_login();
	pass  = kb_smb_password();
	domain = kb_smb_domain();

	if(!login){
		login = &quot;&quot;;
	}
	if(!pass){
		pass = &quot;&quot;;
	}

	soc = open_sock_tcp(_smb_port);
	if(!soc){
		return(FALSE);
	}

	# Request the session
	r = smb_session_request(soc:soc,  remote:name);
	if(!r)
	{
		close(soc);
		return(FALSE);
	}

	# Negotiate the protocol
	prot = smb_neg_prot(soc:soc);
	if(!prot)
	{
		close(soc);
		return(FALSE);
	}

	# Set up our session
	r = smb_session_setup(soc:soc, login:login, password:pass, domain:domain, prot:prot);
	if(!r)
	{
		close(soc);
		return(FALSE);
	}

	# and extract our uid
	uid = session_extract_uid(reply:r);
	if(!uid)
        {
                close(soc);
                return NULL;
        }

	# Connect to the remote IPC and extract the TID
	# we are attributed
	r = smb_tconx(soc:soc, name:name, uid:uid, share:&quot;IPC$&quot;);
	if(!r)
        {
                close(soc);
                return NULL;
        }

	# and extract our tree id
	tid = tconx_extract_tid(reply:r);
	if(!tid)
	{
		close(soc);
		return(FALSE);
	}

	# Create a pipe to \winreg
	r = smbntcreatex(soc:soc, uid:uid, tid:tid, name:&quot;\winreg&quot;);
	if(!r)
	{
		close(soc);
		return(FALSE);
	}
	# and extract its ID
	pipe = smbntcreatex_extract_pipe(reply:r);

	# Setup things
	r = pipe_accessible_registry(soc:soc, uid:uid, tid:tid, pipe:pipe);
	if(!r)
	{
		close(soc);
		return(FALSE);
	}
	r = registry_open_hklm(soc:soc, uid:uid, tid:tid, pipe:pipe);
	if(!r)
        {
                close(soc);
                return NULL;
        }

	r2 = registry_get_key(soc:soc, uid:uid, tid:tid, pipe:pipe, key:key, reply:r);
	if(r2)
	{
		r3 =  registry_get_item_sz(soc:soc, uid:uid, tid:tid, pipe:pipe, item:item, reply:r2);
		registry_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r2);
		registry_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r);
		value = registry_decode_binary(data:r3);
		close(soc);
		return(value);
	}
	close(soc);
	return(FALSE);
 }

 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_get_dword">registry_get_dword</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>key</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_get_dword(key, item)
 {
 	local_var name, port, login, pass, soc, dom, r, prot, value;
 
	if(get_kb_item(&quot;SMB/samba&quot;)){
		return NULL;
	}
 
	port = kb_smb_transport();
	if(!port){
      return NULL;
	}

	name = kb_smb_name();
	if(!name){
      return NULL;
	}

	if(!get_port_state(port)){
      return(FALSE);
	}

	login = kb_smb_login();
	pass  = kb_smb_password();

	if(!login){
		login = &quot;&quot;;
	}
	if(!pass){
		pass = &quot;&quot;;
	}

	dom = kb_smb_domain();
	  
	soc = open_sock_tcp(port);
	if(!soc){
		return NULL;
	}

 	# Request the session
 	r = smb_session_request(soc:soc,  remote:name);
	if(!r)
	{
		close(soc);
		return NULL;
	}

 	# Negotiate the protocol
	prot = smb_neg_prot(soc:soc);
	if(!prot)
	{
		close(soc);
		return NULL;
	}

 	# Set up our session
	r = smb_session_setup(soc:soc, login:login, password:pass, domain:dom, prot:prot);
	if(!r)
	{
		close(soc);
		return NULL;
	}

	# and extract our uid
	uid = session_extract_uid(reply:r);
	if(!uid)
	{
		close(soc);
		return NULL;
	}

 	# Connect to the remote IPC and extract the TID
	# we are attributed
 	r = smb_tconx(soc:soc, name:name, uid:uid, share:&quot;IPC$&quot;);
	if(!r)
	{
		close(soc);
		return NULL;
	}

	# and extract our tree id
	tid = tconx_extract_tid(reply:r);
	if(!tid)
	{
		close(soc);
		return NULL;
	}

	# Create a pipe to \winreg
 	r = smbntcreatex(soc:soc, uid:uid, tid:tid, name:&quot;\winreg&quot;);
	if(!r)
	{
		close(soc);
		return(NULL);
	}

	 # and extract its ID
	pipe = smbntcreatex_extract_pipe(reply:r);
	if(!pipe)
	{
		close(soc);
		return NULL;
	}

	# Setup things
 	r = pipe_accessible_registry(soc:soc, uid:uid, tid:tid, pipe:pipe);
	if(!r)
	{
		close(soc);
		return(NULL);
	}
	r = registry_open_hklm(soc:soc, uid:uid, tid:tid, pipe:pipe);
	if(!r)
	{
		close(soc);
		return NULL;
	}

	r2 = registry_get_key(soc:soc, uid:uid, tid:tid, pipe:pipe, key:key, reply:r);
	if(r2)
 	{
		r3 = registry_get_item_dword(soc:soc, uid:uid, tid:tid, pipe:pipe, item:item, reply:r2);
 		registry_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r2);
		registry_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r);
		value = registry_decode_dword(data:r3);
		close(soc);
		return(value);
	}
	close(soc);
	return NULL;
 }

 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_get_item_dword">registry_get_item_dword</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_get_item_dword(soc, uid, tid, pipe, item, reply)
 {
   if (strlen(uid) == 8)
   {
    res = registry2_get_item_dword(soc:soc, uid:uid, tid:tid, pipe:pipe, item:item, reply:reply);
    return(res);
   }
   else{
    res = registry1_get_item_dword(soc:soc, uid:uid, tid:tid, pipe:pipe, item:item, reply:reply);
    return(res);
   }
 }

 function registry1_get_item_dword(soc, uid, tid, pipe, item, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_get_item_sz">registry_get_item_sz</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_get_item_sz(soc, uid, tid, pipe, item, reply)
 {
   if (strlen(uid) == 8)
   {
     res = registry2_get_item_sz(soc:soc, uid:uid, tid:tid, pipe:pipe, item:item, reply:reply);
     return(res);
   }
   else{
     res = registry1_get_item_sz(soc:soc, uid:uid, tid:tid, pipe:pipe, item:item, reply:reply);
     return(res);
   }
 }

 function registry1_get_item_sz(soc, uid, tid, pipe, item, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_get_key">registry_get_key</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>key</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
			<dt>write</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_get_key(soc, uid, tid, pipe, key, reply, write)
 {
  if (strlen(uid) == 8)
   {
     res = registry2_get_key(soc:soc, uid:uid, tid:tid, pipe:pipe, key:key, reply:reply);
     return(res);
   }
   else{
     res = registry1_get_key(soc:soc, uid:uid, tid:tid, pipe:pipe, key:key, reply:reply);

     return(res);
   }
 }

 function registry1_get_key(soc, uid, tid, pipe, key, reply, write)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_get_key_security">registry_get_key_security</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>reply</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_get_key_security(soc, uid, tid, pipe, reply)
 {
   if(ord(reply[4]) == 254)
   {
    ret = registry2_get_key_security(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
    return(ret);
   }
  else{
    ret = registry1_get_key_security(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:reply);
    return(ret);
  }
 }

 function registry1_get_key_security(soc, uid, tid, pipe, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_get_sz">registry_get_sz</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>item</dt>
			
		
			<dt>key</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function registry_get_sz(key, item)
{
  # Query KB (&quot;proxy&quot;) first.
  local_var kb_proxy, kb_proxy_key, value;
  kb_proxy_key = &quot;SMB//registry_get_sz//Registry//HKLM//&quot; + key + &quot;//&quot; + item;
  kb_proxy = get_kb_item (kb_proxy_key);
  if (!isnull (kb_proxy) || kb_proxy)
  return kb_proxy;

  # Value has not been previousle written to KB, fetch it.
  local_var name, _smb_port, login, pass, domain, soc, uid, tid, r, prot, pipe;
  if(get_kb_item(&quot;SMB/samba&quot;)){
    return NULL;
  }

  name = kb_smb_name();
  if(!name){
    return NULL;
  }

  _smb_port = kb_smb_transport();
  if(!_smb_port){
    return NULL;
  }

  if(!get_port_state(_smb_port)){
    return(FALSE);
  }

  login =  kb_smb_login();
  pass  =  kb_smb_password();
  domain = kb_smb_domain();

  if(!login){
    login = &quot;&quot;;
  }
  if(!pass){
    pass = &quot;&quot;;
  }

  soc = open_sock_tcp(_smb_port);
  if(!soc){
    return(FALSE);
  }

  # Request the session
  r = smb_session_request(soc:soc,  remote:name);
  if(!r)
  {
    close(soc);
    return(FALSE);
  }

  # Negotiate the protocol
  prot = smb_neg_prot(soc:soc);
  if(!prot)
  {
    close(soc);
    return(FALSE);
  }

  # Set up our session
  r = smb_session_setup(soc:soc, login:login, password:pass, domain:domain, prot:prot);
  if(!r)
  {
    close(soc);
    return(FALSE);
  }

    # and extract our uid
    uid = session_extract_uid(reply:r);
    if(!uid)
    {
      close(soc);
      return(FALSE);
    }
    # Connect to the remote IPC and extract the TID
    # we are attributed
    r = smb_tconx(soc:soc, name:name, uid:uid, share:&quot;IPC$&quot;);
    if(!r)
    {
      close(soc);
      return(FALSE);
    }
    # and extract our tree id
    tid = tconx_extract_tid(reply:r);
    if(!tid)
    {
      close(soc);
      return(FALSE);
    }

    # Create a pipe to \winreg
    r = smbntcreatex(soc:soc, uid:uid, tid:tid, name:&quot;\winreg&quot;);
    if(!r)
    {
      close(soc);
      return(FALSE);
    }
    # and extract its ID
    pipe = smbntcreatex_extract_pipe(reply:r);
    if(!pipe)
    {
      close(soc);
      return(FALSE);
    }
    # Setup things
    r = pipe_accessible_registry(soc:soc, uid:uid, tid:tid, pipe:pipe);
    if(!r)
    {
      close(soc);
      return(FALSE);
    }
    r = registry_open_hklm(soc:soc, uid:uid, tid:tid, pipe:pipe);
    if(!r)
    {
      close(soc);
      return(FALSE);
    }
    r2 = registry_get_key(soc:soc, uid:uid, tid:tid, pipe:pipe, key:key, reply:r);
    if(r2)
    {
      r3 =  registry_get_item_sz(soc:soc, uid:uid, tid:tid, pipe:pipe, item:item, reply:r2);
      registry_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r2);
      registry_close(soc:soc, uid:uid, tid:tid, pipe:pipe, reply:r);
      if(r3){
        value = registry_decode_sz(data:r3);
      }
      close(soc);

      # Place value into the KB
      if(!isnull(value)) {
        set_kb_item (name: kb_proxy_key, value:value);
      }
      return(value);

    }
    close(soc);
    return(FALSE);
  }


 #---------------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_key_exists">registry_key_exists</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>key</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_key_exists(key)
 {

   if(!key){
     return NULL;
   }
   name = kb_smb_name();
   if(!name){
     exit(0);
   }

	port = kb_smb_transport();
	if(!port){
		return NULL;
	}

   if(!get_port_state(port)){
     exit(0);
   }

   login =  kb_smb_login();
   pass  =  kb_smb_password();

   if(!login)login = &quot;&quot;;
   if(!pass) pass = &quot;&quot;;

   dom = kb_smb_domain();
   soc = open_sock_tcp(port);
   if(!soc){
     return NULL;
   }
   # Request the session
   r = smb_session_request(soc:soc,  remote:name);
   if(!r){
     return(FALSE);
   }

   # Negotiate the protocol
   prot = smb_neg_prot(soc:soc);
   if(!prot){
     return(FALSE);
   }

   # Set up our session
   r = smb_session_setup(soc:soc, login:login, password:pass,
                          domain:dom, prot:prot);
   if(!r){
          return(FALSE);
   }

   # extract our ssid
   uid = session_extract_uid(reply:r);

     # Connect to the remote IPC and extract the TID
     r = smb_tconx(soc:soc, name:name, uid:uid, share:&quot;IPC$&quot;);
     if(!r){
         return(FALSE);
     }

     tid = tconx_extract_tid(reply:r);
     if(!tid){
       return(FALSE);
     }

     # Create a pipe to \winreg
     r = smbntcreatex(soc:soc, uid:uid, tid:tid, name:&quot;\winreg&quot;);
     if(!r)
     {
         return(FALSE);
     }

     # and extract its ID
     pipe = smbntcreatex_extract_pipe(reply:r);
     if (!pipe)
     {
          return(FALSE);
     }
     r = pipe_accessible_registry(soc:soc, uid:uid, tid:tid, pipe:pipe);
     if(!r){
       return(FALSE);
     }
     r = registry_open_hklm(soc:soc, uid:uid, tid:tid, pipe:pipe);
     r2 = registry_get_key(soc:soc, uid:uid, tid:tid, pipe:pipe, key:key, reply:r);

     close(soc);
     if(!r2 &amp;&amp; strlen(r2) &lt; 104){
     return NULL;
     }
     #flag = 0;
     if (strlen(uid) == 8)
     {
       for(i=1; i&lt;20; i=i+1)
       {
         if(ord(r2[140+i]) != 0)
         {
           return TRUE;
           #flag = 1;
         }
       }

     }
     else{
        for(i=1; i&lt;20; i=i+1)
        {
          if(ord(r2[84+i]) != 0)
          {
            return TRUE;
            #flag = 1;
          }
        }

     }
return NULL;

   }

 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_key_writeable_by_non_admin">registry_key_writeable_by_non_admin</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>security_descriptor</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_key_writeable_by_non_admin(security_descriptor)
 {
 	local_var r, num_aces, size, start, s, i, mask, z, id_auth, num_auth, sub_auth, k, n, sid;
	local_var WRITE, ADMIN_SID, LOCAL_SYSTEM_SID, CREATOR_OWNER_SID; 
 
	if(isnull(security_descriptor)){
		return(NULL);
	}
	
	# write mask
	WRITE = 0x00010000 | 0x00040000 | 0x00080000 | 0x00000002 | 0x000004;

	# sids

	ADMIN_SID = &quot;1-000005-32-544&quot;;
	LOCAL_SYSTEM_SID = &quot;1-000005-18&quot;;
	CREATOR_OWNER_SID = &quot;1-000003-0&quot;;

 	r = security_descriptor;
	num_aces = 0;
	num_aces = ord(r[135]);
	num_aces = ord(r[134])+ num_aces*256;
	num_aces = ord(r[133])+ num_aces*256;
	num_aces = ord(r[132])+ num_aces*256;
	start = 137;
 	size = 0;
	s = start;

	for(i=0;i&lt;num_aces;i=i+1)
 	{
		z = ord(r[s+2]);
		z = ord(r[s+1])+z*256;
		mask = ord(r[s+6]);
		mask = ord(r[s+5])+mask*256;
		mask = ord(r[s+4])+mask*256;
		mask = ord(r[s+3])+mask*256;
  
		id_auth = ord(r[s+14]);
		id_auth = string(ord(r[s+13]), id_auth);
		id_auth = string(ord(r[s+12]), id_auth);
		id_auth = string(ord(r[s+11]), id_auth);
		id_auth = string(ord(r[s+10]), id_auth);
		id_auth = string(ord(r[s+9]), id_auth);
  
		num_auths = ord(r[s+8]);
		sub_auths = &quot;&quot;;
		k = 15;
		for(c = 0;c &lt; num_auths; c = c+1)
		{
			n = ord(r[s+k+3]);
			n = ord(r[s+k+2])+n*256;
			n = ord(r[s+k+1])+n*256;
			n = ord(r[s+k])+n*256;
			k = k + 4;
			sub_auths = string(sub_auths,&quot;-&quot;,n);
		}
  
		sid = string(ord(r[s+7]), &quot;-&quot;, id_auth, sub_auths);
		# display(&quot;sid = &quot;, sid, &quot;\n&quot;);
		if(mask &amp; WRITE)
		{
			#     display(&quot;writeable by &quot;, sid, &quot;\n&quot;);
			#	  display(mask &amp; WRITE, &quot;\n&quot;);
	
			if((sid != ADMIN_SID) &amp;&amp; (sid != LOCAL_SYSTEM_SID) &amp;&amp;
	    		   (sid != CREATOR_OWNER_SID))
			{
				#display(&quot;sid != &quot;, CREATOR_OWNER_SID, &quot;\n&quot;);
				#display(mask, &quot;\n&quot;);
				return(TRUE);
			}
      		}
		s = s + z;
 	} 
	return(FALSE);
 }

 #---------------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_open_hklm">registry_open_hklm</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_open_hklm(soc, uid, tid, pipe)
 {
   if (strlen(uid) == 8)
   {
     res = registry2_open_hklm(soc:soc, uid:uid, tid:tid, pipe:pipe);
     return(res);
   }
   else{
     res = registry1_open_hklm(soc:soc, uid:uid, tid:tid, pipe:pipe);
     return(res);
   }
 }

function registry1_open_hklm(soc, uid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_open_hklm_NTLMSSP">registry_open_hklm_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>ssid</dt>
			
		
			<dt>tid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_open_hklm_NTLMSSP(soc, ssid, tid, pipe)
 {
   local_var req, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, r;

 tid_low = tid % 256;
 tid_high = tid / 256;
 uid_low = uid % 256;
 uid_high = uid / 256;
 pipe_low = pipe % 256;
 pipe_high = pipe / 256;
 g_mhi = multiplex_id / 256;
 g_mlo = multiplex_id % 256;

 req = raw_string(0x00, 0x00, 0x00, 0x78, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
                  0x00, 0x00, 0x00, 0x18);
 if(isSignActive){
                        req += raw_string(0x07, 0x80);
        }
        else
                req += raw_string(0x03, 0x80);
 req += raw_string(0x1D, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, tid_low, tid_high, 0x33, 0x0c, uid_low, uid_high,
                   g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x24, 0x00, 0x00,
                   0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
                   0x00, 0x24, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
                   0x00, pipe_low, pipe_high, 0x35, 0x00, 0x00, 0x5c, 0x00,
                   0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
                   0x5C, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x05, 0x00,
   0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
   0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0xFF,
   0x12, 0x00, 0x30, 0x39, 0x01, 0x00, 0x00, 0x00,
   0x00, 0x02);
 if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:packet, buflen:len, seq_number:seq_number);
        }

 send(socket:soc, data:req);
 r = smb_recv(socket:soc, length:4096);
 if(strlen(r) &lt; 10){
   return(FALSE);
 }
 multiplex_id += 1;
 if(isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(r);
          server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          orig_sign = substr(r, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
  }
        }

 if(ord(r[9])==0){
   return(r);
  }
 else {
  return(FALSE);
 }
 }


function registry2_open_hklm_NTLMSSP(soc, uid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_open_hku">registry_open_hku</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_open_hku(soc, uid, tid, pipe)
 {
	if(ntlmssp_flag)
        {
                response = registry_open_hku_NTLMSSP(soc:soc, uid:uid, tid:tid, pipe:pipe);
                return(response);
        }

 	local_var req, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, r;

	tid_low = tid % 256;
	tid_high = tid / 256;
	uid_low = uid % 256;
	uid_high = uid / 256;
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
 
	req = raw_string(0x00, 0x00,
 		 	 0x00, 0x78, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x03, 0x80, 0x1D, 0x83,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x24, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x24, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_low, pipe_high, 0x35, 0x00, 0x00, 0x5c, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
			 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0xFF,
			 0x12, 0x00, 0x30, 0x39, 0x01, 0x00, 0x00, 0x00,
			 0x00, 0x02);
		  
 	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(strlen(r) &lt; 10){
		return(FALSE);
	}
 	if(ord(r[9])==0){
		return(r);
	}
	else {
		return(FALSE);
	}
 }

 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_open_hku_NTLMSSP">registry_open_hku_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_open_hku_NTLMSSP(soc, uid, tid, pipe)
 {
        local_var req, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, r;

        tid_low = tid % 256;
        tid_high = tid / 256;
        uid_low = uid % 256;
        uid_high = uid / 256;
        pipe_low = pipe % 256;
        pipe_high = pipe / 256;
        g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        req = raw_string(0x00, 0x00,
                         0x00, 0x78, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
                         0x00, 0x00, 0x00, 0x18);
	if(isSignActive)
                req += raw_string(0x07, 0x80);
        else
		req += raw_string(0x03, 0x80);
	req += raw_string(0x1D, 0x83,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, tid_low, tid_high, 0x33, 0x0c, uid_low, uid_high,
                         g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x24, 0x00, 0x00,
                         0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
                         0x00, 0x24, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
                         0x00, pipe_low, pipe_high, 0x35, 0x00, 0x00, 0x5c, 0x00,
                         0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
                         0x5C, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x05, 0x00,
                         0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x24, 0x00,
                         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0xFF,
                         0x12, 0x00, 0x30, 0x39, 0x01, 0x00, 0x00, 0x00,
                         0x00, 0x02);

	if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }

        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4096);
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
	multiplex_id += 1;
        if(r &amp;&amp; isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(r);
          server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          orig_sign = substr(r, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
          }
        }
	
        if(ord(r[9])==0){
                return(r);
        }
        else {
                return(FALSE);
        }
 }


 function registry_open_hku(soc, uid, tid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="registry_shutdown">registry_shutdown</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>closeapps</dt>
			
		
			<dt>message</dt>
			
		
			<dt>pipe</dt>
			
		
			<dt>reboot</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>timeout</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function registry_shutdown(soc, uid, tid, pipe, message, timeout, reboot, closeapps)
 {
 	local_var _na_start, i, error, msg_len, msg_len_hi, msg_len_lo, tid_low, tid_high, uid_low, uid_high, pipe_low, pipe_high, uc;

	msg_len = strlen(message) + 1;
	msg_len_hi = msg_len / 256;
	msg_len_lo = msg_len % 256;
 
 	tid_low = tid % 256;
	tid_high = tid / 256;
	uid_low = uid % 256;
	uid_high = uid / 256;
	pipe_low = pipe % 256;
	pipe_high = pipe / 256;
	uc = unicode4(data:message);
 
	len = 146 + strlen(uc);
 
	len_hi = len / 256;
	len_lo = len % 256;
 
 	z = 38 + strlen(uc);
	z_lo = z % 256;
	z_hi = z / 256;
 
	y = 79 + strlen(uc);
	y_lo = y % 256;
	y_hi = y / 256;
 
	x = 62 + strlen(uc);
	x_lo = x % 256;
	x_hi = x / 256;
 
 	req = raw_string(0x00, 0x00,
 		         len_hi, len_lo, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18);
	if(ntlmssp_flag){
                g_mhi = multiplex_id / 256;
                g_mlo = multiplex_id % 256;
                if(isSignActive)
                        req += raw_string(0x07, 0x80);
                else
                        req += raw_string(0x03, 0x80);
        }
        else{
                req += raw_string(0x03, 0x80);
        }

	req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00,tid_low, tid_high);
	if(ntlmssp_flag)
                req += raw_string(0x33, 0x0c);
        else
                req += raw_string(0x00, 0x28);
	req += raw_string(uid_low, uid_high,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, x_lo, x_hi, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, x_lo, x_hi, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_low, pipe_high, y_lo, y_hi, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, x_lo, x_hi,
			 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, z_lo, z_hi,
			 0x00, 0x00, 0x00, 0x00, 0x18, 0x00);

	x = strlen(message) + strlen(message);
	x_lo = x % 256;
	x_hi = x / 256;
	y = x + 2;
	y_lo = y % 256;
	y_hi = y / 256;

	msg_len2 = msg_len - 1;
	msg_len2_lo = msg_len2 % 256;
	msg_len2_hi = msg_len2 / 256;

	req += raw_string(0x01, 0x00, 0x00, 0x00,  # ptr_1
			  0x01, 0x00, 0x00, 0x00,  # ptr_2
			  0x01, 0x00, 0x00, 0x00,  # ptr_3
			  x_lo, x_hi,		     # uni_str_len
			  y_lo, y_hi,		     # max_str_len
			  0x01, 0x00, 0x00, 0x00,  # buffer
			  msg_len_lo, msg_len_hi, 0x00, 0x00,  # uni_max_len
			  0x00, 0x00, 0x00, 0x00 , # undoc
			  msg_len2_lo, msg_len2_hi, 0x00, 0x00);  # str_max_len
 	req += uc;
	req += raw_string(timeout % 256, (timeout/256) % 256, (timeout/(256*256)) % 256,
			  timeout / (256*256*256));
 	if(closeapps){
		req += raw_string(0x01);
	}
	else {
		req += raw_string(0x00);
	}
 
	if(reboot){
		req += raw_string(0x01);
	}
	else {
		req += raw_string(0x00);
	}
	 if(ntlmssp_flag &amp;&amp; isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }

 	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
	if(strlen(r) &lt; 10){
		return(1);
	}
	if(ntlmssp_flag){
                multiplex_id += 1;
                if(r &amp;&amp; isSignActive){
                        # verify signature
                        seq_number += 1;
                        len = strlen(r);
                        server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                        orig_sign = substr(r, 18, 23);
                        serv_sign = substr(server_resp, 18, 23);
                        if(orig_sign != serv_sign){
                                return(FALSE);
                        }
                }

        }

	error = substr(r, strlen(r) - 4, strlen(r) - 1);
 	return ((int(ord(error[3])) * 256 + int(ord(error[2]))) * 256 +
		 int(ord(error[1])) * 256 ) + int(ord(error[0]));
 }

 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="samr_smbreadx">samr_smbreadx</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function samr_smbreadx(soc, tid, uid, pipe)
 {
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
	req = raw_string(0x00, 0x00,
 			 0x00, 0x3B, 0xFF, 0x53, 0x4D, 0x42, 0x2E, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x0C, 0xFF, 0x00, 0xDE, 0xDE, pipe_lo,
			 pipe_hi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
			 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x00, 
			 0x00, 0x00, 0x00, 0x00, 0x00);
		  
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
 }		    

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="samr_smbwritex">samr_smbwritex</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function samr_smbwritex(soc, tid, uid, pipe)
 {
	if(ntlmssp_flag){
		response = samr_smbwritex_NTLMSSP(soc:soc, tid:tid, uid:uid, pipe:pipe);
		return response;
	}
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
 
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
	req = raw_string(0x00, 0x00,
 			 0x00, 0x88, 0xFF, 0x53, 0x4D, 0x42, 0x2F, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x0E, 0xFF, 0x00, 0xDE, 0xDE, pipe_lo,
			 pipe_hi, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
			 0xFF, 0x08, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48,
			 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
			 0x00, 0xEE, 0x05, 0x00, 0x0B, 0x03, 0x10, 0x00,
			 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00,
			 0x00, 0x00, 0xB8, 0x10, 0xB8, 0x10, 0x00, 0x00,
			 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x01, 0x00, 0x78, 0x57, 0x34, 0x12, 0x34, 0x12,
			 0xCD, 0xAB, 0xEF, 0x00, 0x01, 0x23, 0x45, 0x67,
			 0x89, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x04, 0x5D,
			 0x88, 0x8A, 0xEB, 0x1C, 0xC9, 0x11, 0x9F, 0xE8,
			 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60, 0x02, 0x00,
			 0x00, 0x00);
		  
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);
 }		

 function samr_smbreadx(soc, tid, uid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="samr_smbwritex_NTLMSSP">samr_smbwritex_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function samr_smbwritex_NTLMSSP(soc, tid, uid, pipe)
 {
        tid_hi = tid / 256;
        tid_lo = tid % 256;

        uid_hi = uid / 256;
        uid_lo = uid % 256;

        pipe_hi = pipe / 256;
        pipe_lo = pipe % 256;
	
	g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        req = raw_string(0x00, 0x00,
                         0x00, 0x88, 0xFF, 0x53, 0x4D, 0x42, 0x2F, 0x00,
                         0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, tid_lo, tid_hi, 0x33, 0x0c, uid_lo, uid_hi,
                         g_mlo, g_mhi, 0x0E, 0xFF, 0x00, 0xDE, 0xDE, pipe_lo,
                         pipe_hi, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
                         0xFF, 0x08, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48,
                         0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
                         0x00, 0xEE, 0x05, 0x00, 0x0B, 0x03, 0x10, 0x00,
                         0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00,
                         0x00, 0x00, 0xB8, 0x10, 0xB8, 0x10, 0x00, 0x00,
                         0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x01, 0x00, 0x78, 0x57, 0x34, 0x12, 0x34, 0x12,
                         0xCD, 0xAB, 0xEF, 0x00, 0x01, 0x23, 0x45, 0x67,
                         0x89, 0xAC, 0x01, 0x00, 0x00, 0x00, 0x04, 0x5D,
                         0x88, 0x8A, 0xEB, 0x1C, 0xC9, 0x11, 0x9F, 0xE8,
                         0x08, 0x00, 0x2B, 0x10, 0x48, 0x60, 0x02, 0x00,
                         0x00, 0x00);
	if(isSignActive){
              len = strlen(req);
              seq_number += 1;
              packet = req;
              req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }

        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4096);
	multiplex_id += 1;
        if(r &amp;&amp; isSignActive){
              # verify signature
              seq_number += 1;
              len = strlen(r);
              server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
              orig_sign = substr(r, 18, 23);
              serv_sign = substr(server_resp, 18, 23);
              if(orig_sign != serv_sign){
                     return(FALSE);
              }
        }
	return(r);
	
 }

 function samr_smbwritex(soc, tid, uid, pipe)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="samr_uc">samr_uc</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>name</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function samr_uc(name)
 {
	local_var i;
 	ret = &quot;&quot;;
	for(i=0; i&lt;strlen(name); i=i+1){
  		ret = ret + raw_string(0) + name[i];
 	}
	return(ret);
 }

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="session_extract_sessionid">session_extract_sessionid</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>reply</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function session_extract_sessionid(reply)
{
        start = stridx(reply, &quot;SMB&quot;);
        start = 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 8 + 4 + 4;
        #NTLMSSP challenge is 8 bytes in size
        ssid = (substr(reply, start, start+7));
        return (ssid);

}

 #-----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="session_extract_uid">session_extract_uid</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>reply</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function session_extract_uid(reply)
 {
   if(ord(reply[4]) == 254)
   {
     uid = session_extract_sessionid(reply);
     return(uid);
   }
   else{
     low = ord(reply[32]);
     high = ord(reply[33]);
     uid = high * 256;
     uid = uid + low;
     return(uid);
   }
 }

 #------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb1_close_request">smb1_close_request</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>fid</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb1_close_request(soc, uid, tid, fid)
{
        local_var r, req, uid_lo, uid_hi, tid_lo, tid_hi, fid_hi, fid_lo;

        uid_lo = uid % 256; uid_hi = uid / 256;
        tid_lo = tid % 256; tid_hi = tid / 256;
        fid_lo = fid % 256; fid_hi = fid / 256;

        req = raw_string(0x00, 0x00, 0x00, 0x29, 0xFF, 0x53,
                         0x4D, 0x42, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08);
	if(ntlmssp_flag){
		g_mhi = multiplex_id / 256;
        	g_mlo = multiplex_id % 256;
		if(isSignActive)
			req += raw_string(0x05, 0xc8);
		else
			req += raw_string(0x01, 0xc8);
	}
	else
		req += raw_string(0x01, 0xc8);
        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi);
	if(ntlmssp_flag)
		req += raw_string(0x33, 0x0c);
	else
                req += raw_string(0x00, 0x28);
	req += raw_string(uid_lo, uid_hi, g_mlo, g_mhi, 0x03, fid_lo,
                         fid_hi, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00);
	if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }

        send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:65535);
        if(strlen(r) &lt; 35){
                return(NULL);
        }
	if(ntlmssp_flag){
		multiplex_id += 1;
        	if(r &amp;&amp; isSignActive){
          		# verify signature
          		seq_number += 1;
          		len = strlen(r);
          		server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          		orig_sign = substr(r, 18, 23);
          		serv_sign = substr(server_resp, 18, 23);
          		if(orig_sign != serv_sign){
                   		return(FALSE);
          		}
        	}
	}
	if(ord(r[9])==0){
                return(r);
        }
        else {
                return(FALSE);
        }

 }


 # Returns the size of the file pointed by &lt;fid&gt;

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb1_get_file_size_NTLMSSP">smb1_get_file_size_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>fid</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb1_get_file_size_NTLMSSP(socket, uid, tid, fid)
 {
        local_var r, req, uid_lo, uid_hi, tid_lo, tid_hi, fid_lo, fid_hi, ret;
	g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        uid_lo = uid % 256; uid_hi = uid / 256;
        tid_lo = tid % 256; tid_hi = tid / 256;
        fid_lo = fid % 256; fid_hi = fid / 256;

        req = raw_string(0x00, 0x00, 0x00, 0x48, 0xFF, 0x53,
                         0x4D, 0x42, 0x32, 0x00, 0x00, 0x00, 0x00, 0x08);
	if(isSignActive)
                req += raw_string(0x05, 0x40);
        else
                req += raw_string(0x01, 0x40);

        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi,
                         0x33, 0x0c, uid_lo, uid_hi, g_mlo, g_mhi, 0x0F, 0x04,
                         0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x11, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x00, 0x48,
                         0x00, 0x01, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00,
                         0x44, 0x20, fid_lo, fid_hi, 0x07, 0x01);

	if(isSignActive){
                len = strlen(req);
                seq_number += 1;
                packet = req;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }


        send(socket:socket, data:req);
        r = smb_recv(socket:socket, length:4096);
        if(strlen(r) &lt; 112){
                return -1;
        }
	multiplex_id += 1;
        if(r &amp;&amp; isSignActive){
          # verify signature
          seq_number += 1;
          len = strlen(r);
          server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
          orig_sign = substr(r, 18, 23);
          serv_sign = substr(server_resp, 18, 23);
          if(orig_sign != serv_sign){
                   return(FALSE);
          }
        }

        ret = ord(r[115]);
        ret = ret * 256 + ord(r[114]);
        ret = ret * 256 + ord(r[113]);
        ret = ret * 256 + ord(r[112]);
        return ret;
 }

 function smb_get_file_size(socket, uid, tid, fid)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb1ntcreatex">smb1ntcreatex</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>always_return_blob</dt>
			
		
			<dt>name</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb1ntcreatex(soc, uid, tid, name, always_return_blob)
{
   if(ntlmssp_flag)
   {
     response = smbntcreatex_NTLMSSP(soc:soc, uid:uid, tid:tid, name:name, always_return_blob:always_return_blob);
     return(response);
   }
   else
   {
     tid_high = tid / 256;
     tid_low  = tid % 256;

     uid_high = uid / 256;
     uid_low  = uid % 256;

     req = raw_string(0xFF, 0x53, 0x4D, 0x42, 0xA2, 0x00,
                      0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x50, 0x81,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
                      g_mlo, g_mhi, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00,
                      0x07, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x9F, 0x01, 0x02, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
                      0x00, 0x00, 0x00, (strlen(name)+1) % 256, 0x00) + name +
                      raw_string(0x00);

     req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + req;

       send(socket:soc, data:req);
       r = smb_recv(socket:soc, length:4000);
       if(always_return_blob){
                return r;
        }
        if(strlen(r) &lt; 10){
                return(FALSE);
       }
       if(ord(r[9])==0x00){
                return(r);
        }
        else {
                return(FALSE);
        }

 }
 }


 #--------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_close_request">smb2_close_request</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>fid</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb2_close_request(soc, uid, tid, fid)
{
  g_mhi = multiplex_id / 256;
  g_mhi = multiplex_id % 256;

  req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x60, 0x1f);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }

  req += raw_string(0x00, 0x00, 0x00, 0x00,
                   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00);

  close_req = raw_string(0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, fid);

  req = req + close_req;

   if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + req ;
    }

  send(socket:soc, data:req);
  r = smb_recv(socket:soc, length:65535);
        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }

 if(ord(r[11])==0){
                return(r);
        }
        else {
                return(FALSE);
        }

}


function smb1_close_request(soc, uid, tid, fid)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_get_file_size_NTLMSSP">smb2_get_file_size_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>fid</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb2_get_file_size_NTLMSSP(socket, uid, tid, fid)
{
  g_mhi = multiplex_id / 256;
  g_mlo = multiplex_id % 256;


  req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x6f, 0x00);

   if(isSignActive){
                 req += raw_string(0x08, 0x00, 0x00, 0x00);
   }
   else {
                 req += raw_string(0x00, 0x00, 0x00, 0x00);
   }

  req += raw_string(0x00, 0x00, 0x00, 0x00,
                   g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, tid, uid, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

 get_info = raw_string(0x29, 0x00, 0x01, 0x05, 0x04, 0x11, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       fid );
 req = req + get_info;
 req_l = strlen(req);
 len_lo =  req_l % 256;
 len_hi = req_l / 256;

   if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, len_hi, len_lo) + req;
    }
    else{
         req = raw_string(0x00, 0x00, len_hi, len_lo) + req;
    }

 send(socket:soc, data:req);
 r = smb_recv(socket:socket, length:4096);

   ##If status is pending
    ##if status is pending , wait for response
    status = ord(r[12]);
    status2 = ord(r[13]);
    while(status == 3 &amp;&amp; status2 == 1)
    {
      ##PDU will arrive late
      r = smb_recv(socket:soc, length:4096);
      status = ord(r[12]);
      status2 = ord(r[13]);
    }

       multiplex_id += 1;
        if(r &amp;&amp; isSignActive){
          # verify signature
          seq_number += 1;

          r_head = substr(r, 0, 3);
          r = substr(r, 4, strlen(r)-1);
          orig_sign = substr(r, 48, 63);
          server_resp = get_smb2_signature(buf:r, key: sign_key);
          serv_sign = substr(server_resp, 48, 63);
          if(orig_sign != serv_sign){
            return(FALSE);
          }
          else {
            r = r_head + r;
          }
        }
        ret = ord(r[87]);
        ret = ret * 256 + ord(r[86]);
        ret = ret * 256 + ord(r[85]);
        ret = ret * 256 + ord(r[84]);
        return ret;
}


 function smb1_get_file_size_NTLMSSP(socket, uid, tid, fid)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_neg_prot">smb2_neg_prot</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>domain</dt>
			
		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb2_neg_prot(soc, domain)
 {
   multiplex_id =1;
    g_mhi = multiplex_id / 256;
    g_mlo = multiplex_id % 256;

   #SMB2 header
        st = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, g_mlo, g_mhi, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x24, 0x00);

        st += raw_string(0x02, 0x00, 0x01, 0x00,
                        0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02,
                        0x10, 0x02);
len = strlen(st);
len_hi = len / 256;
len_lo = len % 256;

     stt = raw_string(0x00, 0x00, len_hi, len_lo) + st;

        send(socket:soc, data:stt);
        r = smb_recv(socket:soc, length:1024);
        multiplex_id += 1;
        return(r);
 }

#SMB

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_session_setup">smb2_session_setup</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>domain</dt>
			
		
			<dt>login</dt>
			
		
			<dt>password</dt>
			
		
			<dt>prot</dt>
			
		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb2_session_setup(soc, login, password, domain, prot)
 {
   local_var ct, ret, ntlmv1, cs, flags, flg_str, uid;

   ct = get_kb_item(&quot;SMB/dont_send_in_cleartext&quot;);
   ntlmv1 = get_kb_item(&quot;SMB/dont_send_ntlmv1&quot;);

   if(ntlmssp_flag)
   {
      #Step 1: Negotiation
      ret = smb2_session_setup_NTLMSSP_NEGOT(soc:soc, domain:domain);
      #Step 2:  Read the server challenge from response ret
      cs = smb_session_setup_NTLMSSP_extract_chal(ret);
      #Step 3: Authentication
      flags = smb_session_setup_NTLMSSP_extract_flag(ret);
      flg_str = smb_session_setup_NTLMSSP_auth_flags(neg_flags:flags);
      ssid = session_extract_sessionid(reply:ret);
      if(!ssid){
              return(FALSE);
          }

      local_var addr_list;
      addr_list = smb_session_setup_NTLMSSP_extract_addrlist(ret);
      # call the function to get address list from type 2 message
      if(ntlmv2_flag){
        ret = smb2_session_setup_NTLMSSP_AUTH(soc:soc, login:login, password:password,
                    domain:domain, version:2, cs:cs, uid:uid, server_flags:flags, flag_str:flg_str, addr_list:addr_list);
      }
      else{
           ret = smb2_session_setup_NTLMSSP_AUTH(soc:soc, login:login, password:password,
                     domain:domain, version:2, cs:cs, uid:ssid, server_flags:flags, flag_str:flg_str, addr_list:addr_list);

     if(!ret){
     ret = smb2_session_setup_NTLMSSP_AUTH(soc:soc, login:login, password:password,
                                       domain:domain, version:1, cs:cs, uid:uid, server_flags:flags, flag_str:flg_str, addr_list:addr_list);
     }
   }
   return(ret);
 }
 else
 {
   ret = smb_session_setup_NTLMvN(soc:soc, login:login, password:password,
              domain:domain, cs:smb_neg_prot_cs(prot:prot), version:2);
      if(!ret &amp;&amp; !ntlmv1){
        ret = smb_session_setup_NTLMvN(soc:soc, login:login, password:password,
             domain:domain, cs:smb_neg_prot_cs(prot:prot), version:1);}
         return(ret);
 }
}

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_session_setup_NTLMSSP_AUTH">smb2_session_setup_NTLMSSP_AUTH</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>addr_list</dt>
			
		
			<dt>cs</dt>
			
		
			<dt>domain</dt>
			
		
			<dt>login</dt>
			
		
			<dt>password</dt>
			
		
			<dt>server_flags</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>ssid</dt>
			
		
			<dt>version</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb2_session_setup_NTLMSSP_AUTH(soc, login, password, domain, version, cs, ssid, server_flags, addr_list)
 {
   local_var lm, nt, encrypted_session_key, st, r, NT_H, session_key;
   if(!domain)
      domain = &quot;WORKGROUP&quot;;

   NTLMSSP_NEGOTIATE_KEY_EXCH = 0x40000000;	
   NTLMSSP_NEGOTIATE_NTLM2 = 0x00080000;

   g_mhi = multiplex_id / 256;
   g_mlo = multiplex_id % 256;

#SMB2 header
   st = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x01, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00);

#Add Session ID
st += raw_string(ssid);

#Signature
st += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

#  if(isSignActive){
 #               st +=  raw_string(0x05, 0xc8);
  #      }
   #     else{
    #            st += raw_string(0x19, 0x00);
#  }

if(version == 2)
{
  NT_H = nt_owf_gen(password);
  ntlmv2_hash = ntv2_owf_gen(owf:NT_H, login:login, domain:domain);
  addr_list_len = strlen(addr_list);
  result = ntlmv2_response(cryptkey:cs, user:login, domain:domain, ntlmv2_hash:ntlmv2_hash, address_list:addr_list, address_list_len:addr_list_len);
                lm = substr(result, 0, 23);
                session_key = substr(result, 24, 39);
                nt = substr(result, 40, strlen(result)-1);
}
else if(server_flags &amp; NTLMSSP_NEGOTIATE_NTLM2)
{
#nt hash
        NT_H = nt_owf_gen(password);
        result = ntlm2_response(cryptkey:cs, password:password, nt_hash:NT_H);
        lm = substr(result, 0, 23);
        nt = substr(result, 24, 47);
        session_key = substr(result, 48, 63);
}
else
{
#nt hash
                NT_H = nt_owf_gen(password);
                result = ntlm_response(cryptkey:cs, password:password, nt_hash:NT_H, neg_flags:server_flags);
                lm = substr(result, 0, 23);
                nt = substr(result, 24, 47);
                session_key = substr(result, 48, 63);
}
 s_sign_key = session_key;

if(server_flags &amp; NTLMSSP_NEGOTIATE_KEY_EXCH)
{
                result = key_exchange(cryptkey:cs, session_key:session_key, nt_hash:NT_H);
session_key = substr(result, 0, 15);
encrypted_session_key = substr(result, 16, 31);

        ## session_key is used as signing key
        ## signing key is encrypted RC4 and sent to server as encrypted_session_key
        sign_key = session_key;
        session_key = encrypted_session_key;
}

 lm_resplen = strlen(lm);
 ntlm_resplen = strlen(nt);
 lmoff = 64;
 ntlmoff = lmoff + lm_resplen;

 lm_resp_hi = lm_resplen / 256;
 lm_resp_lo = lm_resplen % 256;

 ntlm_resp_hi = ntlm_resplen / 256;
 ntlm_resp_lo = ntlm_resplen % 256;

 lmoff_hi = lmoff / 256;
 lmoff_lo = lmoff % 256;

 ntlmoff_hi = ntlmoff / 256;
 ntlmoff_lo = ntlmoff % 256;

 lm_resp_length = raw_string(lm_resp_lo) + raw_string(lm_resp_hi); # length 2 bytes
 ntlm_resp_length = raw_string(ntlm_resp_lo) + raw_string(ntlm_resp_hi); # length 2 bytes
 lm_resp_offset = raw_string(lmoff_lo) + raw_string(lmoff_hi) + raw_string(0x00, 0x00); # offset 4 bytes
 ntlm_resp_offset = raw_string(ntlmoff_lo) + raw_string(ntlmoff_hi) + raw_string(0x00, 0x00); # offset 4 bytes

 workstname = &quot;&quot;;
 user = login;

 username = insert_hexzeros(in:login);
 wsdomain = insert_hexzeros(in:domain);
 wsname = insert_hexzeros(in:workstname);

 wsdomlen = (strlen(wsdomain));
 wsnmlen = (strlen(wsname));
 usernmlen = (strlen(username));
 wsdomainoff = ntlmoff + ntlm_resplen;
 usernameoff = wsdomainoff + wsdomlen;
 wsnameoff = usernameoff + usernmlen;

 wsdomain_hi = wsdomlen / 256;
 wsdomain_lo = wsdomlen % 256;

 wsname_hi = wsnmlen / 256;
 wsname_lo = wsnmlen % 256;

 username_hi = usernmlen / 256;
 username_lo = usernmlen % 256;

 wsdomoffset_hi = wsdomainoff / 256;
 wsdomoffset_lo = wsdomainoff % 256;

 wsnameoffset_hi = wsnameoff / 256;
 wsnameoffset_lo = wsnameoff % 256;

 usernameoffset_hi = usernameoff / 256;
 usernameoffset_lo = usernameoff % 256;

 wsdomainlen = raw_string(wsdomain_lo) + raw_string(wsdomain_hi); # length 2 bytes
 wsnamelen = raw_string(wsname_lo) + raw_string(wsname_hi); # length 2 bytes

 usernamelen = raw_string(username_lo) + raw_string(username_hi); # length 2 bytes
 usernameoffset = raw_string(usernameoffset_lo) + raw_string(usernameoffset_hi) + raw_string(0x00, 0x00);

 wsdomainoffset = raw_string(wsdomoffset_lo) + raw_string(wsdomoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes
 wsnameoffset = raw_string(wsnameoffset_lo) + raw_string(wsnameoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes

# encrypted session key
 sec_key_len = strlen(session_key);
 sec_key_off = wsnameoff + wsnmlen;

 seckey_hi = sec_key_len / 256;
 seckey_lo = sec_key_len % 256;
 seckeyoff_hi = sec_key_off / 256;
 seckeyoff_lo = sec_key_off % 256;

 seckeylength = raw_string(seckey_lo) + raw_string(seckey_hi); # length 2 bytes
 seckeyoffset = raw_string(seckeyoff_lo) + raw_string(seckeyoff_hi) + raw_string(0x00, 0x00); # offset 4 bytes

        os = &quot;Unix&quot;;
	native_os = insert_hexzeros(in:os);
	lanman = &quot;OpenVAS&quot;;
	native_lanmanager = insert_hexzeros(in:lanman);

	#Creating NTLMSSP in Security Blob for the request

        # raw string contains NTLMSSP: sign, type1 msgtype, flags
        ntlmssp = raw_string(0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00,
                             0x03, 0x00, 0x00, 0x00);
        # Lan Manager Response
        ntlmssp += lm_resp_length + lm_resp_length + lm_resp_offset ;

        # NTLM Response
        ntlmssp  +=  ntlm_resp_length + ntlm_resp_length + ntlm_resp_offset;
        ntlmssp  += wsdomainlen + wsdomainlen + wsdomainoffset + usernamelen + usernamelen + usernameoffset + wsnamelen + wsnamelen + wsnameoffset + seckeylength + seckeylength + seckeyoffset;

# adding flags
       ntlmssp += raw_string(0x15, 0x82, 0x08, 0x60);

  #adding NT LM Challenge response
        ntlmssp += lm + nt ;


        # adding workstation domain
         if(wsdomain){
                ntlmssp += toupper(wsdomain);
        }

#adding username
ntlmssp += username;

        #adding workstation name
        ntlmssp += toupper(wsname);


#adding session key
ntlmssp += session_key;

#NTLMSSP length
ntlmssplen = 64 + lm_resplen + ntlm_resplen + wsdomlen + wsnmlen + usernmlen + sec_key_len;

#Security Blob
if(version == 2)
{
   len = ntlmssplen + 12;
   len_hi = len / 256;
   len_lo = len % 256;
               secblob = raw_string(0xa1, 0x82) + raw_string(len_hi) + raw_string(len_lo);
   len = ntlmssplen + 8;
   len_hi = len / 256;
   len_lo = len % 256;
                secblob += raw_string(0x30, 0x82) + raw_string(len_hi) + raw_string(len_lo);
   len = ntlmssplen + 4;
   len_hi = len / 256;
   len_lo = len % 256;
                secblob += raw_string(0xa2, 0x82) + raw_string(len_hi) + raw_string(len_lo);
   len = ntlmssplen;
   len_hi = len / 256;
   len_lo = len % 256;
                secblob += raw_string(0x04, 0x82) + raw_string(len_hi) + raw_string(len_lo) + ntlmssp;
  secbloblen = 16 + ntlmssplen;
}
else
{
  secblob = ntlmssp;
  secbloblen = 12 + ntlmssplen;
}
secbloblen_hi = secbloblen / 256;
secbloblen_lo = secbloblen % 256;
bytecount = secbloblen + 1 + strlen(native_os) + 2 + strlen(native_lanmanager) + 2;
bytecount_hi = bytecount / 256;
bytecount_lo = bytecount % 256;


#Session Setup AndX Request
 st += raw_string(0x19, 0x00);
 st += raw_string(0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00);
 st += raw_string(secbloblen_lo) + raw_string(secbloblen_hi) +
       raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

 st += secblob;

	#length of entire packet
        len = strlen(st);
        len_hi = len / 256;
        len_lo = len % 256;

        stt = raw_string(0x00, 0x00, len_hi, len_lo) + st;

		req = stt;

	send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:1024);

        if(strlen(r) &lt; 9){
                return(FALSE);
        }
    multiplex_id += 1;
	if(ord(r[12])==0){
                return(r);
        }
        else {
                return(FALSE);
        }
 }

 #--------------------NTLMSSP IMPLEMENTATION END---------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_session_setup_NTLMSSP_NEGOT">smb2_session_setup_NTLMSSP_NEGOT</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>domain</dt>
			
		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb2_session_setup_NTLMSSP_NEGOT(soc, domain)
{
   g_mhi = multiplex_id / 256;
   g_mlo = multiplex_id % 256;
   local_var st, wsdomain, wsname, wsdomlen, wsnmlen, wsdomainoff, wsdomain_hi, wsdomain_lo, wsname_hi, wsname_lo;
   local_var wsnameoffset_hi, wsnameoffset_lo, wsname_hi, wsname_lo, wsnameoffset_hi, wsnameoffset_lo;
   #SMB2 header
   st = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

   #Session Setup AndX Request
   st += raw_string(0x19, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x58, 0x00);


   wsdomain = domain;
   wsname = &quot;&quot;;
   wsdomlen = strlen(wsdomain);
   wsnmlen = strlen(wsname);
   wsdomainoff = 32;
   wsnameoff = 32 + wsdomlen;

   wsdomain_hi = wsdomlen / 256;
   wsdomain_lo = wsdomlen % 256;

   wsname_hi = wsnmlen / 256;
   wsname_lo = wsnmlen % 256;

   wsdomoffset_hi = wsdomainoff / 256;
   wsdomoffset_lo = wsdomainoff % 256;

   wsnameoffset_hi = wsnameoff / 256;
   wsnameoffset_lo = wsnameoff % 256;

   local_var wsdomainlen, wsnamelen, wsdomainoffset, wsnameoffset;

    wsdomainlen = raw_string(wsdomain_lo) + raw_string(wsdomain_hi) ; # length 2 bytes
    wsnamelen = raw_string(wsname_lo) + raw_string(wsname_hi); # length 2 bytes
    wsdomainoffset = raw_string(wsdomoffset_lo) + raw_string(wsdomoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes 
    wsnameoffset = raw_string(wsnameoffset_lo) + raw_string(wsnameoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes 

    local_var os, native_os, lanman, native_lanmanager;
    os = &quot;Unix&quot;;
    native_os = insert_hexzeros(in:os);
    lanman = &quot;OpenVAS&quot;;
    native_lanmanager = insert_hexzeros(in:lanman);

     #Creating NTLMSSP in Security Blob for the request

	# raw string contains NTLMSSP: sign, type1 msgtype, flags
	#flags: ntlm2+keyex(0x60088215), ntlm+keyex(0x60008215), ntlm2(0x20088215), ntlm(0x20008215)
	local_var ntlmssp;
        ntlmssp = raw_string(0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00,
                             0x01, 0x00, 0x00, 0x00, 0x15, 0x82, 0x08, 0x60);
	

 #adding workstation domain - length,maxLen,offset and workstation name - length,maxLen,offset
 ntlmssp += wsdomainlen + wsdomainlen + wsdomainoffset + raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
# raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

        # adding workstation domain
        if(wsdomain){
                ntlmssp += toupper(wsdomain);
       }

        #adding workstation name
   #     ntlmssp += toupper(wsname);
	
	local_var ntlmssplen, mechToken, mechType, negTokenInit, spnegolen, spnego, oid, gsslen, sec_blob_length_hi, sec_blob_length_lo;

 ntlmssplen = strlen(ntlmssp);
 mechToken = raw_string(0xa2) + raw_string(ntlmssplen + 2) + raw_string(0x04) + raw_string(ntlmssplen);

 #mechType offset 10, value 1.3.6.1.4.1.311.2.2.10 (NTLMSSP)
        mechType =  raw_string(0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02,
                               0x02, 0x0a);
 #Nogotiation Token Init : 0xa0 negTokenInit Identifier, offset 15, 0x30 seq identifier, offset 12
 negTokenInit = raw_string(0xa0, 0x0e, 0x30, 0x0c);

 spnegolen = 4 + 12 + 4 + ntlmssplen;
 spnego = raw_string(0xa0) + raw_string(spnegolen + 2) + raw_string(0x30) + raw_string(spnegolen);

 # identifier and OID 1.3.6.1.5.5.2 (SPNEGO)
        oid =  raw_string(0x06, 0x06, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x02);

 gsslen = 8 + 4 + spnegolen;
 sec_blob_length_hi = (gsslen + 2) / 256;
        sec_blob_length_lo = (gsslen + 2) % 256;


  #Creating Security Blob for the request
        secblob = raw_string(0x60) + raw_string(gsslen) + oid + spnego + negTokenInit + mechType + mechToken + ntlmssp;

 secblob_len = strlen(secblob);
 secblob_len_hi = secblob_len / 256;
 secblob_len_lo = secblob_len % 256;
 #appending security blob length to the request
 st += raw_string(secblob_len_lo + secblob_len_hi) + raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
 st += secblob ;

 #length of entire packet
 len = strlen(st);
 len_hi = len / 256;
 len_lo = len % 256;

#local_var stt, r;
  stt = raw_string(0x00, 0x00, len_hi, len_lo) + st;

        send(socket:soc, data:stt);
        r = smb_recv(socket:soc, length:1024);

        if(strlen(r) &lt; 9){
                return(FALSE);
        }

        multiplex_id += 1;

        ##More Processing required == 0x16 == 22
        if(ord(r[12])==22){
                return(r);
        }
        else {
                return(FALSE);
        }

 }

function smb_session_setup_NTLMSSP_AUTH(soc, login, password, domain, version, cs, uid, server_flags, addr_list)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_tconx">smb2_tconx</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>name</dt>
			
		
			<dt>share</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb2_tconx(soc, name, share, uid)
 {
   if(ntlmssp_flag)
   {
     response = smb2_tconx_NTLMSSP(soc:soc, name:name, share:share, uid:uid);
     return(response);
   }
   else{
     high = uid / 256;
     low = uid % 256;
     local_var req;
     len = 48 + strlen(name) + strlen(share) + 6;
     ulen = 5 + strlen(name) + strlen(share) + 6;
     req = raw_string(0x00, 0x00, 0x00, len, 0xFF, 0x53, 0x4D, 0x42, 0x75, 0x00,
                      0x00, 0x00, 0x00, 0x08, 0xc8, 0x01, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x28, low, high,
                      0x00, 0x00, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x01, 0x00, ulen, 0x00, 0x00, 0x5C, 0x5C) + name +
                      raw_string(0x5C) + share +raw_string(0x00) + &quot;?????&quot;  +
                      raw_string(0x00);
     send(socket:soc, data:req);
     r = smb_recv(socket:soc, length:1024);
     if(strlen(r) &lt; 10){
			return(FALSE);
		}
		if(ord(r[9])==0){
			return(r);
		}
		else {
                	return(FALSE);
        	}	
	}
 }

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_tconx_NTLMSSP">smb2_tconx_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>name</dt>
			
		
			<dt>share</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb2_tconx_NTLMSSP(soc, name, share, uid)
 {
        local_var req, n, nm, sh;
        n = chomp(name);
        nm = insert_hexzeros(in:n);
        sh = insert_hexzeros(in:share);

        ulen = 8 + strlen(nm) + strlen(sh) + 6;
        len = 43 + ulen;
        #Assuming case: NEGOTIATE_SECURITY_USER_LEVEL enabled
        passlen = 1;
        pwd = &quot;&quot;;

        #TO DO: cases SECURITY_CHALLENGE_RESPONSE or otherwise

        len += passlen;
        ulen += passlen;
        len_hi = len / 256;
        len_lo = len % 256;
        ulen_hi = ulen / 256;
        ulen_lo = ulen % 256;
        passlen_hi = passlen / 256;
        passlen_lo = passlen % 256;
        g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        req = raw_string(0xfe, 0x53, 0x4d, 0x42,
        0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x81, 0x1f);

        if(isSignActive){
                req += raw_string(0x08, 0x00, 0x00, 0x00);
       }
       else
       {
                req += raw_string(0x00, 0x00, 0x00, 0x00);
       }

        req += raw_string(0x00, 0x00, 0x00, 0x00, g_mlo,  g_mhi, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00);

        req += uid + raw_string(0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00);

      tree = raw_string(0x5c, 0x00, 0x5c, 0x00) + nm + raw_string(0x5C, 0x00) + sh ;
      treelen = strlen(tree);
      treelen_hi = treelen / 256;
      treelen_lo = treelen % 256;

      req += raw_string(0x09, 0x00, 0x00, 0x00, 0x48, 0x00, treelen_lo, treelen_hi) + tree ;



#length of entire packet
len = strlen(req);
len_hi = len / 256;
len_lo = len % 256;

     if(isSignActive){

        sig = get_smb2_signature(buf:req, key: sign_key);
        stt = raw_string(0x00, 0x00, len_hi, len_lo) + sig;
     }else {
        stt = raw_string(0x00, 0x00, len_hi, len_lo) + req ;
     }
        send(socket:soc, data:stt);
        r = smb_recv(socket:soc, length:1024);

        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
           ##PDU will arrive late
           r = smb_recv(socket:soc, length:4096);
           status = ord(r[12]);
           status2 = ord(r[13]);
        }
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
        multiplex_id += 1;
        if(isSignActive){
                # verify signature
                seq_number += 1;
                len = strlen(r);

                r_head = substr(r, 0, 3);
                r = substr(r, 4, strlen(r)-1);
                server_resp = get_smb2_signature(buf:r, key: sign_key);
                orig_sign = substr(r, 48, 63);
                serv_sign = substr(server_resp, 48, 63);
                if(orig_sign != serv_sign){
                         return(FALSE);
                }
                else {
                  r = r_head + r ;
                } 
        }
        if(ord(r[12])==0){
                return(r);
        }
        else {
                return(FALSE);
        }

 }

function smb_tconx_cleartext(soc, name, uid, share)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2_tconx_extract_tid">smb2_tconx_extract_tid</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>reply</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb2_tconx_extract_tid(reply)
 {
   if(strlen(reply) &lt; 30){
   return(FALSE);
   }

   start = stridx(reply, &quot;SMB&quot;);
   start = 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 8 + 4;
   #NTLMSSP tid is 4 bytes in size
   tid = (substr(reply, start, start+3));
   return (tid);
 }


 #--------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2ntcreatex">smb2ntcreatex</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>always_return_blob</dt>
			
		
			<dt>name</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb2ntcreatex(soc, uid, tid, name, always_return_blob)
{
  if(ntlmssp_flag)
  {
    response = smb2ntcreatex_NTLMSSP(soc:soc, uid:uid, tid:tid, name:name, always_return_blob:always_return_blob);
    return(response);
  }
  else
  {
    tid_high = tid / 256;
    tid_low  = tid % 256;

     uid_high = uid / 256;
     uid_low  = uid % 256;

     req = raw_string(0xFF, 0x53, 0x4D, 0x42, 0xA2, 0x00,
                      0x00, 0x00, 0x00, 0x18, 0x03, 0x00, 0x50, 0x81,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, tid_low, tid_high, 0x00, 0x28, uid_low, uid_high,
                      g_mlo, g_mhi, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00,
                      0x07, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x9F, 0x01, 0x02, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
                      0x00, 0x00, 0x00, (strlen(name)+1) % 256, 0x00) + name +
                      raw_string(0x00);

     req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + req;

       send(socket:soc, data:req);
       r = smb_recv(socket:soc, length:4000);
       if(always_return_blob){
                return r;
        }
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
       if(ord(r[9])==0x00){
                return(r);
        }
        else {
                return(FALSE);
        }

 }
 }

 function smbntcreatex(soc, uid, tid, name, always_return_blob)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2ntcreatex_NTLMSSP">smb2ntcreatex_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>always_return_blob</dt>
			
		
			<dt>name</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb2ntcreatex_NTLMSSP(soc, uid, tid, name, always_return_blob)
 {
        g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;
        name_le = strlen(name);
       name =  substr(name, 1, name_le-1);
        uc = unicode(data:name);


        req = raw_string(0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x60, 0x1f);

        if(isSignActive){
                       req += raw_string(0x08, 0x00, 0x00, 0x00);
        }
        else
        {
                req += raw_string(0x00, 0x00, 0x00, 0x00);
        }

            req += raw_string(0x00, 0x00, 0x00, 0x00,
                         g_mlo, g_mhi, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, tid, uid);

        ##Signature
        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
        namelen = strlen(name)+1;
        name_hi = namelen / 256;
        name_lo = namelen % 256;
        req += raw_string(0x39, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x9f, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
                          0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x40,
                          0x00, 0x40, 0x00, 0x78, 0x00, 0x0c, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
                          + uc;

    if(isSignActive)
    {
         sig = get_smb2_signature(buf:req, key: sign_key);
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + sig;
    }
    else{
         req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + req ;
    }
	
 	send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4000);

        ##If status is pending
        ##if status is pending , wait for response
        status = ord(r[12]);
        status2 = ord(r[13]);
        while(status == 3 &amp;&amp; status2 == 1)
        {
          ##PDU will arrive late
          r = smb_recv(socket:soc, length:4096);
          status = ord(r[12]);
          status2 = ord(r[13]);
        }
        if(always_return_blob){
                return(r);
        }
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
	multiplex_id += 1;
        if(isSignActive){
                # verify signature
                seq_number += 1;
                
                r_head = substr(r, 0, 3);
                r = substr(r, 4, strlen(r)-1);
                orig_sign = substr(r, 48, 63);
                server_resp = get_smb2_signature(buf:r, key: sign_key);
                serv_sign = substr(server_resp, 48, 63);
                if(orig_sign != serv_sign){
                         return(FALSE);
                }
                else {
                  r = r_head + r ;
                }
        }

        if(ord(r[12])==0){
                return(r);
        }
        else {
                return(FALSE);
        }
 }

 #--------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb2ntcreatex_extract_pipe">smb2ntcreatex_extract_pipe</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>reply</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb2ntcreatex_extract_pipe(reply)
 {
    start = stridx(reply, &quot;SMB&quot;);
    start = 64 + 64 + 4;
    #NTLMSSP challenge is 8 bytes in size
    ret = (substr(reply, start, start+15));
    return (ret);
 }


 #---------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_close_request">smb_close_request</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>fid</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_close_request(soc, uid, tid, fid)
 {
  if (strlen(uid) == 8)
  {
  ret = smb2_close_request(soc:soc, uid:uid, tid:tid, fid:fid);
  return(ret);
  }
  else{
  ret =  smb1_close_request(soc:soc, uid:uid, tid:tid, fid:fid);
  return(ret);
  }
}

function smb2_close_request(soc, uid, tid, fid)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_get_file_size">smb_get_file_size</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>fid</dt>
			
		
			<dt>socket</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_get_file_size(socket, uid, tid, fid)
 {
	if(ntlmssp_flag)
  {
   if (strlen(uid) == 8)
   {
      response = smb2_get_file_size_NTLMSSP(socket:socket, uid:uid, tid:tid, fid:fid);
      return(response);
   }
   else{
     response = smb1_get_file_size_NTLMSSP(socket:socket, uid:uid, tid:tid, fid:fid);
     return(response);
   }

 	local_var r, req, uid_lo, uid_hi, tid_lo, tid_hi, fid_lo, fid_hi, ret;
 
	uid_lo = uid % 256; uid_hi = uid / 256;
	tid_lo = tid % 256; tid_hi = tid / 256;
	fid_lo = fid % 256; fid_hi = fid / 256;
 
 	req = raw_string(0x00, 0x00, 0x00, 0x48, 0xFF, 0x53,
 			 0x4D, 0x42, 0x32, 0x00, 0x00, 0x00, 0x00, 0x08,
			 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, tid_lo, tid_hi,
			 0x00, 0x28, uid_lo, uid_hi, g_mlo, g_mhi, 0x0F, 0x04,
			 0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x11, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x00, 0x48,
			 0x00, 0x01, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00,
			 0x44, 0x20, fid_lo, fid_hi, 0x07, 0x01);

	send(socket:socket, data:req);
	r = smb_recv(socket:socket, length:4096);
	if(strlen(r) &lt; 112){
		return -1;
	}
 
	ret = ord(r[115]);			
	ret = ret * 256 + ord(r[114]);		
	ret = ret * 256 + ord(r[113]);
	ret = ret * 256 + ord(r[112]);		
 	return ret;
 }

}
 #

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_get_systemroot">smb_get_systemroot</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb_get_systemroot() {

  local_var sroot, key, item;

  if(sroot = get_kb_item(&quot;SMB/SystemRoot&quot;))return sroot;

  key   = &quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\&quot;;

  if(!registry_key_exists(key:key)){
    return FALSE;
  }
  item  = &quot;SystemRoot&quot;;
  sroot = registry_get_sz(item:item, key:key);

  if(!isnull(sroot)) {
    set_kb_item(name:&quot;SMB/SystemRoot&quot;, value: sroot);
    return sroot;
  } else {
    return FALSE;
  }  
}  



		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot">smb_neg_prot</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot(soc)
 {
   
   if(ntlmssp_flag)
   {
     if(defined_func(&quot;ntlm2_response&quot;)){
               return(smb_neg_prot_NTLMSSP(soc:soc));
     }
   else{
       ntlmssp_flag = 0;
      }
   }
      return(smb_neg_prot_NTLMv1(soc:soc));
 }

 function smb_neg_prot_value(prot){

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot_NTLMSSP">smb_neg_prot_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot_NTLMSSP(soc)
 {
   local_var neg_prot, r;
   #constructing SMB header, also incudes the message type and length
   g_mhi = multiplex_id / 256;
   g_mlo = multiplex_id % 256;
   neg_prot = raw_string(0x00, 0x00, 0x00, 0xd4, 0xff, 0x53, 0x4d, 0x42,
                         0x72, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0xc8,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x33, 0x0c,
                         0x00, 0x00, g_mlo, g_mhi);

   #constructing negotiation protocol request
   #Requested Dialects:
   #Dialect: PC NETWORK PROGRAM 1.0
   #Dialect: MICROSOFT NETWORKS 1.03
   #Dialect: MICROSOFT NETWORKS 3.0
   # Dialect: LANMAN1.0
   # Dialect: LM1.2X002
   # Dialect: DOS LANMAN2.1
   # Dialect: LANMAN2.1
   # Dialect: Samba
   # Dialect: NT LANMAN 1.0
   # Dialect: NT LM 0.12
   # Dialect: SMB 2.002
   # Dialect: SMB 2.???

   neg_prot += raw_string(0x00, 0xb1, 0x00, 0x02, 0x50, 0x43, 0x20, 0x4e,
                          0x45, 0x54, 0x57, 0x4f, 0x52, 0x4b, 0x20, 0x50,
                          0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x20, 0x31,
                          0x2e, 0x30, 0x00, 0x02, 0x4d, 0x49, 0x43, 0x52,
                          0x4f, 0x53, 0x4f, 0x46, 0x54, 0x20, 0x4e, 0x45,
                          0x54, 0x57, 0x4f, 0x52, 0x4b, 0x53, 0x20, 0x31,
                          0x2e, 0x30, 0x33, 0x00, 0x02, 0x4d, 0x49, 0x43,
                          0x52, 0x4f, 0x53, 0x4f, 0x46, 0x54, 0x20, 0x4e,
                          0x45, 0x54, 0x57, 0x4f, 0x52, 0x4b, 0x53, 0x20,
                          0x33, 0x2e, 0x30, 0x00, 0x02, 0x4c, 0x41, 0x4e,
                          0x4d, 0x41, 0x4e, 0x31, 0x2e, 0x30, 0x00, 0x02,
                          0x4c, 0x4d, 0x31, 0x2e, 0x32, 0x58, 0x30, 0x30,
                          0x32, 0x00, 0x02, 0x44, 0x4f, 0x53, 0x20, 0x4c,
                          0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x32, 0x2e, 0x31,
                          0x00, 0x02, 0x4c, 0x41, 0x4e, 0x4d, 0x41, 0x4e,
                          0x32, 0x2e, 0x31, 0x00, 0x02, 0x53, 0x61, 0x6d,
                          0x62, 0x61, 0x00, 0x02, 0x4e, 0x54, 0x20, 0x4c,
                          0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x20, 0x31, 0x2e,
                          0x30, 0x00, 0x02, 0x4e, 0x54, 0x20, 0x4c, 0x4d,
                          0x20, 0x30, 0x2e, 0x31, 0x32, 0x00, 0x02, 0x53,
                          0x4d, 0x42, 0x20, 0x32, 0x2e, 0x30, 0x30, 0x32,
                          0x00, 0x02, 0x53, 0x4d, 0x42, 0x20, 0x32, 0x2e,
                          0x3f, 0x3f, 0x3f, 0x00);

   send(socket:soc, data:neg_prot);
   r = smb_recv(socket:soc, length:4000);
        if(strlen(r) &lt; 38){
                return(NULL);
        }

   multiplex_id += 1;
   local_var sec_mode;
   sec_mode = smb_neg_prot_sm(prot:r);

   if(sec_mode == 7){
     ##server supports signatured PDUs
     NEGOTIATE_SECURITY_SIGNATURES_ENABLED = TRUE;
   }
   else if(sec_mode == 15){
     ##server requires signatured PDUs
     NEGOTIATE_SECURITY_SIGNATURES_REQUIRED = TRUE;
     NEGOTIATE_SECURITY_SIGNATURES_ENABLED = TRUE;
   }
   else if(smb == &quot;SMB2&quot; &amp;&amp; sec_mode == 3){
     ##server requires signatured PDUs
     NEGOTIATE_SECURITY_SIGNATURES_REQUIRED_v2 = TRUE; 
     NEGOTIATE_SECURITY_SIGNATURES_ENABLED_v2 = TRUE;
   }
   else if(smb == &quot;SMB2&quot; &amp;&amp; sec_mode == 1){
     ##server supports signatured PDUs
     NEGOTIATE_SECURITY_SIGNATURES_ENABLED_v2 = TRUE;
   }

   ##old openvas, where get_smb2_signature function is not present
   if(defined_func(&#39;get_smb2_signature&#39;)){
     SHA256 = 1;
   }
   else{
     SHA256 = &quot;&quot;;
   }

   ##old openvas where get_smb2_signature function is not present, and server requires signatured PDUs only, send smb1 req only
   if(!SHA256)
   {
     ##get_smb2_signature function is not present, send smb1 req only
     if((smb == &quot;SMB2&quot;) &amp;&amp; (NEGOTIATE_SECURITY_SIGNATURES_REQUIRED_v2 &amp;&amp; NEGOTIATE_SECURITY_SIGNATURES_ENABLED_v2))
     {
       local_var neg_prot, r;
     #constructing SMB header, also incudes the message type and length
     g_mhi = multiplex_id / 256;
     g_mlo = multiplex_id % 256;
     neg_prot = raw_string(0x00, 0x00, 0x00, 0xbe,
                           0xff, 0x53, 0x4d, 0x42, 0x72, 0x00, 0x00, 0x00, 0x00,
                           0x08, 0x01, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x33,
                           0x0c, 0x00, 0x00, g_mlo, g_mhi);
    #constructing negotiation protocol request
    #Requested Dialects: 
    #       Dialect: PC NETWORK PROGRAM 1.0
    #       Dialect: MICROSOFT NETWORKS 1.03
    #       Dialect: MICROSOFT NETWORKS 3.0
    #       Dialect: LANMAN1.0
    #       Dialect: LM1.2X002
    #       Dialect: DOS LANMAN2.1
    #       Dialect: LANMAN2.1
    #       Dialect: Samba
    #       Dialect: NT LANMAN 1.0
    #       Dialect: NT LM 0.12
            neg_prot += raw_string(0x00, 0x9b, 0x00, 0x02, 0x50, 0x43, 0x20, 0x4e,
                                   0x45, 0x54, 0x57, 0x4f, 0x52, 0x4b, 0x20, 0x50,
                                   0x52, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x20, 0x31,
                                   0x2e, 0x30, 0x00, 0x02, 0x4d, 0x49, 0x43, 0x52,
                                   0x4f, 0x53, 0x4f, 0x46, 0x54, 0x20, 0x4e, 0x45,
                                   0x54, 0x57, 0x4f, 0x52, 0x4b, 0x53, 0x20, 0x31,
                                   0x2e, 0x30, 0x33, 0x00, 0x02, 0x4d, 0x49, 0x43,
                                   0x52, 0x4f, 0x53, 0x4f, 0x46, 0x54, 0x20, 0x4e,
                                   0x45, 0x54, 0x57, 0x4f, 0x52, 0x4b, 0x53, 0x20,
                                   0x33, 0x2e, 0x30, 0x00, 0x02, 0x4c, 0x41, 0x4e,
                                   0x4d, 0x41, 0x4e, 0x31, 0x2e, 0x30, 0x00, 0x02,
                                   0x4c, 0x4d, 0x31, 0x2e, 0x32, 0x58, 0x30, 0x30,
                                   0x32, 0x00, 0x02, 0x44, 0x4f, 0x53, 0x20, 0x4c,
                                   0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x32, 0x2e, 0x31,
                                   0x00, 0x02, 0x4c, 0x41, 0x4e, 0x4d, 0x41, 0x4e,
                                   0x32, 0x2e, 0x31, 0x00, 0x02, 0x53, 0x61, 0x6d,
                                   0x62, 0x61, 0x00, 0x02, 0x4e, 0x54, 0x20, 0x4c,
                                   0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x20, 0x31, 0x2e,
                                   0x30, 0x00, 0x02, 0x4e, 0x54, 0x20, 0x4c, 0x4d,
                                   0x20, 0x30, 0x2e, 0x31, 0x32, 0x00);

    if(soc){
      close(soc);
    }

    port = kb_smb_transport();
    if(!port){
        port = 139;
    }

    soc = open_sock_tcp(port);
    if(!soc){
      return(NULL);
    }

    send(socket:soc, data:neg_prot);
    r = smb_recv(socket:soc, length:4000);
    if(strlen(r) &lt; 38){
      return(NULL);
    }
    multiplex_id += 1;
    local_var sec_mode;
    sec_mode = smb_neg_prot_sm(prot:r);
    if(sec_mode == 7){
         NEGOTIATE_SECURITY_SIGNATURES_ENABLED = TRUE;
       }
       else if(sec_mode == 15){
         NEGOTIATE_SECURITY_SIGNATURES_REQUIRED = TRUE;
         NEGOTIATE_SECURITY_SIGNATURES_ENABLED = TRUE;
       }
       if(sec_mode &amp;&amp; (NEGOTIATE_SECURITY_SIGNATURES_ENABLED &amp;&amp; NEGOTIATE_SECURITY_SIGNATURES_REQUIRED)){
         isSignActive = 1;
       }
       else {
         isSignActive = 0;
       }
       if(ord(r[9])==0){
         return(string(r));
       }
       else {
         return(NULL);
       }
     }

   else if((smb == &quot;SMB2&quot;) &amp;&amp; (!NEGOTIATE_SECURITY_SIGNATURES_REQUIRED_v2))
   {
       isSignActive = 0;
       if(ord(r[12])==0){
               return(string(r));
       }
       else {
                return(NULL);
       }
   }
 
   else if((smb != &quot;SMB2&quot;) &amp;&amp; (NEGOTIATE_SECURITY_SIGNATURES_REQUIRED &amp;&amp; NEGOTIATE_SECURITY_SIGNATURES_ENABLED))
   {
       isSignActive = 1;
       if(ord(r[9])==0){
                return(string(r));
       }
       else {
               return(NULL);
       }

   }else if((smb != &quot;SMB2&quot;) &amp;&amp; (!NEGOTIATE_SECURITY_SIGNATURES_REQUIRED))
   {
       isSignActive = 0;
       if(ord(r[9])==0){
                return(string(r));
       }
       else {
             return(NULL);
       }
   }
  }
  ##New Openvas which supports get_smb2_signature function
  else if(SHA256)
  {
     if((sec_mode &amp;&amp; (NEGOTIATE_SECURITY_SIGNATURES_ENABLED &amp;&amp; NEGOTIATE_SECURITY_SIGNATURES_REQUIRED)) ||
                (sec_mode &amp;&amp; (NEGOTIATE_SECURITY_SIGNATURES_REQUIRED_v2 &amp;&amp; NEGOTIATE_SECURITY_SIGNATURES_ENABLED_v2)))

    {
      isSignActive = 1;
    }else
    {
     isSignActive = 0;
    }

    # Check For SMB2
    if (ord(r[4]) == 254)
    {
      if(ord(r[12])==0){
        return(string(r));
      }
    }
    ##For SMB1
    else if (ord(r[4]) == 255)
    {
      if(ord(r[9])==0)
      {
        return(string(r));
      }
    }
    else {
        return(NULL);
    }
  }
}

 function smb_neg_prot_NTLMv1(soc)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot_NTLMv1">smb_neg_prot_NTLMv1</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot_NTLMv1(soc)
 {
	local_var neg_prot, r;
 
	neg_prot = raw_string(0x00, 0x00, 0x00, 0xA4, 0xFF, 0x53,
			      0x4D, 0x42, 0x72, 0x00, 0x00, 0x00, 0x00, 0x08,
			      0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			      0x4D, 0x0B, 0x00, 0x00, g_mlo, g_mhi, 0x00, 0x81,
	                      0x00, 0x02) + &quot;PC NETWORK PROGRAM 1.0&quot; +
		   raw_string(0x00, 0x02) + &quot;MICROSOFT NETWORKS 1.03&quot; +
		   raw_string(0x00, 0x02) + &quot;MICROSOFT NETWORKS 3.0&quot;  +
		   raw_string(0x00, 0x02) + &quot;LANMAN1.0&quot; +
		   raw_string(0x00, 0x02) + &quot;LM1.2X002&quot; +
		   raw_string(0x00, 0x02) + &quot;Samba&quot; +
		   raw_string(0x00, 0x02) + &quot;NT LANMAN 1.0&quot; +
		   raw_string(0x00, 0x02) + &quot;NT LM 0.12&quot; +
		   raw_string(0x00);

	send(socket:soc, data:neg_prot);
	r = smb_recv(socket:soc, length:4000);
	if(strlen(r) &lt; 38){
		return(NULL);
	}
	if(ord(r[9])==0){
		return(string(r));
	}
	else {
		return(NULL);
	}
 }

 function smb_neg_prot_anonymous(soc)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot_anonymous">smb_neg_prot_anonymous</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot_anonymous(soc)
 {
        return smb_neg_prot_NTLMv1(soc:soc);
 }

 function smb_neg_prot(soc)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot_cleartext">smb_neg_prot_cleartext</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot_cleartext(soc)
 {
	neg_prot = raw_string(0x00,0x00,
	 		      0x00, 0x89, 0xFF, 0x53, 0x4D, 0x42, 0x72, 0x00,
	 		      0x00, 0x00, 0x00, 0x18, 0x01, 0x20, 0x00, 0x00,
	 		      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		              0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
	 		      g_mlo, g_mhi, 0x00, 0x66, 0x00, 0x02, 0x50, 0x43,
	 		      0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B,
	 		      0x20, 0x50, 0x52, 0x4F, 0x47, 0x52, 0x41, 0x4D,
	 	              0x20, 0x31, 0x2E, 0x30, 0x00, 0x02, 0x4D, 0x49,
	 		      0x43, 0x52, 0x4F, 0x53, 0x4F, 0x46, 0x54, 0x20,
			      0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B, 0x53,
			      0x20, 0x31, 0x2E, 0x30, 0x33, 0x00, 0x02, 0x4D,
			      0x49, 0x43, 0x52, 0x4F, 0x53, 0x4F, 0x46, 0x54,
			      0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B,
			      0x53, 0x20, 0x33, 0x2e, 0x30, 0x00, 0x02, 0x4c,
			      0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x31, 0x2e, 0x30,
			      0x00, 0x02, 0x4c, 0x4d, 0x31, 0x2e, 0x32, 0x58,
			      0x30, 0x30, 0x32, 0x00, 0x02, 0x53, 0x61, 0x6d,
			      0x62, 0x61, 0x00);
	send(socket:soc, data:neg_prot);
	r = smb_recv(socket:soc, length:4000);
	if(strlen(r) &lt; 10){
		return(FALSE);
	}
	if(ord(r[9])==0){
		return(r);
	}
	else {
		return(FALSE);
	}
 }

 function smb_neg_prot_NTLMSSP(soc)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot_cs">smb_neg_prot_cs</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>prot</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot_cs(prot){
   if(smb_neg_prot_value(prot:prot) &lt; 7){
    return NULL;
   }
   return(substr(prot, 73, 73 + 7));
 }

 function smb_neg_prot_sm(prot){

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot_domain">smb_neg_prot_domain</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>prot</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot_domain(prot)
 {
	local_var i, ret;
	ret = NULL;
	for(i=81; i&lt;strlen(prot); i+=2)
	{
		if(ord(prot[i]) == 0) break;
		else ret += prot[i];
	}
	return ret;
 }

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot_sm">smb_neg_prot_sm</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>prot</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot_sm(prot){
    if(smb_neg_prot_value(prot:prot) &lt; 7){
             return(NULL);
    }
    local_var sm, sec_mode_hex, sec_mode;
    if(ord(prot[4]) == 254){
      smb = &quot;SMB2&quot;;
      sm = substr(prot, 70, 70);
      sec_mode_hex = hexstr(sm);
      sec_mode = hextodec(str:sec_mode_hex);
      return(sec_mode);
    }
    else{
      sm = substr(prot, 39, 39);
      sec_mode_hex = hexstr(sm);
      sec_mode = hextodec(str:sec_mode_hex);
      return(sec_mode);
    }
 }

 function smb_neg_prot_domain(prot)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_neg_prot_value">smb_neg_prot_value</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>prot</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_neg_prot_value(prot){
     if(ord(prot[4]) == 254)
     {
         negotiated_prot_l = ord(prot[72]);
         negotiated_prot_h =  ord(prot[73]);
         if(negotiated_prot_h){
             value = negotiated_prot_h*256;
             value = value + negotiated_prot_l;
         }else{
           value = negotiated_prot_l;
         }  
        return(value);
     }
     else{
       return(ord(prot[37]));
     }
 }

 function smb_neg_prot_cs(prot){

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_recv">smb_recv</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>length</dt>
			
		
			<dt>socket</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_recv(socket, length)
 {
	local_var header, len, trailer;

	header = recv(socket:socket, length:4, min:4);
	if(strlen(header) &lt; 4){
		return(NULL);
	}
	len = 256 * ord(header[2]);
	len += ord(header[3]);
	if(len == 0){
		return(header);
	}
   	trailer = recv(socket:socket, length:len, min:len);
   	if(strlen(trailer) &lt; len){
		return(NULL);
	}
   	return strcat(header, trailer);
 }

 #-----------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_request">smb_session_request</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>remote</dt>
			
		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_session_request(soc, remote)
 {
   trp = kb_smb_transport();
   # We don&#39;t need to request a session when talking on top of
   # port 445
   if(trp == 445){
   return(TRUE);
   }

  nb_remote = netbios_name(orig:remote);
  nb_local  = netbios_redirector_name();

  session_request = raw_string(0x81, 0x00, 0x00, 0x44) +
                    raw_string(0x20) + nb_remote + raw_string(0x00, 0x20) +
                    nb_local + raw_string(0x00);
  send(socket:soc, data:session_request);
  r = smb_recv(socket:soc, length:4000);
  if(ord(r[0])==0x82){
   return(r);
  }

  else {
    return(FALSE);
   }
 }

 #------------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup">smb_session_setup</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>domain</dt>
			
		
			<dt>login</dt>
			
		
			<dt>password</dt>
			
		
			<dt>prot</dt>
			
		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_session_setup(soc, login, password, domain, prot)
 {
   local_var ct, ret, ntlmv1, cs, flags, flg_str, uid;

   ct = get_kb_item(&quot;SMB/dont_send_in_cleartext&quot;);
   ntlmv1 = get_kb_item(&quot;SMB/dont_send_ntlmv1&quot;);

   if(smb_neg_prot_value(prot:prot) &lt; 7 )
   {
     if(ct == &quot;yes&quot;){
      return NULL;
     }
     else {
      return smb_session_setup_cleartext(soc:soc, login:login,
              password:password, domain:domain);
     }
     ntlmssp_flag = 0;
   }
   else{
     if(ntlmssp_flag)
     {
       # Check For SMB2
       if (ord(prot[4]) == 254)
       {
         prot2 = smb2_neg_prot(soc:soc);
         if(!prot2){
           close(soc);
           return(login_defined);
         }

         r = smb2_session_setup(soc:soc, login:login, password:password,
                             domain:domain, prot:prot2);
           return(r);
       }
       else{
        #Step 1: Negotiation
        ret = smb_session_setup_NTLMSSP_NEGOT(soc:soc, domain:domain);

        #Step 2:  Read the server challenge from response ret
        cs = smb_session_setup_NTLMSSP_extract_chal(ret);	

        #Step 3: Authentication
        flags = smb_session_setup_NTLMSSP_extract_flag(ret);
        flg_str = smb_session_setup_NTLMSSP_auth_flags(neg_flags:flags);
        uid = session_extract_uid(reply:ret);
        if(!uid){
             return(FALSE);
        }
        local_var addr_list;
        addr_list = smb_session_setup_NTLMSSP_extract_addrlist(ret);
        # call the function to get address list from type 2 message
        if(ntlmv2_flag){
          ret = smb_session_setup_NTLMSSP_AUTH(soc:soc, login:login, password:password,
               domain:domain, version:2, cs:cs, uid:uid, server_flags:flags, flag_str:flg_str, addr_list:addr_list);
        }
        else{
          ret = smb_session_setup_NTLMSSP_AUTH(soc:soc, login:login, password:password,
                  domain:domain, version:2, cs:cs, uid:uid, server_flags:flags, flag_str:flg_str, addr_list:addr_list);
          if(!ret){
             ret = smb_session_setup_NTLMSSP_AUTH(soc:soc, login:login, password:password,
                   domain:domain, version:1, cs:cs, uid:uid, server_flags:flags, flag_str:flg_str, addr_list:addr_list);
          }
        }
        return(ret);
       }
     }
     else
     {
       ret = smb_session_setup_NTLMvN(soc:soc, login:login, password:password,
              domain:domain, cs:smb_neg_prot_cs(prot:prot), version:2);
       if(!ret &amp;&amp; !ntlmv1){
       ret = smb_session_setup_NTLMvN(soc:soc, login:login, password:password,
             domain:domain, cs:smb_neg_prot_cs(prot:prot), version:1);
       }
       return(ret);
     }
   }
 }

#SMB2 session setup

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup_NTLMSSP_AUTH">smb_session_setup_NTLMSSP_AUTH</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>addr_list</dt>
			
		
			<dt>cs</dt>
			
		
			<dt>domain</dt>
			
		
			<dt>login</dt>
			
		
			<dt>password</dt>
			
		
			<dt>server_flags</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>uid</dt>
			
		
			<dt>version</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb_session_setup_NTLMSSP_AUTH(soc, login, password, domain, version, cs, uid, server_flags, addr_list)
 {
	local_var lm, nt, encrypted_session_key, st, r, NT_H, session_key;
	if(!domain)
		domain = &quot;WORKGROUP&quot;;
	NTLMSSP_NEGOTIATE_KEY_EXCH = 0x40000000;	
	NTLMSSP_NEGOTIATE_NTLM2 = 0x00080000;
	#SMB header
	g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;
        st = raw_string(0xff, 0x53, 0x4d, 0x42, 0x73, 0x00, 0x00, 0x00,
                        0x00, 0x08);
	if(isSignActive){ 
                st +=  raw_string(0x05, 0xc8);
        }
        else{
                st += raw_string(0x01, 0xc8);
	}

	st += raw_string(0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x33, 0x0c);
	#user id
	uid_hi = uid / 256;
	uid_lo = uid % 256;
	st += raw_string(uid_lo) + raw_string(uid_hi);	

	#multiplex id
	st += raw_string(g_mlo, g_mhi);

	if(version == 2)
	{
		NT_H = nt_owf_gen(password);
		ntlmv2_hash = ntv2_owf_gen(owf:NT_H, login:login, domain:domain);
		addr_list_len = strlen(addr_list);
		result = ntlmv2_response(cryptkey:cs, user:login, domain:domain, ntlmv2_hash:ntlmv2_hash, address_list:addr_list, address_list_len:addr_list_len);
                lm = substr(result, 0, 23);
                session_key = substr(result, 24, 39);
                nt = substr(result, 40, strlen(result)-1);
	}
	else if(server_flags &amp; NTLMSSP_NEGOTIATE_NTLM2)
	{
		#nt hash
        	NT_H = nt_owf_gen(password);
        	result = ntlm2_response(cryptkey:cs, password:password, nt_hash:NT_H);
        	lm = substr(result, 0, 23);
        	nt = substr(result, 24, 47);
		session_key = substr(result, 48, 63);
	}
	else
	{
		#nt hash
                NT_H = nt_owf_gen(password);
                result = ntlm_response(cryptkey:cs, password:password, nt_hash:NT_H, neg_flags:server_flags);
                lm = substr(result, 0, 23);
                nt = substr(result, 24, 47);
                session_key = substr(result, 48, 63);
	}
	if(server_flags &amp; NTLMSSP_NEGOTIATE_KEY_EXCH)
	{
                result = key_exchange(cryptkey:cs, session_key:session_key, nt_hash:NT_H);
		session_key = substr(result, 0, 15);
		encrypted_session_key = substr(result, 16, 31);
	}
	s_sign_key = session_key;
	lm_resplen = strlen(lm);
	ntlm_resplen = strlen(nt);
	lmoff = 64;
	ntlmoff = lmoff + lm_resplen;

	lm_resp_hi = lm_resplen / 256;
	lm_resp_lo = lm_resplen % 256;

	ntlm_resp_hi = ntlm_resplen / 256;
	ntlm_resp_lo = ntlm_resplen % 256;
	
	lmoff_hi = lmoff / 256;
	lmoff_lo = lmoff % 256;

	ntlmoff_hi = ntlmoff / 256;
	ntlmoff_lo = ntlmoff % 256;

	lm_resp_length = raw_string(lm_resp_lo) + raw_string(lm_resp_hi); # length 2 bytes
	ntlm_resp_length = raw_string(ntlm_resp_lo) + raw_string(ntlm_resp_hi); # length 2 bytes
	lm_resp_offset = raw_string(lmoff_lo) + raw_string(lmoff_hi) + raw_string(0x00, 0x00); # offset 4 bytes
	ntlm_resp_offset = raw_string(ntlmoff_lo) + raw_string(ntlmoff_hi) + raw_string(0x00, 0x00); # offset 4 bytes



	workstname = &quot;HostName&quot;;
	user = login;

	username = insert_hexzeros(in:login);
	wsdomain = insert_hexzeros(in:domain);
	wsname = insert_hexzeros(in:workstname);

        wsdomlen = (strlen(wsdomain));
        wsnmlen = (strlen(wsname));
	usernmlen = (strlen(username));	

        wsdomainoff = ntlmoff + ntlm_resplen;
	usernameoff = wsdomainoff + wsdomlen; 
        wsnameoff = usernameoff + usernmlen;

        wsdomain_hi = wsdomlen / 256;
        wsdomain_lo = wsdomlen % 256;

        wsname_hi = wsnmlen / 256;
        wsname_lo = wsnmlen % 256;

	username_hi = usernmlen / 256;
	username_lo = usernmlen % 256;

        wsdomoffset_hi = wsdomainoff / 256;
        wsdomoffset_lo = wsdomainoff % 256;

        wsnameoffset_hi = wsnameoff / 256;
        wsnameoffset_lo = wsnameoff % 256;

	usernameoffset_hi = usernameoff / 256;
	usernameoffset_lo = usernameoff % 256;

        wsdomainlen = raw_string(wsdomain_lo) + raw_string(wsdomain_hi); # length 2 bytes
        wsnamelen = raw_string(wsname_lo) + raw_string(wsname_hi); # length 2 bytes
	usernamelen = raw_string(username_lo) + raw_string(username_hi); # length 2 bytes
        wsdomainoffset = raw_string(wsdomoffset_lo) + raw_string(wsdomoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes
        wsnameoffset = raw_string(wsnameoffset_lo) + raw_string(wsnameoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes
	usernameoffset = raw_string(usernameoffset_lo) + raw_string(usernameoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes
	
	# encrypted session key
	sec_key_len = 16;
	sec_key_off = wsnameoff + wsnmlen;

	seckey_hi = sec_key_len / 256;
	seckey_lo = sec_key_len % 256;
	seckeyoff_hi = sec_key_off / 256;
	seckeyoff_lo = sec_key_off % 256;

	seckeylength = raw_string(seckey_lo) + raw_string(seckey_hi); # length 2 bytes
	seckeyoffset = raw_string(seckeyoff_lo) + raw_string(seckeyoff_hi) + raw_string(0x00, 0x00); # offset 4 bytes

        os = &quot;Unix&quot;;
	native_os = insert_hexzeros(in:os);
	lanman = &quot;OpenVAS&quot;;
	native_lanmanager = insert_hexzeros(in:lanman);

	#Creating NTLMSSP in Security Blob for the request

        # raw string contains NTLMSSP: sign, type1 msgtype, flags
        ntlmssp = raw_string(0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00,
                             0x03, 0x00, 0x00, 0x00) + 
			     lm_resp_length + lm_resp_length + lm_resp_offset +
			     ntlm_resp_length + ntlm_resp_length + ntlm_resp_offset +
			     wsdomainlen + wsdomainlen + wsdomainoffset + 
		             usernamelen + usernamelen + usernameoffset +
			     wsnamelen + wsnamelen + wsnameoffset +
		             seckeylength + seckeylength + seckeyoffset +
			     flag_str;


	#adding NT LM Challenge response
        ntlmssp += lm + nt;

        # adding workstation domain
        if(wsdomain){
                ntlmssp += toupper(wsdomain);
        }

	#adding username
	ntlmssp += toupper(username);

        #adding workstation name
        ntlmssp += toupper(wsname);

	#adding session key
	ntlmssp += encrypted_session_key;

	#NTLMSSP length
	ntlmssplen = 64 + lm_resplen + ntlm_resplen + wsdomlen + wsnmlen + usernmlen + sec_key_len;

	#Security Blob
	if(version == 2)
	{
		len = ntlmssplen + 12;
		len_hi = len / 256;
		len_lo = len % 256;
		secblob = raw_string(0xa1, 0x82) + raw_string(len_hi) + raw_string(len_lo);
		len = ntlmssplen + 8;
                len_hi = len / 256;
                len_lo = len % 256;
                secblob += raw_string(0x30, 0x82) + raw_string(len_hi) + raw_string(len_lo);
		len = ntlmssplen + 4;
                len_hi = len / 256;
                len_lo = len % 256;
                secblob += raw_string(0xa2, 0x82) + raw_string(len_hi) + raw_string(len_lo);
		len = ntlmssplen;
                len_hi = len / 256;
                len_lo = len % 256;
                secblob += raw_string(0x04, 0x82) + raw_string(len_hi) + raw_string(len_lo) + ntlmssp;
		secbloblen = 16 + ntlmssplen;
	}
	else
	{
		secblob = raw_string(0xa1, 0x81) + raw_string(ntlmssplen+9) + 
		  	  raw_string(0x30, 0x81) + raw_string(ntlmssplen+6) +
		  	  raw_string(0xa2, 0x81) + raw_string(ntlmssplen+3) +
		  	  raw_string(0x04, 0x81) + raw_string(ntlmssplen) + ntlmssp;	
		secbloblen = 12 + ntlmssplen;
	}
	secbloblen_hi = secbloblen / 256;
	secbloblen_lo = secbloblen % 256;
	bytecount = secbloblen + 1 + strlen(native_os) + 2 + strlen(native_lanmanager) + 2;
	bytecount_hi = bytecount / 256;
	bytecount_lo = bytecount % 256;

	#Session Setup AndX Request
        st += raw_string(0x0c, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x02,
                         0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00);
	st += raw_string(secbloblen_lo) + raw_string(secbloblen_hi) + 
              raw_string(0x00, 0x00, 0x00, 0x00, 0x5c, 0xc0, 0x00, 0x80) + # reserved and capabilities
              raw_string(bytecount_lo) + raw_string(bytecount_hi) +
              secblob + raw_string(0x00) + native_os + raw_string(0x00, 0x00) + native_lanmanager + raw_string(0x00, 0x00);

	#length of entire packet
        len = strlen(st);
        len_hi = len / 256;
        len_lo = len % 256;

        stt = raw_string(0x00, 0x00, len_hi, len_lo) + st;
	if(isSignActive){
		len += 4;
		seq_number = 0;
		req = get_signature(key:s_sign_key, buf:stt, buflen:len, seq_number:seq_number);
	}
	else{
		req = stt;
	}
	send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:1024);
        if(strlen(r) &lt; 9){
                return(FALSE);
        }
	multiplex_id += 1;
	if(isSignActive)
	{
		# verify signature
		seq_number += 1;
		len = strlen(r);
		server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
		orig_sign = substr(r, 18, 23);
		serv_sign = substr(server_resp, 18, 23);
		if(orig_sign != serv_sign){
                         return(FALSE);
                }

	}
	
	if(ord(r[9])==0){
                return(r);
        }
        else {
                return(FALSE);
        }
}


 # SMB2 NTLMSSP AUTHENTICATION

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup_NTLMSSP_NEGOT">smb_session_setup_NTLMSSP_NEGOT</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>domain</dt>
			
		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb_session_setup_NTLMSSP_NEGOT(soc, domain)
 {
	g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;
	local_var st, wsdomain, wsname, wsdomlen, wsnmlen, wsdomainoff, wsdomain_hi, wsdomain_lo, wsname_hi, wsname_lo;
	local_var wsnameoffset_hi, wsnameoffset_lo, wsname_hi, wsname_lo, wsnameoffset_hi, wsnameoffset_lo;
        #SMB header
        st = raw_string(0xff, 0x53, 0x4d, 0x42, 0x73, 0x00, 0x00, 0x00,
                        0x00, 0x08);
	if(isSignActive){
		st +=  raw_string(0x05, 0xc8);
	}
	else{
		st += raw_string(0x01, 0xc8);
	}
	st += raw_string(0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x33, 0x0c, 0x00, 0x00, g_mlo, g_mhi);

        #Session Setup AndX Request
        st += raw_string(0x0c, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x02,
                         0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00);

	
	wsdomain = domain;
	wsname = &quot;HostName&quot;;
	wsdomlen = strlen(wsdomain);
	wsnmlen = strlen(wsname);
	wsdomainoff = 32;
	wsnameoff = 32 + wsdomlen;
	
	wsdomain_hi = wsdomlen / 256;
	wsdomain_lo = wsdomlen % 256;

	wsname_hi = wsnmlen / 256;
	wsname_lo = wsnmlen % 256; 

	wsdomoffset_hi = wsdomainoff / 256;
	wsdomoffset_lo = wsdomainoff % 256;

	wsnameoffset_hi = wsnameoff / 256;
	wsnameoffset_lo = wsnameoff % 256;

	local_var wsdomainlen, wsnamelen, wsdomainoffset, wsnameoffset;
        wsdomainlen = raw_string(wsdomain_lo) + raw_string(wsdomain_hi); # length 2 bytes
        wsnamelen = raw_string(wsname_lo) + raw_string(wsname_hi); # length 2 bytes
        wsdomainoffset = raw_string(wsdomoffset_lo) + raw_string(wsdomoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes 
        wsnameoffset = raw_string(wsnameoffset_lo) + raw_string(wsnameoffset_hi) + raw_string(0x00, 0x00); # offset 4 bytes 

	local_var os, native_os, lanman, native_lanmanager;
	os = &quot;Unix&quot;;
        native_os = insert_hexzeros(in:os);
        lanman = &quot;OpenVAS&quot;;
        native_lanmanager = insert_hexzeros(in:lanman);

	#Creating NTLMSSP in Security Blob for the request

	# raw string contains NTLMSSP: sign, type1 msgtype, flags
	#flags: ntlm2+keyex(0x60088215), ntlm+keyex(0x60008215), ntlm2(0x20088215), ntlm(0x20008215)
	local_var ntlmssp;
        ntlmssp = raw_string(0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00,
                        0x01, 0x00, 0x00, 0x00, 0x15, 0x82, 0x08, 0x60);
	

	#adding workstation domain - length,maxLen,offset and workstation name - length,maxLen,offset
	ntlmssp += wsdomainlen + wsdomainlen + wsdomainoffset + wsnamelen + wsnamelen + wsnameoffset; 

        # adding workstation domain
        if(wsdomain){
                ntlmssp += toupper(wsdomain);
        }

        #adding workstation name
        ntlmssp += toupper(wsname);
	
	local_var ntlmssplen, mechToken, mechType, negTokenInit, spnegolen, spnego, oid, gsslen, sec_blob_length_hi, sec_blob_length_lo;

	ntlmssplen = (16 + 16 + strlen(wsdomain) + strlen(wsname));
	mechToken = raw_string(0xa2) + raw_string(ntlmssplen + 2) + raw_string(0x04) + raw_string(ntlmssplen);

	#mechType offset 10, value 1.3.6.1.4.1.311.2.2.10 (NTLMSSP)                
        mechType =  raw_string(0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02,
                               0x02, 0x0a);
	#Nogotiation Token Init : 0xa0 negTokenInit Identifier, offset 15, 0x30 seq identifier, offset 12
	negTokenInit = raw_string(0xa0, 0x0e, 0x30, 0x0c);

	spnegolen = 4 + 12 + 4 + ntlmssplen;
	spnego = raw_string(0xa0) + raw_string(spnegolen + 2) + raw_string(0x30) + raw_string(spnegolen); 

	# identifier and OID 1.3.6.1.5.5.2 (SPNEGO)
        oid =  raw_string(0x06, 0x06, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x02);	
	
	gsslen = 8 + 4 + spnegolen;

	sec_blob_length_hi = (gsslen + 2) / 256;
        sec_blob_length_lo = (gsslen + 2) % 256;

	byte_count_hi = (gsslen + 2 + strlen(native_os) + 2 + strlen(native_lanmanager) + 2) / 256;	
        byte_count_lo = (gsslen + 2 + strlen(native_os) + 2 + strlen(native_lanmanager) + 2) % 256;

	 #Creating Security Blob for the request
        secblob = raw_string(0x60) + raw_string(gsslen) + oid + spnego + negTokenInit + mechType + mechToken + ntlmssp;

        #appending security blob length to the request
        st += raw_string(sec_blob_length_lo) + raw_string(sec_blob_length_hi);

	#appending reserved and capabilities to the request
        st += raw_string(0x00, 0x00, 0x00, 0x00, 0x5c, 0xc0, 0x00, 0x80);

        #appending byte count to the request
        st += raw_string(byte_count_lo) + raw_string(byte_count_hi);

        #appending security blob, nativeOS, nativeLanManager
        st += secblob + native_os + raw_string(0x00, 0x00) + native_lanmanager + raw_string(0x00, 0x00);

	#length of entire packet
	len = strlen(st);
	len_hi = len / 256;
	len_lo = len % 256;
	
	local_var stt, r;
	stt = raw_string(0x00, 0x00, len_hi, len_lo) + st;

        send(socket:soc, data:stt);
        r = smb_recv(socket:soc, length:1024);
        if(strlen(r) &lt; 9){
                return(FALSE);
        }
	multiplex_id += 1;
        if(ord(r[9])==22){
                return(r);
        }
        else {
                return(FALSE);
        }

 }

# SMB2

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup_NTLMSSP_auth_flags">smb_session_setup_NTLMSSP_auth_flags</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>neg_flags</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_session_setup_NTLMSSP_auth_flags(neg_flags)
 {
        NTLMSSP_NEGOTIATE_UNICODE = 0x00000001;
        NTLMSSP_NEGOTIATE_OEM = 0x00000002;
        NTLMSSP_REQUEST_TARGET = 0x00000004;
        NTLMSSP_NEGOTIATE_SIGN = 0x00000010; # Message integrity
        NTLMSSP_NEGOTIATE_SEAL = 0x00000020; # Message confidentiality
        NTLMSSP_NEGOTIATE_LM_KEY = 0x00000080;
        NTLMSSP_NEGOTIATE_NTLM = 0x00000200;
        NTLMSSP_NEGOTIATE_ALWAYS_SIGN = 0x00008000;
        NTLMSSP_NEGOTIATE_NTLM2 = 0x00080000;
        NTLMSSP_NEGOTIATE_128 = 0x20000000; # 128-bit encryption
        NTLMSSP_NEGOTIATE_KEY_EXCH = 0x40000000;
        NTLMSSP_NEGOTIATE_56 = 0x80000000;

	local_var flags;
        flags = 0;
        if (neg_flags &amp; NTLMSSP_NEGOTIATE_UNICODE) {
                 flags += NTLMSSP_NEGOTIATE_UNICODE;
        } else {
                 flags += NTLMSSP_NEGOTIATE_OEM;
        }

        if (neg_flags &amp; NTLMSSP_NEGOTIATE_LM_KEY) {
                 flags += NTLMSSP_NEGOTIATE_LM_KEY;
        }

        if (neg_flags &amp; NTLMSSP_NEGOTIATE_ALWAYS_SIGN) {
                 flags += NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
        }

        if (neg_flags &amp; NTLMSSP_NEGOTIATE_NTLM2) {
                 flags += NTLMSSP_NEGOTIATE_NTLM2;
        }

        if (neg_flags &amp; NTLMSSP_NEGOTIATE_128) {
                 flags += NTLMSSP_NEGOTIATE_128;
        }

	if (neg_flags &amp; NTLMSSP_NEGOTIATE_56) {
                 flags += NTLMSSP_NEGOTIATE_56;
        }

        if (neg_flags &amp; NTLMSSP_NEGOTIATE_KEY_EXCH) {
                 flags += NTLMSSP_NEGOTIATE_KEY_EXCH;
        }

        if (neg_flags &amp; NTLMSSP_NEGOTIATE_SIGN) {
                 flags += NTLMSSP_NEGOTIATE_SIGN;
        }

        if (neg_flags &amp; NTLMSSP_NEGOTIATE_SEAL) {
                 flags += NTLMSSP_NEGOTIATE_SEAL;
        }

        if (neg_flags &amp; NTLMSSP_NEGOTIATE_NTLM) {
                 flags += NTLMSSP_NEGOTIATE_NTLM;
        }

        if (neg_flags &amp; NTLMSSP_REQUEST_TARGET) {
                flags += NTLMSSP_REQUEST_TARGET;
        }
        new_server_flags = dec2str(num:flags);
        return(new_server_flags);
 }

 #------------------------NTLMSSP utilities end----------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup_NTLMSSP_extract_addrlist">smb_session_setup_NTLMSSP_extract_addrlist</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>ret</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_session_setup_NTLMSSP_extract_addrlist(ret)
 {
	local_var start, end, i;
        local_var addr_list;
        start = stridx(ret, &quot;NTLMSSP&quot;,0);
        # to find address list - length, shift byte postions
        start += 8 + 4; #ntlmssp(8) + message type(4)
        start += 2 + 2 + 4 + 4 + 8 + 8; # domainlen(2) + domain maxlen(2) + offset(4) + flags(4) + challenge(8) + reserved(8);
        addrlist_len_str = ret[start+1];
        addrlist_len_str += ret[start];
        addrlist_len = hextodec(str:(hexstr(addrlist_len_str)));
        # to find address list - offset, shift byte postions
        start += 2 + 2; #address list len(2) + address list max len(2)
        for(i=(start+3); i&gt;(start-1); i--)
        {
                addrlist_offset_str += ret[i];
        }
        addrlist_offset = hextodec(str:(hexstr(addrlist_offset_str)));
        # initializing start to the starting position of address list
        start = stridx(ret, &quot;NTLMSSP&quot;,0) + addrlist_offset;
        end = start + addrlist_len - 1;
        addr_list = substr(ret, start, end);
        return(addr_list);
 }

 #NTLMSSP auth flags (based on server flags)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup_NTLMSSP_extract_chal">smb_session_setup_NTLMSSP_extract_chal</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>ret</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_session_setup_NTLMSSP_extract_chal(ret)
 {
	local_var start;
        start = stridx(ret, &quot;NTLMSSP&quot;,0);
        start += 8 + 4 + 2 + 2 + 4 + 4; #ntlmssp(8) + message type(4) + domainlen(2) + domain maxlen(2) + offset(4) + flags(4)
        #NTLMSSP challenge is 8 bytes in size
        cs = (substr(ret, start, start+7));
        return (cs);
 }


 # NTLMSSP extract server flags from type 2 message

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup_NTLMSSP_extract_flag">smb_session_setup_NTLMSSP_extract_flag</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>ret</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_session_setup_NTLMSSP_extract_flag(ret)
 {
	local_var start, i;
        start = stridx(ret, &quot;NTLMSSP&quot;,0);
        start += 8 + 4 + 2 + 2 + 4; #ntlmssp(8) + message type(4) + domainlen(2) + domain maxlen(2) + offset(4)
        local_var flag, serv_flag, server_flag;
        for(i=(start+3); i&gt;(start-1); i--)
        {
                serv_flag += ret[i];
        }
        #conversion hex to dec
        server_flag = hexstr(serv_flag);
        flag = hextodec(str:server_flag);
        return(flag);
 }

#NTLMSSP extract address list for ntlmv2 auth message

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup_NTLMvN">smb_session_setup_NTLMvN</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>cs</dt>
			
		
			<dt>domain</dt>
			
		
			<dt>login</dt>
			
		
			<dt>password</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>version</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_session_setup_NTLMvN(soc, login, password, domain, cs, version)
 {
 	local_var extra, native_os, native_lanmanager, len, bcc;
 	local_var len_hi, len_lo, bcc_hi_n, bcc_lo;
	local_var plen;
  
	local_var NT_H, LM_H, lm, nt;
	local_var ntlmv2_hash;

	if(version == 1)
  	{
  		if(password)
  		{
  			NT_H = nt_owf_gen(password);
  			LM_H = lm_owf_gen(password);
  
			lm = NTLMv1_HASH(cryptkey:cs, passhash:LM_H);
  			nt = NTLMv1_HASH(cryptkey:cs, passhash:NT_H);
  		}
  	}
  	else 
  	{
    		if(password)
		{
	 		NT_H = nt_owf_gen(password);
	 		ntlmv2_hash = ntv2_owf_gen(owf:NT_H, login:login, domain:domain);
	 		lm = NTLMv2_HASH(cryptkey:cs, passhash:ntlmv2_hash, length:8);
			nt = NTLMv2_HASH(cryptkey:cs, passhash:ntlmv2_hash, length:64);
		}
  	}
  
  	extra = 0;
  	native_os = &quot;Unix&quot;;
  	native_lanmanager = &quot;OpenVAS&quot;;
  	if(!domain)domain = &quot;WORKGROUP&quot;;

  	if(domain){
		extra = 3 + strlen(domain) + strlen(native_os) +
			    strlen(native_lanmanager);
	}
  	else {
		extra = strlen(native_os) + strlen(native_lanmanager) + 2;
	}

  	len = strlen(login) + strlen(lm) + strlen(nt) + 62 + extra;
  	bcc = 1 + strlen(login) + strlen(lm) + strlen(nt) + extra;
  
  	len_hi = len / 256;
  	len_low = len % 256;
  
	bcc_hi = bcc / 256;
	bcc_lo = bcc % 256;
  
	if(password)
	{
  		plen_lm = strlen(lm);
		plen_nt = strlen(nt);
  	}
	else
	{
		plen_lm = 0;
		plen_nt = 0;
		plen = 0;
	}
  
  	pass_len_hi = pass_len / 256;
  	pass_len_lo = pass_len % 256;
  
  	if(!login){
		login=&quot;&quot;;
	}
	if(!password){
		password=&quot;&quot;;
	}
  
  	st = raw_string(0x00,0x00,
    	  		len_hi, len_low, 0xFF, 0x53,
	  		0x4D, 0x42, 0x73, 0x00, 0x00, 0x00, 0x00, 0x08,
	  		0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 		0x00, 0x28, 0x00, 0x00, g_mlo, g_mhi, 0x0D, 0xFF,
			0x00, 0x00, 0x00, 0x00, 0x44, 0x02, 0x00, 0xA0,
			0xF5, 0x00, 0x00, 0x00, 0x00, plen_lm, 0x00, plen_nt,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, bcc_lo, bcc_hi) + lm + nt + toupper(login) + 
	     raw_string(0);

	if(domain){
		st += domain + raw_string(0x00);
	}
	
  	st += native_os + raw_string(0x00) + native_lanmanager + raw_string(0x00);
  	  
  	send(socket:soc, data:st);
	r = smb_recv(socket:soc, length:1024); 
  	if(strlen(r) &lt; 9){
		return(FALSE);
	}
  	if(ord(r[9])==0){
		return(r);
	}
	else {
		return(FALSE);
	}
 }

 function smb_session_setup(soc, login, password, domain, prot)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_session_setup_cleartext">smb_session_setup_cleartext</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>domain</dt>
			
		
			<dt>login</dt>
			
		
			<dt>password</dt>
			
		
			<dt>soc</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smb_session_setup_cleartext(soc, login, password, domain)
 {
  	local_var extra, native_os, native_lanmanager, len, bcc;
  	local_var len_hi, len_lo, bcc_hi_n, bcc_lo;
  	local_var pass_len_hi, pass_len_lo;
  	extra = 0;
  	native_os = &quot;Unix&quot;;
  	native_lanmanager = &quot;OpenVAS&quot;;

  	if(!domain){
		domain = &quot;MYGROUP&quot;;
	}

  	if(domain){
		extra = 3 + strlen(domain) + strlen(native_os) +
			    strlen(native_lanmanager);
	}
  	else {
		extra = strlen(native_os) + strlen(native_lanmanager) + 2;
	}

  	len = strlen(login) + strlen(password) + 57 + extra;
 	bcc = 2 + strlen(login) + strlen(password) + extra;
  
 	len_hi = len / 256;
 	len_low = len % 256;
  
	bcc_hi = bcc / 256;
	bcc_lo = bcc % 256;
  
	pass_len = strlen(password) + 1 ;
	pass_len_hi = pass_len / 256;
	pass_len_lo = pass_len % 256;

  	#if (typeof(login) == &quot;int&quot;)    display(&quot;HORROR! login=&quot;, login, &quot;\n&quot;);
  	#if (typeof(password) == &quot;int&quot;) display(&quot;HORROR! password=&quot;, password, &quot;\n&quot;);
  	if(!login){
		login=&quot;&quot;;
	}
	if(!password){
		password=&quot;&quot;;
	}
  
  	st = raw_string(0x00,0x00,
    	  		len_hi, len_low, 0xFF, 0x53, 0x4D, 0x42, 0x73, 0x00,
			0x00, 0x00, 0x00, 0x18, 0x01, 0x20, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
			0x00, 0x00, 0x0A, 0xFF, 0x00, 0x00, 0x00, 0x04,
			0x11, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, pass_len_lo,  pass_len_hi, 0x00, 0x00, 0x00, 0x00,
			bcc_lo, bcc_hi) + password +
	     raw_string(0) + login + raw_string(0x00);
	  
  	if(domain){
  		st = st + domain + raw_string(0x00);
	}
	
	st = st + native_os + raw_string(0x00) + native_lanmanager + raw_string(0x00);
  	send(socket:soc, data:st);
  	r = smb_recv(socket:soc, length:1024); 
  	if(strlen(r) &lt; 9){
		return(NULL);
	}
	if(ord(r[9])==0){
		return(r);
	}
 	else {
		return(NULL);
	}
 }

 #------------------------NTLMSSP utilities start--------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_tconx">smb_tconx</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>name</dt>
			
		
			<dt>share</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb_tconx(soc, name, uid, share)
{
  if(strlen(uid) ==8)
  {
    response = smb2_tconx(soc:soc, name:name, share:share, uid:uid);
    return(response);
  }
  else {
    if(ntlmssp_flag)
    {
      response = smb_tconx_NTLMSSP(soc:soc, name:name, uid:uid, share:share);
      return(response);
    }
    else{
      high = uid / 256;
      low = uid % 256;
      local_var req;
      len = 48 + strlen(name) + strlen(share) + 6;
      ulen = 5 + strlen(name) + strlen(share) + 6;
      req = raw_string(0x00, 0x00, 0x00, len, 0xFF, 0x53, 0x4D, 0x42, 0x75, 0x00,
                       0x00, 0x00, 0x00, 0x08, 0xc8, 0x01, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x28, low, high, 0x00, 0x00, 0x04, 0xFF, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x01, 0x00, ulen, 0x00, 0x00, 0x5C, 0x5C) + name +
                       raw_string(0x5C) + share +raw_string(0x00) + &quot;?????&quot;  +
                       raw_string(0x00);
      send(socket:soc, data:req);
      r = smb_recv(socket:soc, length:1024);
      if(strlen(r) &lt; 10){
        return(FALSE);
      }
      if(ord(r[9])==0){
        return(r);
      }
      else {
            return(FALSE);
      }
    }
  }
}

function smb2_tconx(soc, name, share, uid)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_tconx_NTLMSSP">smb_tconx_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>name</dt>
			
		
			<dt>share</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb_tconx_NTLMSSP(soc, name, uid, share)
 {
        high = uid / 256;
        low = uid % 256;
        local_var req, n, nm, sh;
	n = chomp(name);
        nm = insert_hexzeros(in:n);
        sh = insert_hexzeros(in:share);

        ulen = 8 + strlen(nm) + strlen(sh) + 6;
        len = 43 + ulen;
        #Assuming case: NEGOTIATE_SECURITY_USER_LEVEL enabled
        passlen = 1;
        pwd = &quot;&quot;;

        #TO DO: cases SECURITY_CHALLENGE_RESPONSE or otherwise

        len += passlen;
        ulen += passlen;
        len_hi = len / 256;
        len_lo = len % 256;
        ulen_hi = ulen / 256;
        ulen_lo = ulen % 256;
        passlen_hi = passlen / 256;
        passlen_lo = passlen % 256;
        g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;
        req = raw_string(0x00, 0x00) + raw_string(len_hi) + raw_string(len_lo) +
        	 raw_string(0xFF, 0x53, 0x4D, 0x42, 0x75, 0x00,
                            0x00, 0x00, 0x00, 0x08);
        if(isSignActive){
                req +=  raw_string(0x05, 0xc8);
        }
        else{
                req += raw_string(0x01, 0xc8);
        }
        req += raw_string(0x00, 0x00);
        #putting signature null initially
        req += raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
        req += raw_string(0x00, 0x00, 0xff, 0xff, 0x33, 0x0c, low, high,
                             g_mlo, g_mhi, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x08,
                             0x00, passlen_lo, passlen_hi, ulen_lo, ulen_hi);#43
        if(passlen == 1)
                req += raw_string(0x00);
        else
                req += pwd;
        req += raw_string(0x5C, 0x00, 0x5C, 0x00) + nm + raw_string(0x5C, 0x00) + sh + raw_string(0x00, 0x00) + &quot;?????&quot; + raw_string(0x00);
        if(isSignActive){
                len += 4;
                seq_number += 1;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }
	send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:1024);
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
        multiplex_id += 1;
        if(isSignActive){
                # verify signature
                seq_number += 1;
                len = strlen(r);
                server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                orig_sign = substr(r, 18, 23);
                serv_sign = substr(server_resp, 18, 23);
                if(orig_sign != serv_sign){
                         return(FALSE);
                }
        }
        if(ord(r[9])==0){
                return(r);
        }
        else {
                return(FALSE);
        }

 }

 #NTLMSSP

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smb_tconx_cleartext">smb_tconx_cleartext</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>name</dt>
			
		
			<dt>share</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smb_tconx_cleartext(soc, name, uid, share)
{
  high = uid / 256;
  low = uid % 256;
  local_var req;
  len = 48 + strlen(name) + strlen(share) + 6;
  ulen = 5 + strlen(name) + strlen(share) + 6;
  req = raw_string(0x00, 0x00, 0x00, len, 0xFF, 0x53, 0x4D,
                   0x42, 0x75, 0x00, 0x00, 0x00, 0x00, 0x08,
                   0xc8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x28, low, high, 0x00,
                   0x00, 0x04, 0xFF, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x01, 0x00, ulen, 0x00, 0x00, 0x5C,
                   0x5C) + name + raw_string(0x5C) + share +
                   raw_string(0x00) + &quot;?????&quot;  + raw_string(0x00);

  send(socket:soc, data:req);
  r = smb_recv(socket:soc, length:1024);

  if(strlen(r) &lt; 10){
    return(FALSE);
  }

  if(ord(r[9])==0){
    return(r);
  }
  else{
    return(FALSE);
  }
}

function smb_tconx(soc, name, uid, share)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smbntcreatex">smbntcreatex</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>always_return_blob</dt>
			
		
			<dt>name</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smbntcreatex(soc, uid, tid, name, always_return_blob)
 {
   if (strlen(uid) == 8)
   {
     response = smb2ntcreatex(soc:soc, uid:uid, tid:tid, name:&quot;\winreg&quot;);
     return(response);
   }
   else
   {
     response = smb1ntcreatex(soc:soc, uid:uid, tid:tid, name:&quot;\winreg&quot;);
     return(response);
   }
 }

function smb1ntcreatex(soc, uid, tid, name, always_return_blob)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smbntcreatex_NTLMSSP">smbntcreatex_NTLMSSP</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>always_return_blob</dt>
			
		
			<dt>name</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
function smbntcreatex_NTLMSSP(soc, uid, tid, name, always_return_blob)
 {

        tid_high = tid / 256;
        tid_low  = tid % 256;

        uid_high = uid / 256;
        uid_low  = uid % 256;

        g_mhi = multiplex_id / 256;
        g_mlo = multiplex_id % 256;

        req = raw_string(0xFF, 0x53, 0x4D, 0x42, 0xA2, 0x00,
                         0x00, 0x00, 0x00, 0x18);
        
        if(isSignActive){
                        req += raw_string(0x07, 0x00);
        }
        else
                req += raw_string(0x03, 0x00);
        req += raw_string(0x50, 0x81,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, tid_low, tid_high,0x33, 0x0c);
        namelen = strlen(name);
        name_hi = namelen / 256;
        name_lo = namelen % 256;

        req += raw_string(uid_low, uid_high,
                         g_mlo, g_mhi, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00,
                         name_lo, name_hi, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x9F, 0x01, 0x02, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
                         0x00, 0x00, 0x00, (strlen(name)+1) % 256, 0x00) + name +
              		 raw_string(0x00);
	req = raw_string(0x00, 0x00, 0x00, (strlen(req)%256)) + req;
	if(isSignActive){
                len  = strlen(req);
		seq_number += 1;
                req = get_signature(key:s_sign_key, buf:req, buflen:len, seq_number:seq_number);
        }
	
 	send(socket:soc, data:req);
        r = smb_recv(socket:soc, length:4000);
        if(always_return_blob){
                return(r);
        }
        if(strlen(r) &lt; 10){
                return(FALSE);
        }
	multiplex_id += 1;
        if(isSignActive){
                # verify signature
                seq_number += 1;
                len = strlen(r);
                server_resp = get_signature(key:s_sign_key, buf:r, buflen:len, seq_number:seq_number);
                orig_sign = substr(r, 18, 23);
                serv_sign = substr(server_resp, 18, 23);
                if(orig_sign != serv_sign){
                         return(FALSE);
                }
        }

        if(ord(r[9])==0x00){
                return(r);
        }
        else {
                return(FALSE);
        }
 }

 function smb2ntcreatex_NTLMSSP(soc, uid, tid, name, always_return_blob)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="smbntcreatex_extract_pipe">smbntcreatex_extract_pipe</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>reply</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function smbntcreatex_extract_pipe(reply)
 {
   if(strlen(reply) &lt; 44){
    return(FALSE);
   }
   if(ord(reply[4]) == 254)
   {
     ret = smb2ntcreatex_extract_pipe(reply);
     return(ret);
   }
   else{
    low = ord(reply[42]);
    high = ord(reply[43]);
    ret = high * 256;
    ret = ret + low;
    return(ret);
   }
 }

#--------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="tconx_extract_tid">tconx_extract_tid</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>reply</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function tconx_extract_tid(reply)
 {
   if(strlen(reply) &lt; 30){
     return(FALSE);
   }

   if(ord(reply[4]) == 254)
   {
     ret = smb2_tconx_extract_tid(reply);
     return(ret);
   }
   else{
     low = ord(reply[28]);
     high = ord(reply[29]);
     ret = high * 256;
     ret = ret + low;
     return(ret);
   }
 }


#------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="unicode">unicode</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function unicode(data)
 {
	local_var i;
	len = strlen(data);
	ret = raw_string(ord(data[0]));
	for(i=1;i&lt;len;i=i+1){
		ret = string(ret, raw_string(0, ord(data[i])));
	}
 
	if(!(len &amp; 1)){
		even = 1;
	}
	else {
		even = 0;
	}
 
	for(i=0;i&lt;7;i=i+1){
		ret = ret + raw_string(0);
	}

	if(even){
		ret = ret + raw_string(0x00, 0x00);
	}
	return(ret);
 }

 #----------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="unicode2">unicode2</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function unicode2(data)
 {
	local_var i;
 	len = strlen(data);
	ret = raw_string(0, ord(data[0]));
 
	for(i=1; i&lt;len; i=i+1){
  		ret = ret + raw_string(0, ord(data[i]));
	}
	if(len &amp; 1){
		ret = ret + raw_string(0x00, 0x00);
	}
	else {
		ret = ret + raw_string(0x00, 0x00, 0x00, 0x63);
	}
	return(ret);
 }

 function unicode3(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="unicode3">unicode3</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function unicode3(data)
 {
	local_var i;
 	len = strlen(data);
	ret = raw_string(0, ord(data[0]));
 
	for(i=1; i&lt;len; i=i+1){
  		ret = ret + raw_string(0, ord(data[i]));
	}
	if(len &amp; 1){
		ret = ret + raw_string(0x00, 0x00);
	}
	else {
		ret = ret + raw_string(0x00, 0x00, 0x00, 0x00);
	}
	return(ret);
 }

 function unicode4(data)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="unicode4">unicode4</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>data</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function unicode4(data)
 {
	local_var i;
 	len = strlen(data);
	ret = raw_string(0, ord(data[0]));
 
	for(i=1; i&lt;len; i=i+1){
		ret = ret + raw_string(ord(data[i]),0);
	}
	if(len &amp; 1){
		ret = ret + raw_string(0x00);
	}
	return(ret);
 }

 function registry_get_item_sz(soc, uid, tid, pipe, item, reply)

		</pre>
		<a href="#top">top</a>
		<hr>
		
		
		
		
		<h1>Private Function Details</h1>
		
		<h2 id="_ExtractTime">_ExtractTime</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>base</dt>
			
		
			<dt>buffer</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function _ExtractTime(buffer, base)
 {
	if(strlen(buffer) &lt; base + 8){
		return(FALSE);
	}

	return(string(hex(ord(buffer[base+7])), &quot;-&quot;,
 		      hex(ord(buffer[base+6])), &quot;-&quot;,
		      hex(ord(buffer[base+5])), &quot;-&quot;,
		      hex(ord(buffer[base+4])), &quot;-&quot;,
		      hex(ord(buffer[base+3])), &quot;-&quot;,
		      hex(ord(buffer[base+2])), &quot;-&quot;,
		      hex(ord(buffer[base+1])), &quot;-&quot;,
		      hex(ord(buffer[base]))));
 }

 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="_SamrDecodeUserInfo">_SamrDecodeUserInfo</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>count</dt>
			
		
			<dt>info</dt>
			
		
			<dt>type</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function _SamrDecodeUserInfo(info, count, type)
 {
 	lim = strlen(info);

	if(strlen(info) &lt; 100){
 		return(FALSE);
	}
	
	# Various times
 	logon = _ExtractTime(buffer:info, base:92);
	#display(&quot;Logon time : &quot;, logon, &quot;\n&quot;);
 
	set_kb_item(name:string(&quot;SMB/&quot;, type, &quot;/&quot;, count, &quot;/Info/LogonTime&quot;),
 		    value:logon);
	     
 	logoff = _ExtractTime(buffer:info, base:100);
	#display(&quot;Logoff time : &quot;, logoff, &quot;\n&quot;);
	set_kb_item(name:string(&quot;SMB/&quot;, type, &quot;/&quot;, count, &quot;/Info/LogoffTime&quot;),
 		    value:logoff);

	if(strlen(info) &lt; 116){
		return(FALSE);
	}
 
 	kickoff = _ExtractTime(buffer:info, base:108);
	#display(&quot;Kickoff time : &quot;, kickoff, &quot;\n&quot;);
	set_kb_item(name:string(&quot;SMB/&quot;, type, &quot;/&quot;, count, &quot;/Info/KickoffTime&quot;),
 		    value:kickoff);

	base = 116;
	pass_last_set = _ExtractTime(buffer:info, base:116);

	if(strlen(info) &lt; 124){
 		return(FALSE);
 	}

	#display(&quot;Pass last set : &quot;, pass_last_set, &quot;\n&quot;);		     
	set_kb_item(name:string(&quot;SMB/&quot;, type, &quot;/&quot;, count, &quot;/Info/PassLastSet&quot;),
 		    value:pass_last_set); 

	pass_can_change = _ExtractTime(buffer:info, base:124);
	#display(&quot;Pass can change : &quot;, pass_can_change,&quot;\n&quot;);
	set_kb_item(name:string(&quot;SMB/&quot;, type, &quot;/&quot;, count, &quot;/Info/PassCanChange&quot;),
 		    value:pass_can_change);
 
	pass_must_change = _ExtractTime(buffer:info, base:132);
 
	#display(&quot;Pass must change : &quot;, pass_must_change, &quot;\n&quot;);
	set_kb_item(name:string(&quot;SMB/&quot;, type, &quot;/&quot;, count, &quot;/Info/PassMustChange&quot;),
 		    value:pass_must_change);
 
	# ACB
 	if(strlen(info) &lt; 260){
		return(FALSE);
 	}
 
	acb_lo = ord(info[260]);
	acb_hi = ord(info[261]);
	acb = acb_hi * 256;
	acb = acb + acb_lo;
	#display(&quot;ACB : &quot;, hex(acb), &quot;\n&quot;);
 
	set_kb_item(name:string(&quot;SMB/&quot;, type, &quot;/&quot;, count, &quot;/Info/ACB&quot;), value:acb);
	     
 	#if(acb &amp; 0x01)display(&quot;  Account is disabled\n&quot;);
	#if(acb &amp; 0x04)display(&quot;  Password not required\n&quot;);
	#if(acb &amp; 0x10)display(&quot;  Normal account\n&quot;);
	#if(acb &amp; 0x0200)display(&quot;  Password does not expire\n&quot;);
	#if(acb &amp; 0x0400)display(&quot;  Account auto-locked\n&quot;);
	#if(acb &amp; 0x0800)display(&quot;  Password can&#39;t be changed\n&quot;);
  
	#if(acb &amp; 0x1000)display(&quot;  Smart card is required for interactive log on\n&quot;);
	#if(acb &amp; 0x2000)display(&quot;  Account is trusted for delegation\n&quot;);
	#if(acb &amp; 0x4000)display(&quot;  Account is sensitive an can not be delegated\n&quot;);
	#if(acb &amp; 0x8000)display(&quot;  Use DES encryption type for this account\n&quot;);
 }

 #

		</pre>
		<a href="#top">top</a>
		<hr>
		
		<h2 id="_SamrEnumDomains">_SamrEnumDomains</h2>
		

		

		
		<h3>Named Parameters</h3>
		<dl>

		
			<dt>pipe</dt>
			
		
			<dt>samrhdl</dt>
			
		
			<dt>soc</dt>
			
		
			<dt>tid</dt>
			
		
			<dt>uid</dt>
			
		
		</dl>
		

		

		<h3>Code</h3>
                <!-- The contents must not have indentation, else formatting is off. -->
		<pre class="brush: nasl">
 function _SamrEnumDomains(soc, uid, tid, pipe, samrhdl)
 {
	local_var i;
 	tid_hi = tid / 256;
	tid_lo = tid % 256;
	uid_hi = uid / 256;
	uid_lo = uid % 256;
 
	pipe_hi = pipe / 256;
	pipe_lo = pipe % 256;
 
	req = raw_string(0x00, 0x00,
 			 0x00, 0x88, 0xFF, 0x53, 0x4D, 0x42, 0x25, 0x00,
			 0x00, 0x00, 0x00, 0x18, 0x07, 0xC8, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, tid_lo, tid_hi, 0x00, 0x28, uid_lo, uid_hi,
			 g_mlo, g_mhi, 0x10, 0x00, 0x00, 0x34, 0x00, 0x00,
			 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
			 0x00, 0x34, 0x00, 0x54, 0x00, 0x02, 0x00, 0x26,
			 0x00, pipe_lo, pipe_hi, 0x45, 0x00, 0x00, 0x5C, 0x00,
			 0x50, 0x00, 0x49, 0x00, 0x50, 0x00, 0x45, 0x00,
			 0x5C, 0x00, 0x00, 0x00, 0xAF, 0x47, 0x05, 0x00,
			 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x34, 0x00,
			 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x00,
			 0x00, 0x00, 0x00, 0x00, 0x06, 0x00) + samrhdl +
	      raw_string(0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00);
		  
	send(socket:soc, data:req);
	r = smb_recv(socket:soc, length:4096);		  
	if(strlen(r) &lt; 137){
		return(FALSE);
	}
 
	len_lo = ord(r[136]);
	len_hi = ord(r[137]);
 
	len = len_hi * 256;
	len = len + len_lo;
	dom = &quot;&quot;;
	len = len*2;
	maxlen = strlen(r);
	if(maxlen &lt; len)return(FALSE);
	for(i=0; i&lt;len; i=i+2)
	{
  		if(maxlen &lt; 139+i){
			return(FALSE);
		}
		dom = dom + raw_string(ord(r[139+i]), ord(r[140+i]));
 	}
	#display(dom, &quot;\n&quot;);
	return(dom);  
 }


 #------------------------------------------------------#

		</pre>
		<a href="#top">top</a>
		<hr>
		
		
		

	</div><!--/span-->
	</div><!--/row-->

	<hr>

	<footer>
		<p>&copy; Tenable Network Security 2014</p>
	</footer>

  </div><!--/.fluid-container-->

  <!-- Le javascript
  ================================================== -->
  <!-- Placed at the end of the document so the pages load faster -->
  <script type="text/javascript" src="js/jquery-1.8.2.js"></script>
  <script type="text/javascript" src="js/bootstrap.min.js"></script>
  <script type="text/javascript" src="js/shCore.js"></script>
  <script type="text/javascript" src="js/shBrushNasl.js"></script>

  <script type="text/javascript">
    SyntaxHighlighter.defaults['collapse'] = true;
    SyntaxHighlighter.defaults['gutter'] = false;
    SyntaxHighlighter.all();
  </script>

  </body>
</html>
